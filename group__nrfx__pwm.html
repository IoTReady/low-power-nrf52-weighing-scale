<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: PWM driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nrfx__pwm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">PWM driver<div class="ingroups"><a class="el" href="group__nrfx__drivers.html">Drivers</a> &raquo; <a class="el" href="group__nrf__pwm.html">PWM</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Pulse Width Modulation (PWM) peripheral driver.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver instance data structure.  <a href="structnrfx__pwm__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver configuration structure.  <a href="structnrfx__pwm__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga248fea7bfb810bed3145b9927b7ab679"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga248fea7bfb810bed3145b9927b7ab679">NRFX_PWM_INSTANCE</a>(id)</td></tr>
<tr class="memdesc:ga248fea7bfb810bed3145b9927b7ab679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating a PWM driver instance.  <a href="group__nrfx__pwm.html#ga248fea7bfb810bed3145b9927b7ab679">More...</a><br /></td></tr>
<tr class="separator:ga248fea7bfb810bed3145b9927b7ab679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d0f4652322f07b3225d8be97984bfdc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga8d0f4652322f07b3225d8be97984bfdc">NRFX_PWM_PIN_NOT_USED</a>&#160;&#160;&#160;0xFF</td></tr>
<tr class="memdesc:ga8d0f4652322f07b3225d8be97984bfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value can be provided instead of a pin number for any channel to specify that its output is not used and therefore does not need to be connected to a pin.  <a href="group__nrfx__pwm.html#ga8d0f4652322f07b3225d8be97984bfdc">More...</a><br /></td></tr>
<tr class="separator:ga8d0f4652322f07b3225d8be97984bfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga730fb957fc2eec7d963a44f6631bbb63"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga730fb957fc2eec7d963a44f6631bbb63">NRFX_PWM_PIN_INVERTED</a>&#160;&#160;&#160;0x80</td></tr>
<tr class="memdesc:ga730fb957fc2eec7d963a44f6631bbb63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value can be added to a pin number to inverse its polarity (set idle state = 1).  <a href="group__nrfx__pwm.html#ga730fb957fc2eec7d963a44f6631bbb63">More...</a><br /></td></tr>
<tr class="separator:ga730fb957fc2eec7d963a44f6631bbb63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7090e8b64090dcc4d3b5c5d9283452e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad7090e8b64090dcc4d3b5c5d9283452e">NRFX_PWM_DEFAULT_CONFIG</a></td></tr>
<tr class="memdesc:gad7090e8b64090dcc4d3b5c5d9283452e"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver default configuration.  <a href="group__nrfx__pwm.html#gad7090e8b64090dcc4d3b5c5d9283452e">More...</a><br /></td></tr>
<tr class="separator:gad7090e8b64090dcc4d3b5c5d9283452e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga6c253f31a35919400ef71aa81443daf9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga6c253f31a35919400ef71aa81443daf9">nrfx_pwm_handler_t</a>) (<a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> event_type)</td></tr>
<tr class="memdesc:ga6c253f31a35919400ef71aa81443daf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event handler type.  <a href="group__nrfx__pwm.html#ga6c253f31a35919400ef71aa81443daf9">More...</a><br /></td></tr>
<tr class="separator:ga6c253f31a35919400ef71aa81443daf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaeb8d583a31cccbb8cf9b452a8e298063"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__nrfx__pwm.html#ggaeb8d583a31cccbb8cf9b452a8e298063a7b007406bbb1602db5ddd3c55031ceb8">NRFX_PWM_ENABLED_COUNT</a>
 }</td></tr>
<tr class="separator:gaeb8d583a31cccbb8cf9b452a8e298063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a> = 0x01
, <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad">NRFX_PWM_FLAG_LOOP</a> = 0x02
, <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> = 0x04
, <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> = 0x08
, <br />
&#160;&#160;<a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465">NRFX_PWM_FLAG_NO_EVT_FINISHED</a> = 0x10
, <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> = 0x80
<br />
 }</td></tr>
<tr class="memdesc:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM flags providing additional playback options.  <a href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">More...</a><br /></td></tr>
<tr class="separator:ga68ffb6414b8b5e07ddb4e14431b2bd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd252a13f482085e89e23516b8a422a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> { <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f">NRFX_PWM_EVT_FINISHED</a>
, <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a>
, <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a>
, <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a>
 }</td></tr>
<tr class="memdesc:ga3bd252a13f482085e89e23516b8a422a"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM driver event type.  <a href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">More...</a><br /></td></tr>
<tr class="separator:ga3bd252a13f482085e89e23516b8a422a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf06bb9053293005bc91217e5a1791261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gaf06bb9053293005bc91217e5a1791261">nrfx_pwm_init</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *p_config, <a class="el" href="group__nrfx__pwm.html#ga6c253f31a35919400ef71aa81443daf9">nrfx_pwm_handler_t</a> handler)</td></tr>
<tr class="memdesc:gaf06bb9053293005bc91217e5a1791261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the PWM driver.  <a href="group__nrfx__pwm.html#gaf06bb9053293005bc91217e5a1791261">More...</a><br /></td></tr>
<tr class="separator:gaf06bb9053293005bc91217e5a1791261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d39f32db25a3bd9c61eeb9f719be6b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga8d39f32db25a3bd9c61eeb9f719be6b3">nrfx_pwm_uninit</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance)</td></tr>
<tr class="memdesc:ga8d39f32db25a3bd9c61eeb9f719be6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing the PWM driver.  <a href="group__nrfx__pwm.html#ga8d39f32db25a3bd9c61eeb9f719be6b3">More...</a><br /></td></tr>
<tr class="separator:ga8d39f32db25a3bd9c61eeb9f719be6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbdadeeba36d9f70239f9cf08f4c9ff4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gafbdadeeba36d9f70239f9cf08f4c9ff4">nrfx_pwm_simple_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:gafbdadeeba36d9f70239f9cf08f4c9ff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a single sequence playback.  <a href="group__nrfx__pwm.html#gafbdadeeba36d9f70239f9cf08f4c9ff4">More...</a><br /></td></tr>
<tr class="separator:gafbdadeeba36d9f70239f9cf08f4c9ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ace01a636ac528b3c233e0ae661e5e7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga9ace01a636ac528b3c233e0ae661e5e7">nrfx_pwm_complex_playback</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_0, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence_1, uint16_t playback_count, uint32_t flags)</td></tr>
<tr class="memdesc:ga9ace01a636ac528b3c233e0ae661e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for starting a two-sequence playback.  <a href="group__nrfx__pwm.html#ga9ace01a636ac528b3c233e0ae661e5e7">More...</a><br /></td></tr>
<tr class="separator:ga9ace01a636ac528b3c233e0ae661e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2428ab5f507f0e84f4f7c535cc973fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga2428ab5f507f0e84f4f7c535cc973fa1">nrfx_pwm_step</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance)</td></tr>
<tr class="memdesc:ga2428ab5f507f0e84f4f7c535cc973fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for advancing the active sequence.  <a href="group__nrfx__pwm.html#ga2428ab5f507f0e84f4f7c535cc973fa1">More...</a><br /></td></tr>
<tr class="separator:ga2428ab5f507f0e84f4f7c535cc973fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d372f2f710abacd79ec5aefc358c8af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga7d372f2f710abacd79ec5aefc358c8af">nrfx_pwm_stop</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, bool wait_until_stopped)</td></tr>
<tr class="memdesc:ga7d372f2f710abacd79ec5aefc358c8af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for stopping the sequence playback.  <a href="group__nrfx__pwm.html#ga7d372f2f710abacd79ec5aefc358c8af">More...</a><br /></td></tr>
<tr class="separator:ga7d372f2f710abacd79ec5aefc358c8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acf4c1265c548ce1f891b0f80e75ec7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga5acf4c1265c548ce1f891b0f80e75ec7">nrfx_pwm_is_stopped</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance)</td></tr>
<tr class="memdesc:ga5acf4c1265c548ce1f891b0f80e75ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking the status of the PWM peripheral.  <a href="group__nrfx__pwm.html#ga5acf4c1265c548ce1f891b0f80e75ec7">More...</a><br /></td></tr>
<tr class="separator:ga5acf4c1265c548ce1f891b0f80e75ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab74da7834ea60b27b278662ede880384"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gab74da7834ea60b27b278662ede880384">nrfx_pwm_sequence_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *p_sequence)</td></tr>
<tr class="memdesc:gab74da7834ea60b27b278662ede880384"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the sequence data during playback.  <a href="group__nrfx__pwm.html#gab74da7834ea60b27b278662ede880384">More...</a><br /></td></tr>
<tr class="separator:gab74da7834ea60b27b278662ede880384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd54088a2789e7751871a1745b3207ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gabd54088a2789e7751871a1745b3207ec">nrfx_pwm_sequence_values_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, <a class="el" href="unionnrf__pwm__values__t.html">nrf_pwm_values_t</a> values)</td></tr>
<tr class="memdesc:gabd54088a2789e7751871a1745b3207ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the pointer to the duty cycle values in the specified sequence during playback.  <a href="group__nrfx__pwm.html#gabd54088a2789e7751871a1745b3207ec">More...</a><br /></td></tr>
<tr class="separator:gabd54088a2789e7751871a1745b3207ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f0ba95dcabb3e78197e10f5b1666dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad4f0ba95dcabb3e78197e10f5b1666dc">nrfx_pwm_sequence_length_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, uint16_t length)</td></tr>
<tr class="memdesc:gad4f0ba95dcabb3e78197e10f5b1666dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the number of duty cycle values in the specified sequence during playback.  <a href="group__nrfx__pwm.html#gad4f0ba95dcabb3e78197e10f5b1666dc">More...</a><br /></td></tr>
<tr class="separator:gad4f0ba95dcabb3e78197e10f5b1666dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13477b80691014995ef33cdc1b97a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gac13477b80691014995ef33cdc1b97a0a">nrfx_pwm_sequence_repeats_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, uint32_t repeats)</td></tr>
<tr class="memdesc:gac13477b80691014995ef33cdc1b97a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the number of repeats for duty cycle values in specified sequence during playback.  <a href="group__nrfx__pwm.html#gac13477b80691014995ef33cdc1b97a0a">More...</a><br /></td></tr>
<tr class="separator:gac13477b80691014995ef33cdc1b97a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13f7c4b37a0b4f83f7251f4e096cdf42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga13f7c4b37a0b4f83f7251f4e096cdf42">nrfx_pwm_sequence_end_delay_update</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, uint8_t seq_id, uint32_t end_delay)</td></tr>
<tr class="memdesc:ga13f7c4b37a0b4f83f7251f4e096cdf42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the additional delay after the specified sequence during playback.  <a href="group__nrfx__pwm.html#ga13f7c4b37a0b4f83f7251f4e096cdf42">More...</a><br /></td></tr>
<tr class="separator:ga13f7c4b37a0b4f83f7251f4e096cdf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d26ec5e3a8d62940cbbe656e15bfa03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga0d26ec5e3a8d62940cbbe656e15bfa03">nrfx_pwm_task_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a> task)</td></tr>
<tr class="memdesc:ga0d26ec5e3a8d62940cbbe656e15bfa03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM task that can be used in PPI module.  <a href="group__nrfx__pwm.html#ga0d26ec5e3a8d62940cbbe656e15bfa03">More...</a><br /></td></tr>
<tr class="separator:ga0d26ec5e3a8d62940cbbe656e15bfa03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0a61720521d98af91339130a23ec658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gae0a61720521d98af91339130a23ec658">nrfx_pwm_event_address_get</a> (<a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const p_instance, <a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a> event)</td></tr>
<tr class="memdesc:gae0a61720521d98af91339130a23ec658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for returning the address of a specified PWM event that can be used in PPI module.  <a href="group__nrfx__pwm.html#gae0a61720521d98af91339130a23ec658">More...</a><br /></td></tr>
<tr class="separator:gae0a61720521d98af91339130a23ec658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf21b42033820b0cce64a0585477bc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga1cf21b42033820b0cce64a0585477bc2">nrfx_pwm_0_irq_handler</a> (void)</td></tr>
<tr class="separator:ga1cf21b42033820b0cce64a0585477bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad44087ebb8caed1df4f77af13e828108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gad44087ebb8caed1df4f77af13e828108">nrfx_pwm_1_irq_handler</a> (void)</td></tr>
<tr class="separator:gad44087ebb8caed1df4f77af13e828108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5acf384dc138389edb3d5dad4480094"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#gaa5acf384dc138389edb3d5dad4480094">nrfx_pwm_2_irq_handler</a> (void)</td></tr>
<tr class="separator:gaa5acf384dc138389edb3d5dad4480094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a2dac86a76e69a7051fb24453b54249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrfx__pwm.html#ga9a2dac86a76e69a7051fb24453b54249">nrfx_pwm_3_irq_handler</a> (void)</td></tr>
<tr class="separator:ga9a2dac86a76e69a7051fb24453b54249"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Pulse Width Modulation (PWM) peripheral driver. </p>
<p>Copyright (c) 2015 - 2018, Nordic Semiconductor ASA</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form, except as embedded into a Nordic Semiconductor ASA integrated circuit in a product or a software update for such product, must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of Nordic Semiconductor ASA nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
<li>This software, with or without modification, must only be used with a Nordic Semiconductor ASA integrated circuit.</li>
<li>Any software provided in binary form under this license must not be reverse engineered, decompiled, modified and/or disassembled.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gad7090e8b64090dcc4d3b5c5d9283452e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7090e8b64090dcc4d3b5c5d9283452e">&#9670;&nbsp;</a></span>NRFX_PWM_DEFAULT_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_DEFAULT_CONFIG</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                          \</div>
<div class="line">    .output_pins  = { <a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#ae47e25a4270f19fad1db05d74789cc99">NRFX_PWM_DEFAULT_CONFIG_OUT0_PIN</a>,                    \</div>
<div class="line">                      NRFX_PWM_DEFAULT_CONFIG_OUT1_PIN,                    \</div>
<div class="line">                      NRFX_PWM_DEFAULT_CONFIG_OUT2_PIN,                    \</div>
<div class="line">                      NRFX_PWM_DEFAULT_CONFIG_OUT3_PIN },                  \</div>
<div class="line">    .irq_priority = <a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a097ff5d073d1266dde45fbe2b0dbddc9">NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</a>,                  \</div>
<div class="line">    .base_clock   = (<a class="code" href="group__nrf__pwm__hal.html#ga8479da20e14394fb2388b1be3b879670">nrf_pwm_clk_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a6cad4e008f74d9a464d86b5b32422005">NRFX_PWM_DEFAULT_CONFIG_BASE_CLOCK</a>,     \</div>
<div class="line">    .count_mode   = (<a class="code" href="group__nrf__pwm__hal.html#ga1f29b190ff13c52895d249e07ebe92cb">nrf_pwm_mode_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#ab0e12dfd2269daf12ee42af8d79539fe">NRFX_PWM_DEFAULT_CONFIG_COUNT_MODE</a>,    \</div>
<div class="line">    .top_value    = <a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a34a78c0f3fbb073b2e5b399b1e2a66c6">NRFX_PWM_DEFAULT_CONFIG_TOP_VALUE</a>,                     \</div>
<div class="line">    .load_mode    = (<a class="code" href="group__nrf__pwm__hal.html#ga453888e5feb46774da27499ca1eeafd2">nrf_pwm_dec_load_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a48733405a8c474d7cf5abf7ba4eef89f">NRFX_PWM_DEFAULT_CONFIG_LOAD_MODE</a>, \</div>
<div class="line">    .step_mode    = (<a class="code" href="group__nrf__pwm__hal.html#gae25a7e03c383934d33cda8a049b7dde4">nrf_pwm_dec_step_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#ae20e4c1fd83af3d09b0c5c5a065b769b">NRFX_PWM_DEFAULT_CONFIG_STEP_MODE</a>, \</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a097ff5d073d1266dde45fbe2b0dbddc9"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a097ff5d073d1266dde45fbe2b0dbddc9">NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_IRQ_PRIORITY</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2240</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a34a78c0f3fbb073b2e5b399b1e2a66c6"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a34a78c0f3fbb073b2e5b399b1e2a66c6">NRFX_PWM_DEFAULT_CONFIG_TOP_VALUE</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_TOP_VALUE</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2205</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a48733405a8c474d7cf5abf7ba4eef89f"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a48733405a8c474d7cf5abf7ba4eef89f">NRFX_PWM_DEFAULT_CONFIG_LOAD_MODE</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_LOAD_MODE</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2216</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a6cad4e008f74d9a464d86b5b32422005"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a6cad4e008f74d9a464d86b5b32422005">NRFX_PWM_DEFAULT_CONFIG_BASE_CLOCK</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_BASE_CLOCK</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2191</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_ab0e12dfd2269daf12ee42af8d79539fe"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#ab0e12dfd2269daf12ee42af8d79539fe">NRFX_PWM_DEFAULT_CONFIG_COUNT_MODE</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_COUNT_MODE</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2200</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_ae20e4c1fd83af3d09b0c5c5a065b769b"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#ae20e4c1fd83af3d09b0c5c5a065b769b">NRFX_PWM_DEFAULT_CONFIG_STEP_MODE</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_STEP_MODE</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2225</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_ae47e25a4270f19fad1db05d74789cc99"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#ae47e25a4270f19fad1db05d74789cc99">NRFX_PWM_DEFAULT_CONFIG_OUT0_PIN</a></div><div class="ttdeci">#define NRFX_PWM_DEFAULT_CONFIG_OUT0_PIN</div><div class="ttdef"><b>Definition:</b> sdk_config.h:2155</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_ga1f29b190ff13c52895d249e07ebe92cb"><div class="ttname"><a href="group__nrf__pwm__hal.html#ga1f29b190ff13c52895d249e07ebe92cb">nrf_pwm_mode_t</a></div><div class="ttdeci">nrf_pwm_mode_t</div><div class="ttdoc">PWM modes of operation.</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:129</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_ga453888e5feb46774da27499ca1eeafd2"><div class="ttname"><a href="group__nrf__pwm__hal.html#ga453888e5feb46774da27499ca1eeafd2">nrf_pwm_dec_load_t</a></div><div class="ttdeci">nrf_pwm_dec_load_t</div><div class="ttdoc">PWM decoder load modes.</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:156</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_ga8479da20e14394fb2388b1be3b879670"><div class="ttname"><a href="group__nrf__pwm__hal.html#ga8479da20e14394fb2388b1be3b879670">nrf_pwm_clk_t</a></div><div class="ttdeci">nrf_pwm_clk_t</div><div class="ttdoc">PWM base clock frequencies.</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:138</div></div>
<div class="ttc" id="agroup__nrf__pwm__hal_html_gae25a7e03c383934d33cda8a049b7dde4"><div class="ttname"><a href="group__nrf__pwm__hal.html#gae25a7e03c383934d33cda8a049b7dde4">nrf_pwm_dec_step_t</a></div><div class="ttdeci">nrf_pwm_dec_step_t</div><div class="ttdoc">PWM decoder next step modes.</div><div class="ttdef"><b>Definition:</b> nrf_pwm.h:170</div></div>
</div><!-- fragment -->
<p>PWM driver default configuration. </p>

</div>
</div>
<a id="ga248fea7bfb810bed3145b9927b7ab679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga248fea7bfb810bed3145b9927b7ab679">&#9670;&nbsp;</a></span>NRFX_PWM_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                           \</div>
<div class="line">    .p_registers  = <a class="code" href="group__nrfx__common.html#ga9fced903f4d0fc450e63d40426050236">NRFX_CONCAT_2</a>(NRF_PWM, <span class="keywordtype">id</span>),             \</div>
<div class="line">    .drv_inst_idx = <a class="code" href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4">NRFX_CONCAT_3</a>(NRFX_PWM, <span class="keywordtype">id</span>, _INST_IDX), \</div>
<div class="line">}</div>
<div class="ttc" id="agroup__nrfx__common_html_ga9fced903f4d0fc450e63d40426050236"><div class="ttname"><a href="group__nrfx__common.html#ga9fced903f4d0fc450e63d40426050236">NRFX_CONCAT_2</a></div><div class="ttdeci">#define NRFX_CONCAT_2(p1, p2)</div><div class="ttdoc">Macro for concatenating two tokens in macro expansion.</div><div class="ttdef"><b>Definition:</b> nrfx_common.h:89</div></div>
<div class="ttc" id="agroup__nrfx__common_html_gaa78d21b07d22f7a4bfbd1feda51ef1f4"><div class="ttname"><a href="group__nrfx__common.html#gaa78d21b07d22f7a4bfbd1feda51ef1f4">NRFX_CONCAT_3</a></div><div class="ttdeci">#define NRFX_CONCAT_3(p1, p2, p3)</div><div class="ttdoc">Macro for concatenating three tokens in macro expansion.</div><div class="ttdef"><b>Definition:</b> nrfx_common.h:112</div></div>
</div><!-- fragment -->
<p>Macro for creating a PWM driver instance. </p>

</div>
</div>
<a id="ga730fb957fc2eec7d963a44f6631bbb63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga730fb957fc2eec7d963a44f6631bbb63">&#9670;&nbsp;</a></span>NRFX_PWM_PIN_INVERTED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_PIN_INVERTED&#160;&#160;&#160;0x80</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value can be added to a pin number to inverse its polarity (set idle state = 1). </p>

</div>
</div>
<a id="ga8d0f4652322f07b3225d8be97984bfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d0f4652322f07b3225d8be97984bfdc">&#9670;&nbsp;</a></span>NRFX_PWM_PIN_NOT_USED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRFX_PWM_PIN_NOT_USED&#160;&#160;&#160;0xFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This value can be provided instead of a pin number for any channel to specify that its output is not used and therefore does not need to be connected to a pin. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga6c253f31a35919400ef71aa81443daf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c253f31a35919400ef71aa81443daf9">&#9670;&nbsp;</a></span>nrfx_pwm_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nrfx_pwm_handler_t) (<a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a> event_type)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM driver event handler type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaeb8d583a31cccbb8cf9b452a8e298063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb8d583a31cccbb8cf9b452a8e298063">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaeb8d583a31cccbb8cf9b452a8e298063a7b007406bbb1602db5ddd3c55031ceb8"></a>NRFX_PWM_ENABLED_COUNT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ga3bd252a13f482085e89e23516b8a422a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3bd252a13f482085e89e23516b8a422a">&#9670;&nbsp;</a></span>nrfx_pwm_evt_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga3bd252a13f482085e89e23516b8a422a">nrfx_pwm_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM driver event type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aa087e425c2519f35f5db0b0a85222406f"></a>NRFX_PWM_EVT_FINISHED&#160;</td><td class="fielddoc"><p>Sequence playback finished. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30"></a>NRFX_PWM_EVT_END_SEQ0&#160;</td><td class="fielddoc"><p>End of sequence 0 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957"></a>NRFX_PWM_EVT_END_SEQ1&#160;</td><td class="fielddoc"><p>End of sequence 1 reached. Its data can be safely modified now. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a"></a>NRFX_PWM_EVT_STOPPED&#160;</td><td class="fielddoc"><p>The PWM peripheral has been stopped. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga68ffb6414b8b5e07ddb4e14431b2bd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68ffb6414b8b5e07ddb4e14431b2bd1f">&#9670;&nbsp;</a></span>nrfx_pwm_flag_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">nrfx_pwm_flag_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM flags providing additional playback options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18"></a>NRFX_PWM_FLAG_STOP&#160;</td><td class="fielddoc"><p>When the requested playback is finished, the peripheral should be stopped. </p><dl class="section note"><dt>Note</dt><dd>The STOP task is triggered when the last value of the final sequence is loaded from RAM, and the peripheral stops at the end of the current PWM period. For sequences with configured repeating of duty cycle values, this might result in less than the requested number of repeats of the last value. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4ce524255d29bb74352584be77ac3bad"></a>NRFX_PWM_FLAG_LOOP&#160;</td><td class="fielddoc"><p>When the requested playback is finished, it should be started from the beginning. This flag is ignored if used together with <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa4b95e8b694bd8ccea5732ecdb50dcc18">NRFX_PWM_FLAG_STOP</a>. </p><dl class="section note"><dt>Note</dt><dd>The playback restart is done via a shortcut configured in the PWM peripheral. This shortcut triggers the proper starting task when the final value of previous playback is read from RAM and applied to the pulse generator counter. When this mechanism is used together with the <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode, the playback restart will occur right after switching to the final value (this final value will be played only once). </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ0&#160;</td><td class="fielddoc"><p>The event handler should be called when the last value from sequence 0 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa"></a>NRFX_PWM_FLAG_SIGNAL_END_SEQ1&#160;</td><td class="fielddoc"><p>The event handler should be called when the last value from sequence 1 is loaded. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa4971c619bfc960e43ae4ac4a790a8465"></a>NRFX_PWM_FLAG_NO_EVT_FINISHED&#160;</td><td class="fielddoc"><p>The playback finished event (enabled by default) should be suppressed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec"></a>NRFX_PWM_FLAG_START_VIA_TASK&#160;</td><td class="fielddoc"><p>The playback should not be started directly by the called function. Instead, the function should only prepare it and return the address of the task to be triggered to start the playback. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga1cf21b42033820b0cce64a0585477bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf21b42033820b0cce64a0585477bc2">&#9670;&nbsp;</a></span>nrfx_pwm_0_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_0_irq_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad44087ebb8caed1df4f77af13e828108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad44087ebb8caed1df4f77af13e828108">&#9670;&nbsp;</a></span>nrfx_pwm_1_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_1_irq_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa5acf384dc138389edb3d5dad4480094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5acf384dc138389edb3d5dad4480094">&#9670;&nbsp;</a></span>nrfx_pwm_2_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_2_irq_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9a2dac86a76e69a7051fb24453b54249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a2dac86a76e69a7051fb24453b54249">&#9670;&nbsp;</a></span>nrfx_pwm_3_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_3_irq_handler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga9ace01a636ac528b3c233e0ae661e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ace01a636ac528b3c233e0ae661e5e7">&#9670;&nbsp;</a></span>nrfx_pwm_complex_playback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_complex_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a two-sequence playback. </p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (using PPI for instance). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_0</td><td>First sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence_1</td><td>Second sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a id="gae0a61720521d98af91339130a23ec658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0a61720521d98af91339130a23ec658">&#9670;&nbsp;</a></span>nrfx_pwm_event_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t nrfx_pwm_event_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga4a8ceac653433e4ac8ee8682bdef45bf">nrf_pwm_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM event that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Requested event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event address. </dd></dl>

</div>
</div>
<a id="gaf06bb9053293005bc91217e5a1791261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06bb9053293005bc91217e5a1791261">&#9670;&nbsp;</a></span>nrfx_pwm_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrfx__error__codes.html#ga2449720f8fa17b22243218068459a24b">nrfx_err_t</a> nrfx_pwm_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__config__t.html">nrfx_pwm_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrfx__pwm.html#ga6c253f31a35919400ef71aa81443daf9">nrfx_pwm_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the PWM driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Pointer to the structure with initial configuration.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">handler</td><td>Event handler provided by the user. If NULL is passed instead, event notifications are not done and PWM interrupts are disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>If the driver was already initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5acf4c1265c548ce1f891b0f80e75ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5acf4c1265c548ce1f891b0f80e75ec7">&#9670;&nbsp;</a></span>nrfx_pwm_is_stopped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_is_stopped </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking the status of the PWM peripheral. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>If the PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga13f7c4b37a0b4f83f7251f4e096cdf42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13f7c4b37a0b4f83f7251f4e096cdf42">&#9670;&nbsp;</a></span>nrfx_pwm_sequence_end_delay_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrfx_pwm_sequence_end_delay_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>end_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the additional delay after the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_delay</td><td>New end delay value (in PWM periods). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4f0ba95dcabb3e78197e10f5b1666dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f0ba95dcabb3e78197e10f5b1666dc">&#9670;&nbsp;</a></span>nrfx_pwm_sequence_length_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrfx_pwm_sequence_length_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the number of duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>New number of the duty cycle values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac13477b80691014995ef33cdc1b97a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13477b80691014995ef33cdc1b97a0a">&#9670;&nbsp;</a></span>nrfx_pwm_sequence_repeats_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrfx_pwm_sequence_repeats_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>repeats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the number of repeats for duty cycle values in specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">repeats</td><td>New number of repeats. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab74da7834ea60b27b278662ede880384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab74da7834ea60b27b278662ede880384">&#9670;&nbsp;</a></span>nrfx_pwm_sequence_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrfx_pwm_sequence_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the sequence data during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Pointer to the new sequence definition. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd54088a2789e7751871a1745b3207ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd54088a2789e7751871a1745b3207ec">&#9670;&nbsp;</a></span>nrfx_pwm_sequence_values_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrfx_pwm_sequence_values_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>seq_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionnrf__pwm__values__t.html">nrf_pwm_values_t</a>&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the pointer to the duty cycle values in the specified sequence during playback. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">seq_id</td><td>Identifier of the sequence (0 or 1). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">values</td><td>New pointer to the duty cycle values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafbdadeeba36d9f70239f9cf08f4c9ff4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbdadeeba36d9f70239f9cf08f4c9ff4">&#9670;&nbsp;</a></span>nrfx_pwm_simple_playback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrfx_pwm_simple_playback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a> const *&#160;</td>
          <td class="paramname"><em>p_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>playback_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for starting a single sequence playback. </p>
<p>To take advantage of the looping mechanism in the PWM peripheral, both sequences must be used (single sequence can be played back only once by the peripheral). Therefore, the provided sequence is internally set and played back as both sequence 0 and sequence 1. Consequently, if end of sequence notifications are required, events for both sequences should be used (that means that both the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa36819eabef2acc3106b48f0069a57213">NRFX_PWM_FLAG_SIGNAL_END_SEQ0</a> flag and the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6eff2306ea081e9c520c5a07548791fa">NRFX_PWM_FLAG_SIGNAL_END_SEQ1</a> flag should be specified and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa9548867c6bb75600cd7fb219b868fe30">NRFX_PWM_EVT_END_SEQ0</a> event and the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aaa9dc1447d439ba09dedc954f66768957">NRFX_PWM_EVT_END_SEQ1</a> event should be handled in the same way).</p>
<p>Use the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag if you want the playback to be only prepared by this function, and you want to start it later by triggering a task (using PPI for instance). The function will then return the address of the task to be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>The array containing the duty cycle values for the specified sequence must be in RAM and cannot be allocated on stack. For detailed information, see <a class="el" href="structnrf__pwm__sequence__t.html">nrf_pwm_sequence_t</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sequence</td><td>Sequence to be played back. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">playback_count</td><td>Number of playbacks to be performed (must not be 0). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Additional options. Pass any combination of <a class="el" href="group__nrfx__pwm.html#ga68ffb6414b8b5e07ddb4e14431b2bd1f">playback flags</a>, or 0 for default settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Address of the task to be triggered to start the playback if the <a class="el" href="group__nrfx__pwm.html#gga68ffb6414b8b5e07ddb4e14431b2bd1fa6c737217548bc0e09197db28b1a4f6ec">NRFX_PWM_FLAG_START_VIA_TASK</a> flag was used, 0 otherwise. </dd></dl>

</div>
</div>
<a id="ga2428ab5f507f0e84f4f7c535cc973fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2428ab5f507f0e84f4f7c535cc973fa1">&#9670;&nbsp;</a></span>nrfx_pwm_step()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrfx_pwm_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for advancing the active sequence. </p>
<p>This function only applies to <a class="el" href="group__nrf__pwm__hal.html#ggae25a7e03c383934d33cda8a049b7dde4aa64f9312c7d5928aadcaf7596e61357b">NRF_PWM_STEP_TRIGGERED</a> mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7d372f2f710abacd79ec5aefc358c8af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d372f2f710abacd79ec5aefc358c8af">&#9670;&nbsp;</a></span>nrfx_pwm_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrfx_pwm_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>wait_until_stopped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for stopping the sequence playback. </p>
<p>The playback is stopped at the end of the current PWM period. This means that if the active sequence is configured to repeat each duty cycle value for a certain number of PWM periods, the last played value might appear on the output less times than requested.</p>
<dl class="section note"><dt>Note</dt><dd>This function can be instructed to wait until the playback is stopped (by setting <code>wait_until_stopped</code> to true). Note that, depending on the length of the PMW period, this might take a significant amount of time. Alternatively, the <a class="el" href="group__nrfx__pwm.html#ga5acf4c1265c548ce1f891b0f80e75ec7">nrfx_pwm_is_stopped</a> function can be used to poll the status, or the <a class="el" href="group__nrfx__pwm.html#gga3bd252a13f482085e89e23516b8a422aa38d857ec1e12fe4a6091734678a3869a">NRFX_PWM_EVT_STOPPED</a> event can be used to get the notification when the playback is stopped, provided the event handler is defined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wait_until_stopped</td><td>If true, the function will not return until the playback is stopped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the PWM peripheral is stopped. </td></tr>
    <tr><td class="paramname">false</td><td>If the PWM peripheral is not stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0d26ec5e3a8d62940cbbe656e15bfa03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d26ec5e3a8d62940cbbe656e15bfa03">&#9670;&nbsp;</a></span>nrfx_pwm_task_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t nrfx_pwm_task_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__pwm__hal.html#ga11cb9ca8fbb773011a3ad6658914418e">nrf_pwm_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for returning the address of a specified PWM task that can be used in PPI module. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Requested task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a id="ga8d39f32db25a3bd9c61eeb9f719be6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d39f32db25a3bd9c61eeb9f719be6b3">&#9670;&nbsp;</a></span>nrfx_pwm_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrfx_pwm_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrfx__pwm__t.html">nrfx_pwm_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing the PWM driver. </p>
<p>If any sequence playback is in progress, it is stopped immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
