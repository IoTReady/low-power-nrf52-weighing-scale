<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: USB Device HAL and driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nrf__drv__usbd.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB Device HAL and driver</div>  </div>
</div><!--header-->
<div class="contents">

<p>@tagAPI52840 USB Device APIs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nrf__drv__usbd__errata"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd__errata.html">Functions to check if selected PAN is present in current chip</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__evt__t.html">nrf_drv_usbd_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event structure.  <a href="structnrf__drv__usbd__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionnrf__drv__usbd__data__ptr__t.html">nrf_drv_usbd_data_ptr_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal data pointer.  <a href="unionnrf__drv__usbd__data__ptr__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to be filled with information about the next transfer.  <a href="structnrf__drv__usbd__ep__transfer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total transfer configuration.  <a href="structnrf__drv__usbd__transfer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="unionnrf__drv__usbd__handler__t.html">nrf_drv_usbd_handler_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Universal transfer handler.  <a href="unionnrf__drv__usbd__handler__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__handler__desc__t.html">nrf_drv_usbd_handler_desc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD transfer descriptor.  <a href="structnrf__drv__usbd__handler__desc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__usbd__setup__t.html">nrf_drv_usbd_setup_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup packet structure.  <a href="structnrf__drv__usbd__setup__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga3ecfa2bc5ba0c2b9c7cd384290f27739"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ga3ecfa2bc5ba0c2b9c7cd384290f27739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes in the endpoint.  <a href="group__nrf__drv__usbd.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">More...</a><br /></td></tr>
<tr class="separator:ga3ecfa2bc5ba0c2b9c7cd384290f27739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2482239c2133ddfe1fd269f8d2c44f6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga2482239c2133ddfe1fd269f8d2c44f6c">NRF_DRV_USBD_ISOSIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="memdesc:ga2482239c2133ddfe1fd269f8d2c44f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes for isochronous endpoints.  <a href="group__nrf__drv__usbd.html#ga2482239c2133ddfe1fd269f8d2c44f6c">More...</a><br /></td></tr>
<tr class="separator:ga2482239c2133ddfe1fd269f8d2c44f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bbed2bd99a3c54cc5956f16b72061c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gab4bbed2bd99a3c54cc5956f16b72061c">NRF_DRV_USBD_FEEDER_BUFFER_SIZE</a>&#160;&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a></td></tr>
<tr class="memdesc:gab4bbed2bd99a3c54cc5956f16b72061c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The size of internal feeder buffer.  <a href="group__nrf__drv__usbd.html#gab4bbed2bd99a3c54cc5956f16b72061c">More...</a><br /></td></tr>
<tr class="separator:gab4bbed2bd99a3c54cc5956f16b72061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee0dbca6acc4af77ccbb555b2f109d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(name,  tx_buff,  tx_size,  tx_flags)</td></tr>
<tr class="memdesc:ga1ee0dbca6acc4af77ccbb555b2f109d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary macro for declaring IN transfer description with flags.  <a href="group__nrf__drv__usbd.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">More...</a><br /></td></tr>
<tr class="separator:ga1ee0dbca6acc4af77ccbb555b2f109d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad153e248ce252afaa4a3a3912e41d547"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gad153e248ce252afaa4a3a3912e41d547">NRF_DRV_USBD_TRANSFER_IN</a>(name,  tx_buff,  tx_size)&#160;&#160;&#160;    <a class="el" href="group__nrf__drv__usbd.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(name, tx_buff, tx_size, 0)</td></tr>
<tr class="memdesc:gad153e248ce252afaa4a3a3912e41d547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for declaring IN transfer description.  <a href="group__nrf__drv__usbd.html#gad153e248ce252afaa4a3a3912e41d547">More...</a><br /></td></tr>
<tr class="separator:gad153e248ce252afaa4a3a3912e41d547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec2fac985fd7d5b96629028d558796e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga9ec2fac985fd7d5b96629028d558796e">NRF_DRV_USBD_TRANSFER_IN_ZLP</a>(name,  tx_buff,  tx_size)</td></tr>
<tr class="memdesc:ga9ec2fac985fd7d5b96629028d558796e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for declaring IN transfer description.  <a href="group__nrf__drv__usbd.html#ga9ec2fac985fd7d5b96629028d558796e">More...</a><br /></td></tr>
<tr class="separator:ga9ec2fac985fd7d5b96629028d558796e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c757e4582e52975bb6dabd8f0dc1e0f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga6c757e4582e52975bb6dabd8f0dc1e0f">NRF_DRV_USBD_TRANSFER_OUT</a>(name,  rx_buff,  rx_size)</td></tr>
<tr class="memdesc:ga6c757e4582e52975bb6dabd8f0dc1e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper macro for declaring OUT transfer item (<a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a>)  <a href="group__nrf__drv__usbd.html#ga6c757e4582e52975bb6dabd8f0dc1e0f">More...</a><br /></td></tr>
<tr class="separator:ga6c757e4582e52975bb6dabd8f0dc1e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaedc9aa1b393e8a00fe0aec2e756d3397"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gaedc9aa1b393e8a00fe0aec2e756d3397">nrf_drv_usbd_event_handler_t</a>) (<a class="el" href="structnrf__drv__usbd__evt__t.html">nrf_drv_usbd_evt_t</a> const *const p_event)</td></tr>
<tr class="memdesc:gaedc9aa1b393e8a00fe0aec2e756d3397"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD event callback function type.  <a href="group__nrf__drv__usbd.html#gaedc9aa1b393e8a00fe0aec2e756d3397">More...</a><br /></td></tr>
<tr class="separator:gaedc9aa1b393e8a00fe0aec2e756d3397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb89e843d21a8d3fa695fa68ab772738"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gabb89e843d21a8d3fa695fa68ab772738">nrf_drv_usbd_feeder_t</a>) (<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size)</td></tr>
<tr class="memdesc:gabb89e843d21a8d3fa695fa68ab772738"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD transfer feeder.  <a href="group__nrf__drv__usbd.html#gabb89e843d21a8d3fa695fa68ab772738">More...</a><br /></td></tr>
<tr class="separator:gabb89e843d21a8d3fa695fa68ab772738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24496ca286682e570b1017cb8a5b8265"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga24496ca286682e570b1017cb8a5b8265">nrf_drv_usbd_consumer_t</a>) (<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size, size_t data_size)</td></tr>
<tr class="memdesc:ga24496ca286682e570b1017cb8a5b8265"><td class="mdescLeft">&#160;</td><td class="mdescRight">USBD transfer consumer.  <a href="group__nrf__drv__usbd.html#ga24496ca286682e570b1017cb8a5b8265">More...</a><br /></td></tr>
<tr class="separator:ga24496ca286682e570b1017cb8a5b8265"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaa65ebeb12443fd8325e7447a2187f70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70afb5b50c3d9680fbda0b08830f42e382f">NRF_DRV_USBD_EPOUT0</a> = NRF_USBD_EPOUT(0)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a0806d24dac06f5c0d3898cd67e405617">NRF_DRV_USBD_EPOUT1</a> = NRF_USBD_EPOUT(1)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70aaf42aef784c75192853fddefe57a2fb9">NRF_DRV_USBD_EPOUT2</a> = NRF_USBD_EPOUT(2)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a7ebbfa51beb7a0dd6ee5f071b8d35950">NRF_DRV_USBD_EPOUT3</a> = NRF_USBD_EPOUT(3)
, <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70ad4a07134f5ea54e003d4a17ee1ba4c7f">NRF_DRV_USBD_EPOUT4</a> = NRF_USBD_EPOUT(4)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a5ab577a8042f3f0f73ad3de23b0d4ba3">NRF_DRV_USBD_EPOUT5</a> = NRF_USBD_EPOUT(5)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a6da7bf30befbefaaf7f8ad79c9f1666a">NRF_DRV_USBD_EPOUT6</a> = NRF_USBD_EPOUT(6)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70af087b27308b6f18bf4bf8fff43d827f5">NRF_DRV_USBD_EPOUT7</a> = NRF_USBD_EPOUT(7)
, <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70ae53cb7398e739532f7069f4859a2d2c5">NRF_DRV_USBD_EPOUT8</a> = NRF_USBD_EPOUT(8)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70ac8e5ae481bf8a23aa2e5f9e4d9bfec24">NRF_DRV_USBD_EPIN0</a> = NRF_USBD_EPIN(0)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a78c594d15eee745ac6eb11e83c294b1b">NRF_DRV_USBD_EPIN1</a> = NRF_USBD_EPIN(1)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70acb4347afc5cebf8dc2cf6efe6825eed0">NRF_DRV_USBD_EPIN2</a> = NRF_USBD_EPIN(2)
, <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70acd14758cfae4cca0095c7ced300fc678">NRF_DRV_USBD_EPIN3</a> = NRF_USBD_EPIN(3)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a8609bbebe798a8ae69309b586c83c922">NRF_DRV_USBD_EPIN4</a> = NRF_USBD_EPIN(4)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a69321276f3de8b259f82bf3720274662">NRF_DRV_USBD_EPIN5</a> = NRF_USBD_EPIN(5)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70aaf4e021d052ef571afbf3d2f140ba3c1">NRF_DRV_USBD_EPIN6</a> = NRF_USBD_EPIN(6)
, <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a4d9d5809cd17a2bb686b6b896ea3a446">NRF_DRV_USBD_EPIN7</a> = NRF_USBD_EPIN(7)
, <a class="el" href="group__nrf__drv__usbd.html#ggaaa65ebeb12443fd8325e7447a2187f70a51de27329e5d1c525409b0d073d661c4">NRF_DRV_USBD_EPIN8</a> = NRF_USBD_EPIN(8)
<br />
 }</td></tr>
<tr class="memdesc:gaaa65ebeb12443fd8325e7447a2187f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Endpoint identifier.  <a href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">More...</a><br /></td></tr>
<tr class="separator:gaaa65ebeb12443fd8325e7447a2187f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f0b03e5a41539896e07ccba22b67b3d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga9f0b03e5a41539896e07ccba22b67b3d">nrf_drv_usbd_event_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3da5e5aa0126cace9c3e1ca9bf202fcfb76">NRF_DRV_USBD_EVT_SOF</a>
, <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dafb97ef9016ced03034a496683b9d59ef">NRF_DRV_USBD_EVT_RESET</a>
, <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3da610d9052eed8b8fa98d6d66a9b4cfd78">NRF_DRV_USBD_EVT_SUSPEND</a>
, <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3da773b2df8b85d14aae8e75b85dc75be32">NRF_DRV_USBD_EVT_RESUME</a>
, <br />
&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dad801b6ddca9ca53d8d3493675600a1bd">NRF_DRV_USBD_EVT_WUREQ</a>
, <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dad5eb9fc5f0621fa680cab1ccb8a6911d">NRF_DRV_USBD_EVT_SETUP</a>
, <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df">NRF_DRV_USBD_EVT_EPTRANSFER</a>
, <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3da76a716e60a05c83622c79910a404fd92">NRF_DRV_USBD_EVT_CNT</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9f0b03e5a41539896e07ccba22b67b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Events generated by the library.  <a href="group__nrf__drv__usbd.html#ga9f0b03e5a41539896e07ccba22b67b3d">More...</a><br /></td></tr>
<tr class="separator:ga9f0b03e5a41539896e07ccba22b67b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae51235955b1bec1393a393946544fc6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gae51235955b1bec1393a393946544fc6e">nrf_drv_usbd_ep_status_t</a> { <a class="el" href="group__nrf__drv__usbd.html#ggae51235955b1bec1393a393946544fc6ea6c64dda31a6dd80d690a078bbb713f05">NRF_USBD_EP_OK</a>
, <a class="el" href="group__nrf__drv__usbd.html#ggae51235955b1bec1393a393946544fc6ea82b67485a8aed419a744bbac8c5de806">NRF_USBD_EP_WAITING</a>
, <a class="el" href="group__nrf__drv__usbd.html#ggae51235955b1bec1393a393946544fc6ea32ddfa8d69d4f14816f5fe83fb2713fc">NRF_USBD_EP_OVERLOAD</a>
, <a class="el" href="group__nrf__drv__usbd.html#ggae51235955b1bec1393a393946544fc6ea184bf8a573eaa257384917103ae0fd9b">NRF_USBD_EP_ABORTED</a>
 }</td></tr>
<tr class="memdesc:gae51235955b1bec1393a393946544fc6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible endpoint error codes.  <a href="group__nrf__drv__usbd.html#gae51235955b1bec1393a393946544fc6e">More...</a><br /></td></tr>
<tr class="separator:gae51235955b1bec1393a393946544fc6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe244baf5655539aa3e356620f2acfc"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gacfe244baf5655539aa3e356620f2acfc">nrf_drv_usbd_transfer_flags_t</a> { <a class="el" href="group__nrf__drv__usbd.html#ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3">NRF_DRV_USBD_TRANSFER_ZLP_FLAG</a> = 1U &lt;&lt; 0
 }</td></tr>
<tr class="memdesc:gacfe244baf5655539aa3e356620f2acfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags for the current transfer.  <a href="group__nrf__drv__usbd.html#gacfe244baf5655539aa3e356620f2acfc">More...</a><br /></td></tr>
<tr class="separator:gacfe244baf5655539aa3e356620f2acfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gabf8b527764aefdbe4859981c56f96dd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gabf8b527764aefdbe4859981c56f96dd5">nrf_drv_usbd_init</a> (<a class="el" href="group__nrf__drv__usbd.html#gaedc9aa1b393e8a00fe0aec2e756d3397">nrf_drv_usbd_event_handler_t</a> const event_handler)</td></tr>
<tr class="memdesc:gabf8b527764aefdbe4859981c56f96dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library initialization.  <a href="group__nrf__drv__usbd.html#gabf8b527764aefdbe4859981c56f96dd5">More...</a><br /></td></tr>
<tr class="separator:gabf8b527764aefdbe4859981c56f96dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07274745cf2ca5867c1c50192aadaa43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga07274745cf2ca5867c1c50192aadaa43">nrf_drv_usbd_uninit</a> (void)</td></tr>
<tr class="memdesc:ga07274745cf2ca5867c1c50192aadaa43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library deinitialization.  <a href="group__nrf__drv__usbd.html#ga07274745cf2ca5867c1c50192aadaa43">More...</a><br /></td></tr>
<tr class="separator:ga07274745cf2ca5867c1c50192aadaa43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafee8557590430bd5d50d64b9363ecc7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gafee8557590430bd5d50d64b9363ecc7d">nrf_drv_usbd_enable</a> (void)</td></tr>
<tr class="memdesc:gafee8557590430bd5d50d64b9363ecc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the USBD port.  <a href="group__nrf__drv__usbd.html#gafee8557590430bd5d50d64b9363ecc7d">More...</a><br /></td></tr>
<tr class="separator:gafee8557590430bd5d50d64b9363ecc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4f73e18396c94c6c6a90114ad3de6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gaad4f73e18396c94c6c6a90114ad3de6a">nrf_drv_usbd_disable</a> (void)</td></tr>
<tr class="memdesc:gaad4f73e18396c94c6c6a90114ad3de6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the USBD port.  <a href="group__nrf__drv__usbd.html#gaad4f73e18396c94c6c6a90114ad3de6a">More...</a><br /></td></tr>
<tr class="separator:gaad4f73e18396c94c6c6a90114ad3de6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb757b8af8c827b45e306cfbd2d38045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a> (bool enable_sof)</td></tr>
<tr class="memdesc:gacb757b8af8c827b45e306cfbd2d38045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start USB functionality.  <a href="group__nrf__drv__usbd.html#gacb757b8af8c827b45e306cfbd2d38045">More...</a><br /></td></tr>
<tr class="separator:gacb757b8af8c827b45e306cfbd2d38045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad60ee9a55f2be757f63b83ec7e45ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga1ad60ee9a55f2be757f63b83ec7e45ce">nrf_drv_usbd_stop</a> (void)</td></tr>
<tr class="memdesc:ga1ad60ee9a55f2be757f63b83ec7e45ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop USB functionality.  <a href="group__nrf__drv__usbd.html#ga1ad60ee9a55f2be757f63b83ec7e45ce">More...</a><br /></td></tr>
<tr class="separator:ga1ad60ee9a55f2be757f63b83ec7e45ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ecb8a9633445fd9e2eb79f956e69361"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga3ecb8a9633445fd9e2eb79f956e69361">nrf_drv_usbd_is_initialized</a> (void)</td></tr>
<tr class="memdesc:ga3ecb8a9633445fd9e2eb79f956e69361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if driver is initialized.  <a href="group__nrf__drv__usbd.html#ga3ecb8a9633445fd9e2eb79f956e69361">More...</a><br /></td></tr>
<tr class="separator:ga3ecb8a9633445fd9e2eb79f956e69361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb2723c73382ccd1db168d6e79d53e47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gafb2723c73382ccd1db168d6e79d53e47">nrf_drv_usbd_is_enabled</a> (void)</td></tr>
<tr class="memdesc:gafb2723c73382ccd1db168d6e79d53e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if driver is enabled.  <a href="group__nrf__drv__usbd.html#gafb2723c73382ccd1db168d6e79d53e47">More...</a><br /></td></tr>
<tr class="separator:gafb2723c73382ccd1db168d6e79d53e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77db8d2bb83b5d393bd7b179f065fac6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga77db8d2bb83b5d393bd7b179f065fac6">nrf_drv_usbd_is_started</a> (void)</td></tr>
<tr class="memdesc:ga77db8d2bb83b5d393bd7b179f065fac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if driver is started.  <a href="group__nrf__drv__usbd.html#ga77db8d2bb83b5d393bd7b179f065fac6">More...</a><br /></td></tr>
<tr class="separator:ga77db8d2bb83b5d393bd7b179f065fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae40c7a874e4591d3b3b9e52d4d5721e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gae40c7a874e4591d3b3b9e52d4d5721e8">nrf_drv_usbd_suspend</a> (void)</td></tr>
<tr class="memdesc:gae40c7a874e4591d3b3b9e52d4d5721e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend USBD operation.  <a href="group__nrf__drv__usbd.html#gae40c7a874e4591d3b3b9e52d4d5721e8">More...</a><br /></td></tr>
<tr class="separator:gae40c7a874e4591d3b3b9e52d4d5721e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae12a91b95970c3b95fa2427c92e12297"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gae12a91b95970c3b95fa2427c92e12297">nrf_drv_usbd_wakeup_req</a> (void)</td></tr>
<tr class="memdesc:gae12a91b95970c3b95fa2427c92e12297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start wake up procedure.  <a href="group__nrf__drv__usbd.html#gae12a91b95970c3b95fa2427c92e12297">More...</a><br /></td></tr>
<tr class="separator:gae12a91b95970c3b95fa2427c92e12297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ffc1368c7aa7251e9c609c15b935a0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga3ffc1368c7aa7251e9c609c15b935a0b">nrf_drv_usbd_suspend_check</a> (void)</td></tr>
<tr class="memdesc:ga3ffc1368c7aa7251e9c609c15b935a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if USBD is in SUSPEND mode.  <a href="group__nrf__drv__usbd.html#ga3ffc1368c7aa7251e9c609c15b935a0b">More...</a><br /></td></tr>
<tr class="separator:ga3ffc1368c7aa7251e9c609c15b935a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e3453e96cdb567f163877a7c605162d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga2e3453e96cdb567f163877a7c605162d">nrf_drv_usbd_suspend_irq_config</a> (void)</td></tr>
<tr class="memdesc:ga2e3453e96cdb567f163877a7c605162d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable only interrupts that should be processed in SUSPEND mode.  <a href="group__nrf__drv__usbd.html#ga2e3453e96cdb567f163877a7c605162d">More...</a><br /></td></tr>
<tr class="separator:ga2e3453e96cdb567f163877a7c605162d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00d06c84ee4b51980f4411ca86ff1b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga00d06c84ee4b51980f4411ca86ff1b31">nrf_drv_usbd_active_irq_config</a> (void)</td></tr>
<tr class="memdesc:ga00d06c84ee4b51980f4411ca86ff1b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default active interrupt configuration.  <a href="group__nrf__drv__usbd.html#ga00d06c84ee4b51980f4411ca86ff1b31">More...</a><br /></td></tr>
<tr class="separator:ga00d06c84ee4b51980f4411ca86ff1b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf73fc5a5adf8a97a664a248132d378e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gaf73fc5a5adf8a97a664a248132d378e2">nrf_drv_usbd_bus_suspend_check</a> (void)</td></tr>
<tr class="memdesc:gaf73fc5a5adf8a97a664a248132d378e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the bus state.  <a href="group__nrf__drv__usbd.html#gaf73fc5a5adf8a97a664a248132d378e2">More...</a><br /></td></tr>
<tr class="separator:gaf73fc5a5adf8a97a664a248132d378e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cea23d18bfb29af3b36aa53b32fca14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga2cea23d18bfb29af3b36aa53b32fca14">nrf_drv_usbd_ep_max_packet_size_set</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, uint16_t size)</td></tr>
<tr class="memdesc:ga2cea23d18bfb29af3b36aa53b32fca14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure packet size that should be supported by the endpoint.  <a href="group__nrf__drv__usbd.html#ga2cea23d18bfb29af3b36aa53b32fca14">More...</a><br /></td></tr>
<tr class="separator:ga2cea23d18bfb29af3b36aa53b32fca14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga693c13c49ab1fbe7ffa42386de8a15af"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga693c13c49ab1fbe7ffa42386de8a15af">nrf_drv_usbd_ep_max_packet_size_get</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga693c13c49ab1fbe7ffa42386de8a15af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get configured endpoint packet size.  <a href="group__nrf__drv__usbd.html#ga693c13c49ab1fbe7ffa42386de8a15af">More...</a><br /></td></tr>
<tr class="separator:ga693c13c49ab1fbe7ffa42386de8a15af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd74bb1091ba7fb9a710ef98caf04df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gacd74bb1091ba7fb9a710ef98caf04df3">nrf_drv_usbd_ep_enable_check</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gacd74bb1091ba7fb9a710ef98caf04df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the selected endpoint is enabled.  <a href="group__nrf__drv__usbd.html#gacd74bb1091ba7fb9a710ef98caf04df3">More...</a><br /></td></tr>
<tr class="separator:gacd74bb1091ba7fb9a710ef98caf04df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dd2c52f807f3663cc864f358fd53ac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga4dd2c52f807f3663cc864f358fd53ac6">nrf_drv_usbd_ep_enable</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga4dd2c52f807f3663cc864f358fd53ac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable selected endpoint.  <a href="group__nrf__drv__usbd.html#ga4dd2c52f807f3663cc864f358fd53ac6">More...</a><br /></td></tr>
<tr class="separator:ga4dd2c52f807f3663cc864f358fd53ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedb19d74504654d1628e0e3ca4976ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gacedb19d74504654d1628e0e3ca4976ba">nrf_drv_usbd_ep_disable</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gacedb19d74504654d1628e0e3ca4976ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable selected endpoint.  <a href="group__nrf__drv__usbd.html#gacedb19d74504654d1628e0e3ca4976ba">More...</a><br /></td></tr>
<tr class="separator:gacedb19d74504654d1628e0e3ca4976ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10bdc10e75a2e5c45251024e19120b2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga10bdc10e75a2e5c45251024e19120b2e">nrf_drv_usbd_ep_default_config</a> (void)</td></tr>
<tr class="memdesc:ga10bdc10e75a2e5c45251024e19120b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable all endpoints except for EP0.  <a href="group__nrf__drv__usbd.html#ga10bdc10e75a2e5c45251024e19120b2e">More...</a><br /></td></tr>
<tr class="separator:ga10bdc10e75a2e5c45251024e19120b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfed547bace8fe28d0142ad1af18a008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gabfed547bace8fe28d0142ad1af18a008">nrf_drv_usbd_ep_transfer</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a> const *const p_transfer)</td></tr>
<tr class="memdesc:gabfed547bace8fe28d0142ad1af18a008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start sending data over endpoint.  <a href="group__nrf__drv__usbd.html#gabfed547bace8fe28d0142ad1af18a008">More...</a><br /></td></tr>
<tr class="separator:gabfed547bace8fe28d0142ad1af18a008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1219e767791807d91d92871e95346f91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga1219e767791807d91d92871e95346f91">nrf_drv_usbd_ep_handled_transfer</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, <a class="el" href="structnrf__drv__usbd__handler__desc__t.html">nrf_drv_usbd_handler_desc_t</a> const *const p_handler)</td></tr>
<tr class="memdesc:ga1219e767791807d91d92871e95346f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start sending data over the endpoint using the transfer handler function.  <a href="group__nrf__drv__usbd.html#ga1219e767791807d91d92871e95346f91">More...</a><br /></td></tr>
<tr class="separator:ga1219e767791807d91d92871e95346f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad844c7b3654777b8e3a2c8d0b5657d26"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gad844c7b3654777b8e3a2c8d0b5657d26">nrf_drv_usbd_feeder_buffer_get</a> (void)</td></tr>
<tr class="memdesc:gad844c7b3654777b8e3a2c8d0b5657d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the temporary buffer to be used by the feeder.  <a href="group__nrf__drv__usbd.html#gad844c7b3654777b8e3a2c8d0b5657d26">More...</a><br /></td></tr>
<tr class="separator:gad844c7b3654777b8e3a2c8d0b5657d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3467a64cb0eba21868aa9a1e96f0d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga5d3467a64cb0eba21868aa9a1e96f0d4">nrf_drv_usbd_ep_status_get</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep, size_t *p_size)</td></tr>
<tr class="memdesc:ga5d3467a64cb0eba21868aa9a1e96f0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about last finished or current transfer.  <a href="group__nrf__drv__usbd.html#ga5d3467a64cb0eba21868aa9a1e96f0d4">More...</a><br /></td></tr>
<tr class="separator:ga5d3467a64cb0eba21868aa9a1e96f0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada3a71a437745665c288110fdb0356b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gada3a71a437745665c288110fdb0356b8">nrf_drv_usbd_epout_size_get</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gada3a71a437745665c288110fdb0356b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of received bytes.  <a href="group__nrf__drv__usbd.html#gada3a71a437745665c288110fdb0356b8">More...</a><br /></td></tr>
<tr class="separator:gada3a71a437745665c288110fdb0356b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73852623b474a7626496366089cb1d85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga73852623b474a7626496366089cb1d85">nrf_drv_usbd_ep_is_busy</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga73852623b474a7626496366089cb1d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if endpoint buffer is ready or is under USB IP control.  <a href="group__nrf__drv__usbd.html#ga73852623b474a7626496366089cb1d85">More...</a><br /></td></tr>
<tr class="separator:ga73852623b474a7626496366089cb1d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51ca226d86703aad748af44ca24dd819"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga51ca226d86703aad748af44ca24dd819">nrf_drv_usbd_ep_stall</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga51ca226d86703aad748af44ca24dd819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stall endpoint.  <a href="group__nrf__drv__usbd.html#ga51ca226d86703aad748af44ca24dd819">More...</a><br /></td></tr>
<tr class="separator:ga51ca226d86703aad748af44ca24dd819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58141094e1a11a5b0e91e4a3b0f02784"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga58141094e1a11a5b0e91e4a3b0f02784">nrf_drv_usbd_ep_stall_clear</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga58141094e1a11a5b0e91e4a3b0f02784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear stall flag on endpoint.  <a href="group__nrf__drv__usbd.html#ga58141094e1a11a5b0e91e4a3b0f02784">More...</a><br /></td></tr>
<tr class="separator:ga58141094e1a11a5b0e91e4a3b0f02784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca00e5defeb5986340ecd0e7e9c364b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gaca00e5defeb5986340ecd0e7e9c364b9">nrf_drv_usbd_ep_stall_check</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gaca00e5defeb5986340ecd0e7e9c364b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if endpoint is stalled.  <a href="group__nrf__drv__usbd.html#gaca00e5defeb5986340ecd0e7e9c364b9">More...</a><br /></td></tr>
<tr class="separator:gaca00e5defeb5986340ecd0e7e9c364b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1df2a11e0d7dcf23c3aade30779a1dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gab1df2a11e0d7dcf23c3aade30779a1dc">nrf_drv_usbd_ep_dtoggle_clear</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:gab1df2a11e0d7dcf23c3aade30779a1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear current endpoint data toggle.  <a href="group__nrf__drv__usbd.html#gab1df2a11e0d7dcf23c3aade30779a1dc">More...</a><br /></td></tr>
<tr class="separator:gab1df2a11e0d7dcf23c3aade30779a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae47e5d114e751ae88feee568a7dda845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gae47e5d114e751ae88feee568a7dda845">nrf_drv_usbd_setup_get</a> (<a class="el" href="structnrf__drv__usbd__setup__t.html">nrf_drv_usbd_setup_t</a> *const p_setup)</td></tr>
<tr class="memdesc:gae47e5d114e751ae88feee568a7dda845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get parsed setup data.  <a href="group__nrf__drv__usbd.html#gae47e5d114e751ae88feee568a7dda845">More...</a><br /></td></tr>
<tr class="separator:gae47e5d114e751ae88feee568a7dda845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6a84106ecef4effd20d615fb985ecb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gac6a84106ecef4effd20d615fb985ecb8">nrf_drv_usbd_setup_data_clear</a> (void)</td></tr>
<tr class="memdesc:gac6a84106ecef4effd20d615fb985ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear only for data transmission on setup endpoint.  <a href="group__nrf__drv__usbd.html#gac6a84106ecef4effd20d615fb985ecb8">More...</a><br /></td></tr>
<tr class="separator:gac6a84106ecef4effd20d615fb985ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aa78cfbacee0edfc5f43d184aaaddc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#gaa8aa78cfbacee0edfc5f43d184aaaddc">nrf_drv_usbd_setup_clear</a> (void)</td></tr>
<tr class="memdesc:gaa8aa78cfbacee0edfc5f43d184aaaddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear setup endpoint.  <a href="group__nrf__drv__usbd.html#gaa8aa78cfbacee0edfc5f43d184aaaddc">More...</a><br /></td></tr>
<tr class="separator:gaa8aa78cfbacee0edfc5f43d184aaaddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680eae1b344512f9e7c166a740bfa5ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga680eae1b344512f9e7c166a740bfa5ba">nrf_drv_usbd_setup_stall</a> (void)</td></tr>
<tr class="memdesc:ga680eae1b344512f9e7c166a740bfa5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stall setup endpoint.  <a href="group__nrf__drv__usbd.html#ga680eae1b344512f9e7c166a740bfa5ba">More...</a><br /></td></tr>
<tr class="separator:ga680eae1b344512f9e7c166a740bfa5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c2099f06bc27e498d058226019d8e8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga5c2099f06bc27e498d058226019d8e8a">nrf_drv_usbd_ep_abort</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="separator:ga5c2099f06bc27e498d058226019d8e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga569381189170f7bbce7995894bcfaa87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga569381189170f7bbce7995894bcfaa87">nrf_drv_usbd_last_setup_dir_get</a> (void)</td></tr>
<tr class="memdesc:ga569381189170f7bbce7995894bcfaa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the information about expected transfer SETUP data direction.  <a href="group__nrf__drv__usbd.html#ga569381189170f7bbce7995894bcfaa87">More...</a><br /></td></tr>
<tr class="separator:ga569381189170f7bbce7995894bcfaa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52acb0c56ab24137f5e6d45f47e46a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga52acb0c56ab24137f5e6d45f47e46a46">nrf_drv_usbd_transfer_out_drop</a> (<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> ep)</td></tr>
<tr class="memdesc:ga52acb0c56ab24137f5e6d45f47e46a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop transfer on OUT endpoint.  <a href="group__nrf__drv__usbd.html#ga52acb0c56ab24137f5e6d45f47e46a46">More...</a><br /></td></tr>
<tr class="separator:ga52acb0c56ab24137f5e6d45f47e46a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Possible schemes of DMA scheduling</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp4e633a446652c354dfa1e304ff6a6376"></a>Definition of available configuration constants used by DMA scheduler </p>
</td></tr>
<tr class="memitem:ga7a7a7bbf6ff89a856f8d6b33633d8158"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga7a7a7bbf6ff89a856f8d6b33633d8158">NRF_DRV_USBD_DMASCHEDULER_PRIORITIZED</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ga7a7a7bbf6ff89a856f8d6b33633d8158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highly prioritized access.  <a href="group__nrf__drv__usbd.html#ga7a7a7bbf6ff89a856f8d6b33633d8158">More...</a><br /></td></tr>
<tr class="separator:ga7a7a7bbf6ff89a856f8d6b33633d8158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6a3d41b494e34b66fb320ae3a0634d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga8e6a3d41b494e34b66fb320ae3a0634d">NRF_DRV_USBD_DMASCHEDULER_ROUNDROBIN</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ga8e6a3d41b494e34b66fb320ae3a0634d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Round robin scheme.  <a href="group__nrf__drv__usbd.html#ga8e6a3d41b494e34b66fb320ae3a0634d">More...</a><br /></td></tr>
<tr class="separator:ga8e6a3d41b494e34b66fb320ae3a0634d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Macros for creating endpoint identifiers</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp1b3261fef70bc87900134bbc77e61aae"></a>Auxiliary macros to be used to create Endpoint identifier that is compatible with USB specification. </p>
</td></tr>
<tr class="memitem:ga22655b77192f6b0b4acd570a15d1e13e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga22655b77192f6b0b4acd570a15d1e13e">NRF_DRV_USBD_EPIN</a>(n)&#160;&#160;&#160;((<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga9be1e5cf3c38d21e1116c2771ab86bcf">NRF_USBD_EPIN</a>(n))</td></tr>
<tr class="memdesc:ga22655b77192f6b0b4acd570a15d1e13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create identifier for IN endpoint.  <a href="group__nrf__drv__usbd.html#ga22655b77192f6b0b4acd570a15d1e13e">More...</a><br /></td></tr>
<tr class="separator:ga22655b77192f6b0b4acd570a15d1e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74bb0cb3e39e40aed5797256fcd62e3d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__usbd.html#ga74bb0cb3e39e40aed5797256fcd62e3d">NRF_DRV_USBD_EPOUT</a>(n)&#160;&#160;&#160;((<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga8b6d96a8d69d5283919896d6f5b54b01">NRF_USBD_EPOUT</a>(n))</td></tr>
<tr class="memdesc:ga74bb0cb3e39e40aed5797256fcd62e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create identifier for OUT endpoint.  <a href="group__nrf__drv__usbd.html#ga74bb0cb3e39e40aed5797256fcd62e3d">More...</a><br /></td></tr>
<tr class="separator:ga74bb0cb3e39e40aed5797256fcd62e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>@tagAPI52840 USB Device APIs. </p>
<p>Copyright (c) 2016 - 2018, Nordic Semiconductor ASA</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form, except as embedded into a Nordic Semiconductor ASA integrated circuit in a product or a software update for such product, must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of Nordic Semiconductor ASA nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
<li>This software, with or without modification, must only be used with a Nordic Semiconductor ASA integrated circuit.</li>
<li>Any software provided in binary form under this license must not be reverse engineered, decompiled, modified and/or disassembled.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>The USB Device HAL provides basic APIs for accessing the registers of the USBD. The USB Device driver provides APIs on a higher level. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7a7a7bbf6ff89a856f8d6b33633d8158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7a7bbf6ff89a856f8d6b33633d8158">&#9670;&nbsp;</a></span>NRF_DRV_USBD_DMASCHEDULER_PRIORITIZED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_DMASCHEDULER_PRIORITIZED&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highly prioritized access. </p>
<p>Endpoint with lower number has always higher priority and its data would be transfered first. OUT endpoints ale processed before IN endpoints </p>

</div>
</div>
<a id="ga8e6a3d41b494e34b66fb320ae3a0634d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e6a3d41b494e34b66fb320ae3a0634d">&#9670;&nbsp;</a></span>NRF_DRV_USBD_DMASCHEDULER_ROUNDROBIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_DMASCHEDULER_ROUNDROBIN&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Round robin scheme. </p>
<p>All endpoints are processed in round-robin scheme. It means that when one endpoint is processed next in order would be the nearest with lower number. When no endpoints with lower number requires processing - then all endpoints from 0 are tested. </p>

</div>
</div>
<a id="ga22655b77192f6b0b4acd570a15d1e13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22655b77192f6b0b4acd570a15d1e13e">&#9670;&nbsp;</a></span>NRF_DRV_USBD_EPIN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_EPIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga9be1e5cf3c38d21e1116c2771ab86bcf">NRF_USBD_EPIN</a>(n))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create identifier for IN endpoint. </p>
<p>Simple macro to create IN endpoint identifier for given endpoint number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endpoint identifier that connects endpoint number and endpoint direction. </dd></dl>

</div>
</div>
<a id="ga74bb0cb3e39e40aed5797256fcd62e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74bb0cb3e39e40aed5797256fcd62e3d">&#9670;&nbsp;</a></span>NRF_DRV_USBD_EPOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_EPOUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td>&#160;&#160;&#160;((<a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>)<a class="el" href="group__nrf__usbd__hal.html#ga8b6d96a8d69d5283919896d6f5b54b01">NRF_USBD_EPOUT</a>(n))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create identifier for OUT endpoint. </p>
<p>Simple macro to create OUT endpoint identifier for given endpoint number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Endpoint identifier that connects endpoint number and endpoint direction. </dd></dl>

</div>
</div>
<a id="ga3ecfa2bc5ba0c2b9c7cd384290f27739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ecfa2bc5ba0c2b9c7cd384290f27739">&#9670;&nbsp;</a></span>NRF_DRV_USBD_EPSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_EPSIZE&#160;&#160;&#160;64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes in the endpoint. </p>
<p>Constant that informs about endpoint size </p>

</div>
</div>
<a id="gab4bbed2bd99a3c54cc5956f16b72061c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4bbed2bd99a3c54cc5956f16b72061c">&#9670;&nbsp;</a></span>NRF_DRV_USBD_FEEDER_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_FEEDER_BUFFER_SIZE&#160;&#160;&#160;<a class="el" href="group__nrf__drv__usbd.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The size of internal feeder buffer. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__usbd.html#gad844c7b3654777b8e3a2c8d0b5657d26" title="Get the temporary buffer to be used by the feeder.">nrf_drv_usbd_feeder_buffer_get</a> </dd></dl>

</div>
</div>
<a id="ga2482239c2133ddfe1fd269f8d2c44f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2482239c2133ddfe1fd269f8d2c44f6c">&#9670;&nbsp;</a></span>NRF_DRV_USBD_ISOSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_ISOSIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes for isochronous endpoints. </p>
<p>Number of bytes for isochronous endpoints in total. This number would be shared between IN and OUT endpoint. It may be also assigned totaly to one endpoint. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__usbd__hal.html#ga3cc80e71ef242cd1bd3811ef58f92501" title="Function for configuration of isochronous buffer splitting.">nrf_usbd_isosplit_set</a> </dd>
<dd>
<a class="el" href="group__nrf__usbd__hal.html#ga09a75378581cf4c5f301fc0c46808518" title="Function for getting the isochronous buffer splitting configuration.">nrf_usbd_isosplit_get</a> </dd></dl>

</div>
</div>
<a id="gad153e248ce252afaa4a3a3912e41d547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad153e248ce252afaa4a3a3912e41d547">&#9670;&nbsp;</a></span>NRF_DRV_USBD_TRANSFER_IN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_IN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="group__nrf__drv__usbd.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(name, tx_buff, tx_size, 0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper macro for declaring IN transfer description. </p>
<p>Normal transfer mode, no ZLP would be automatically generated.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnrf__drv__usbd__transfer__t.html" title="Total transfer configuration.">nrf_drv_usbd_transfer_t</a> </dd>
<dd>
<a class="el" href="group__nrf__drv__usbd.html#ga9ec2fac985fd7d5b96629028d558796e" title="Helper macro for declaring IN transfer description.">NRF_DRV_USBD_TRANSFER_IN_ZLP</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name </td></tr>
    <tr><td class="paramname">tx_buff</td><td>Buffer to transfer </td></tr>
    <tr><td class="paramname">tx_size</td><td>Transfer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configured variable with total transfer description </dd></dl>

</div>
</div>
<a id="ga1ee0dbca6acc4af77ccbb555b2f109d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee0dbca6acc4af77ccbb555b2f109d3">&#9670;&nbsp;</a></span>NRF_DRV_USBD_TRANSFER_IN_FLAGS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_IN_FLAGS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_flags&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a> name = {                               \</div>
<div class="line">       .<a class="code" href="structnrf__drv__usbd__transfer__t.html#a92f55a088638ea71a83953052473a99d">p_data</a> = { .<a class="code" href="unionnrf__drv__usbd__data__ptr__t.html#a95cfddb4da8b0f488001d0297251f9cb">tx</a> = (tx_buff)  },                                   \</div>
<div class="line">       .size = (tx_size),                                                \</div>
<div class="line">       .flags = (tx_flags)                                               \</div>
<div class="line">    }</div>
<div class="ttc" id="astructnrf__drv__usbd__transfer__t_html"><div class="ttname"><a href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a></div><div class="ttdoc">Total transfer configuration.</div><div class="ttdef"><b>Definition:</b> nrf_drv_usbd.h:298</div></div>
<div class="ttc" id="astructnrf__drv__usbd__transfer__t_html_a92f55a088638ea71a83953052473a99d"><div class="ttname"><a href="structnrf__drv__usbd__transfer__t.html#a92f55a088638ea71a83953052473a99d">nrf_drv_usbd_transfer_t::p_data</a></div><div class="ttdeci">nrf_drv_usbd_data_ptr_t p_data</div><div class="ttdoc">Union with available data pointers used by the library.</div><div class="ttdef"><b>Definition:</b> nrf_drv_usbd.h:299</div></div>
<div class="ttc" id="aunionnrf__drv__usbd__data__ptr__t_html_a95cfddb4da8b0f488001d0297251f9cb"><div class="ttname"><a href="unionnrf__drv__usbd__data__ptr__t.html#a95cfddb4da8b0f488001d0297251f9cb">nrf_drv_usbd_data_ptr_t::tx</a></div><div class="ttdeci">void const  * tx</div><div class="ttdoc">Constant TX buffer pointer.</div><div class="ttdef"><b>Definition:</b> nrf_drv_usbd.h:263</div></div>
</div><!-- fragment -->
<p>Auxiliary macro for declaring IN transfer description with flags. </p>
<p>The base macro for creating transfers with any configuration option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name. </td></tr>
    <tr><td class="paramname">tx_buff</td><td>Buffer to transfer. </td></tr>
    <tr><td class="paramname">tx_size</td><td>Transfer size. </td></tr>
    <tr><td class="paramname">tx_flags</td><td>Flags for the transfer (see <a class="el" href="group__nrf__drv__usbd.html#gacfe244baf5655539aa3e356620f2acfc">nrf_drv_usbd_transfer_flags_t</a>).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configured variable with total transfer description. </dd></dl>

</div>
</div>
<a id="ga9ec2fac985fd7d5b96629028d558796e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec2fac985fd7d5b96629028d558796e">&#9670;&nbsp;</a></span>NRF_DRV_USBD_TRANSFER_IN_ZLP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_IN_ZLP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tx_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="group__nrf__drv__usbd.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a>(                          \</div>
<div class="line">        name,                                                \</div>
<div class="line">        tx_buff,                                             \</div>
<div class="line">        tx_size,                                             \</div>
<div class="line">        <a class="code" href="group__nrf__drv__usbd.html#ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3">NRF_DRV_USBD_TRANSFER_ZLP_FLAG</a>)</div>
<div class="ttc" id="agroup__nrf__drv__usbd_html_ga1ee0dbca6acc4af77ccbb555b2f109d3"><div class="ttname"><a href="group__nrf__drv__usbd.html#ga1ee0dbca6acc4af77ccbb555b2f109d3">NRF_DRV_USBD_TRANSFER_IN_FLAGS</a></div><div class="ttdeci">#define NRF_DRV_USBD_TRANSFER_IN_FLAGS(name, tx_buff, tx_size, tx_flags)</div><div class="ttdoc">Auxiliary macro for declaring IN transfer description with flags.</div><div class="ttdef"><b>Definition:</b> nrf_drv_usbd.h:318</div></div>
<div class="ttc" id="agroup__nrf__drv__usbd_html_ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3"><div class="ttname"><a href="group__nrf__drv__usbd.html#ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3">NRF_DRV_USBD_TRANSFER_ZLP_FLAG</a></div><div class="ttdeci">@ NRF_DRV_USBD_TRANSFER_ZLP_FLAG</div><div class="ttdoc">Add a zero-length packet.</div><div class="ttdef"><b>Definition:</b> nrf_drv_usbd.h:288</div></div>
</div><!-- fragment -->
<p>Helper macro for declaring IN transfer description. </p>
<p>ZLP mode - Zero Length Packet would be generated on the end of the transfer (always!).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structnrf__drv__usbd__transfer__t.html" title="Total transfer configuration.">nrf_drv_usbd_transfer_t</a> </dd>
<dd>
<a class="el" href="group__nrf__drv__usbd.html#gad153e248ce252afaa4a3a3912e41d547" title="Helper macro for declaring IN transfer description.">NRF_DRV_USBD_TRANSFER_IN</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name </td></tr>
    <tr><td class="paramname">tx_buff</td><td>Buffer to transfer </td></tr>
    <tr><td class="paramname">tx_size</td><td>Transfer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Configured variable with total transfer description </dd></dl>

</div>
</div>
<a id="ga6c757e4582e52975bb6dabd8f0dc1e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c757e4582e52975bb6dabd8f0dc1e0f">&#9670;&nbsp;</a></span>NRF_DRV_USBD_TRANSFER_OUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_USBD_TRANSFER_OUT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_buff, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">rx_size&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <span class="keyword">const</span> <a class="code" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a> name = {                      \</div>
<div class="line">       .<a class="code" href="structnrf__drv__usbd__transfer__t.html#a92f55a088638ea71a83953052473a99d">p_data</a> = { .<a class="code" href="unionnrf__drv__usbd__data__ptr__t.html#a775158207650c02089f34179c8ccd9ab">rx</a> = (rx_buff)  },                          \</div>
<div class="line">       .size = (rx_size),                                       \</div>
<div class="line">       .flags = 0                                               \</div>
<div class="line">    }</div>
<div class="ttc" id="aunionnrf__drv__usbd__data__ptr__t_html_a775158207650c02089f34179c8ccd9ab"><div class="ttname"><a href="unionnrf__drv__usbd__data__ptr__t.html#a775158207650c02089f34179c8ccd9ab">nrf_drv_usbd_data_ptr_t::rx</a></div><div class="ttdeci">void * rx</div><div class="ttdoc">Writable RX buffer pointer.</div><div class="ttdef"><b>Definition:</b> nrf_drv_usbd.h:264</div></div>
</div><!-- fragment -->
<p>Helper macro for declaring OUT transfer item (<a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a>) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Instance name </td></tr>
    <tr><td class="paramname">rx_buff</td><td>Buffer to transfer </td></tr>
    <tr><td class="paramname">rx_size</td><td>Transfer size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga24496ca286682e570b1017cb8a5b8265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga24496ca286682e570b1017cb8a5b8265">&#9670;&nbsp;</a></span>nrf_drv_usbd_consumer_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* nrf_drv_usbd_consumer_t) (<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size, size_t data_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD transfer consumer. </p>
<p>Pointer for a transfer consumer. Transfer consumer is a feedback function used to prepare a single RX (Host-&gt;Device) endpoint transfer.</p>
<p>The transfer must provide a buffer big enough to fit the whole data from the endpoint. Otherwise, the NRF_USBD_EP_OVERLOAD event is generated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_next</td><td>Structure with the data for the next transfer to be filled. Required only if the function returns true. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_context</td><td>Context variable configured with the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_size</td><td>The endpoint size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_size</td><td>Number of received bytes in the endpoint buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Current transfer is the last one - you do not need to call the function again. </td></tr>
    <tr><td class="paramname">true</td><td>There is more data to be prepared and when current transfer finishes, the feeder function is expected to be called again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaedc9aa1b393e8a00fe0aec2e756d3397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaedc9aa1b393e8a00fe0aec2e756d3397">&#9670;&nbsp;</a></span>nrf_drv_usbd_event_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nrf_drv_usbd_event_handler_t) (<a class="el" href="structnrf__drv__usbd__evt__t.html">nrf_drv_usbd_evt_t</a> const *const p_event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD event callback function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Event information structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabb89e843d21a8d3fa695fa68ab772738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb89e843d21a8d3fa695fa68ab772738">&#9670;&nbsp;</a></span>nrf_drv_usbd_feeder_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* nrf_drv_usbd_feeder_t) (<a class="el" href="structnrf__drv__usbd__ep__transfer__t.html">nrf_drv_usbd_ep_transfer_t</a> *p_next, void *p_context, size_t ep_size)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>USBD transfer feeder. </p>
<p>Pointer for a transfer feeder. Transfer feeder is a feedback function used to prepare a single TX (Device-&gt;Host) endpoint transfer.</p>
<p>The transfers provided by the feeder must be simple:</p><ul>
<li>The size of the transfer provided by this function is limited to a single endpoint buffer. Bigger transfers are not handled automatically in this case.</li>
<li>Flash transfers are not automatically supported- you must copy them to the RAM buffer before.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function may use <a class="el" href="group__nrf__drv__usbd.html#gad844c7b3654777b8e3a2c8d0b5657d26">nrf_drv_usbd_feeder_buffer_get</a> to gain a temporary buffer that can be used to prepare transfer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_next</td><td>Structure with the data for the next transfer to be filled. Required only if the function returns true. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_context</td><td>Context variable configured with the transfer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ep_size</td><td>The endpoint size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>The current transfer is the last one - you do not need to call the function again. </td></tr>
    <tr><td class="paramname">true</td><td>There is more data to be prepared and when the current transfer finishes, the feeder function is expected to be called again. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gae51235955b1bec1393a393946544fc6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae51235955b1bec1393a393946544fc6e">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_status_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__drv__usbd.html#gae51235955b1bec1393a393946544fc6e">nrf_drv_usbd_ep_status_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Possible endpoint error codes. </p>
<p>Error codes that may be returned with <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df">NRF_DRV_USBD_EVT_EPTRANSFER</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae51235955b1bec1393a393946544fc6ea6c64dda31a6dd80d690a078bbb713f05"></a>NRF_USBD_EP_OK&#160;</td><td class="fielddoc"><p>No error </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae51235955b1bec1393a393946544fc6ea82b67485a8aed419a744bbac8c5de806"></a>NRF_USBD_EP_WAITING&#160;</td><td class="fielddoc"><p>Data received, no buffer prepared already - waiting for configured transfer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae51235955b1bec1393a393946544fc6ea32ddfa8d69d4f14816f5fe83fb2713fc"></a>NRF_USBD_EP_OVERLOAD&#160;</td><td class="fielddoc"><p>Received number of bytes cannot fit given buffer This error would also be returned when next_transfer function has been defined but currently received data cannot fit completely in current buffer. No data split from single endpoint transmission is supported.</p>
<p>When this error is reported - data is left inside endpoint buffer. Clear endpoint or prepare new buffer and read it. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae51235955b1bec1393a393946544fc6ea184bf8a573eaa257384917103ae0fd9b"></a>NRF_USBD_EP_ABORTED&#160;</td><td class="fielddoc"><p>EP0 transfer can be aborted when new setup comes. Any other transfer can be aborted by USB reset or library stopping. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaaa65ebeb12443fd8325e7447a2187f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa65ebeb12443fd8325e7447a2187f70">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Endpoint identifier. </p>
<p>Endpoint identifier used in the driver. This endpoint number is consistent with USB 2.0 specification. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70afb5b50c3d9680fbda0b08830f42e382f"></a>NRF_DRV_USBD_EPOUT0&#160;</td><td class="fielddoc"><p>Endpoint OUT 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a0806d24dac06f5c0d3898cd67e405617"></a>NRF_DRV_USBD_EPOUT1&#160;</td><td class="fielddoc"><p>Endpoint OUT 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70aaf42aef784c75192853fddefe57a2fb9"></a>NRF_DRV_USBD_EPOUT2&#160;</td><td class="fielddoc"><p>Endpoint OUT 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a7ebbfa51beb7a0dd6ee5f071b8d35950"></a>NRF_DRV_USBD_EPOUT3&#160;</td><td class="fielddoc"><p>Endpoint OUT 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70ad4a07134f5ea54e003d4a17ee1ba4c7f"></a>NRF_DRV_USBD_EPOUT4&#160;</td><td class="fielddoc"><p>Endpoint OUT 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a5ab577a8042f3f0f73ad3de23b0d4ba3"></a>NRF_DRV_USBD_EPOUT5&#160;</td><td class="fielddoc"><p>Endpoint OUT 5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a6da7bf30befbefaaf7f8ad79c9f1666a"></a>NRF_DRV_USBD_EPOUT6&#160;</td><td class="fielddoc"><p>Endpoint OUT 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70af087b27308b6f18bf4bf8fff43d827f5"></a>NRF_DRV_USBD_EPOUT7&#160;</td><td class="fielddoc"><p>Endpoint OUT 7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70ae53cb7398e739532f7069f4859a2d2c5"></a>NRF_DRV_USBD_EPOUT8&#160;</td><td class="fielddoc"><p>Endpoint OUT 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70ac8e5ae481bf8a23aa2e5f9e4d9bfec24"></a>NRF_DRV_USBD_EPIN0&#160;</td><td class="fielddoc"><p>Endpoint IN 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a78c594d15eee745ac6eb11e83c294b1b"></a>NRF_DRV_USBD_EPIN1&#160;</td><td class="fielddoc"><p>Endpoint IN 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70acb4347afc5cebf8dc2cf6efe6825eed0"></a>NRF_DRV_USBD_EPIN2&#160;</td><td class="fielddoc"><p>Endpoint IN 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70acd14758cfae4cca0095c7ced300fc678"></a>NRF_DRV_USBD_EPIN3&#160;</td><td class="fielddoc"><p>Endpoint IN 3 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a8609bbebe798a8ae69309b586c83c922"></a>NRF_DRV_USBD_EPIN4&#160;</td><td class="fielddoc"><p>Endpoint IN 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a69321276f3de8b259f82bf3720274662"></a>NRF_DRV_USBD_EPIN5&#160;</td><td class="fielddoc"><p>Endpoint IN 5 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70aaf4e021d052ef571afbf3d2f140ba3c1"></a>NRF_DRV_USBD_EPIN6&#160;</td><td class="fielddoc"><p>Endpoint IN 6 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a4d9d5809cd17a2bb686b6b896ea3a446"></a>NRF_DRV_USBD_EPIN7&#160;</td><td class="fielddoc"><p>Endpoint IN 7 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaa65ebeb12443fd8325e7447a2187f70a51de27329e5d1c525409b0d073d661c4"></a>NRF_DRV_USBD_EPIN8&#160;</td><td class="fielddoc"><p>Endpoint IN 8 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9f0b03e5a41539896e07ccba22b67b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f0b03e5a41539896e07ccba22b67b3d">&#9670;&nbsp;</a></span>nrf_drv_usbd_event_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__drv__usbd.html#ga9f0b03e5a41539896e07ccba22b67b3d">nrf_drv_usbd_event_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Events generated by the library. </p>
<p>Enumeration of possible events that may be generated by the library. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3da5e5aa0126cace9c3e1ca9bf202fcfb76"></a>NRF_DRV_USBD_EVT_SOF&#160;</td><td class="fielddoc"><p>Start Of Frame event on USB bus detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3dafb97ef9016ced03034a496683b9d59ef"></a>NRF_DRV_USBD_EVT_RESET&#160;</td><td class="fielddoc"><p>Reset condition on USB bus detected </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3da610d9052eed8b8fa98d6d66a9b4cfd78"></a>NRF_DRV_USBD_EVT_SUSPEND&#160;</td><td class="fielddoc"><p>This device should go to suspend mode now </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3da773b2df8b85d14aae8e75b85dc75be32"></a>NRF_DRV_USBD_EVT_RESUME&#160;</td><td class="fielddoc"><p>This device should resume from suspend now </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3dad801b6ddca9ca53d8d3493675600a1bd"></a>NRF_DRV_USBD_EVT_WUREQ&#160;</td><td class="fielddoc"><p>Wakeup request - the USBD peripheral is ready to generate WAKEUP signal after exiting low power mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3dad5eb9fc5f0621fa680cab1ccb8a6911d"></a>NRF_DRV_USBD_EVT_SETUP&#160;</td><td class="fielddoc"><p>Setup frame received and decoded </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df"></a>NRF_DRV_USBD_EVT_EPTRANSFER&#160;</td><td class="fielddoc"><p>For Rx (OUT: Host-&gt;Device):</p><ol type="1">
<li>The packet has been received but there is no buffer prepared for transfer already.</li>
<li>Whole transfer has been finished</li>
</ol>
<p>For Tx (IN: Device-&gt;Host): The last packet from requested transfer has been transfered over USB bus and acknowledged </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f0b03e5a41539896e07ccba22b67b3da76a716e60a05c83622c79910a404fd92"></a>NRF_DRV_USBD_EVT_CNT&#160;</td><td class="fielddoc"><p>Number of defined events </p>
</td></tr>
</table>

</div>
</div>
<a id="gacfe244baf5655539aa3e356620f2acfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfe244baf5655539aa3e356620f2acfc">&#9670;&nbsp;</a></span>nrf_drv_usbd_transfer_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__drv__usbd.html#gacfe244baf5655539aa3e356620f2acfc">nrf_drv_usbd_transfer_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flags for the current transfer. </p>
<p>Flags configured for the transfer that can be merged using the bitwise 'or' operator (|). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacfe244baf5655539aa3e356620f2acfca434f1af79242c2e2cd5d1a0998ddcaa3"></a>NRF_DRV_USBD_TRANSFER_ZLP_FLAG&#160;</td><td class="fielddoc"><p>Add a zero-length packet. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga00d06c84ee4b51980f4411ca86ff1b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00d06c84ee4b51980f4411ca86ff1b31">&#9670;&nbsp;</a></span>nrf_drv_usbd_active_irq_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_active_irq_config </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default active interrupt configuration. </p>
<p>Default interrupt configuration. Use in a pair with <a class="el" href="group__nrf__drv__usbd.html#ga00d06c84ee4b51980f4411ca86ff1b31">nrf_drv_usbd_active_irq_config</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__usbd.html#ga2e3453e96cdb567f163877a7c605162d" title="Enable only interrupts that should be processed in SUSPEND mode.">nrf_drv_usbd_suspend_irq_config</a> </dd></dl>

</div>
</div>
<a id="gaf73fc5a5adf8a97a664a248132d378e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf73fc5a5adf8a97a664a248132d378e2">&#9670;&nbsp;</a></span>nrf_drv_usbd_bus_suspend_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_bus_suspend_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check the bus state. </p>
<p>This function checks if the bus state is suspended</p>
<dl class="section note"><dt>Note</dt><dd>The value returned by this function changes on SUSPEND and RESUME event processing.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>USBD bus is suspended </td></tr>
    <tr><td class="paramname">false</td><td>USBD bus is active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaad4f73e18396c94c6c6a90114ad3de6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad4f73e18396c94c6c6a90114ad3de6a">&#9670;&nbsp;</a></span>nrf_drv_usbd_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the USBD port. </p>
<p>After calling this function USBD peripheral would be disabled. No events would be detected or processed by the library. Clock for the peripheral would be disconnected. </p>

</div>
</div>
<a id="gafee8557590430bd5d50d64b9363ecc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafee8557590430bd5d50d64b9363ecc7d">&#9670;&nbsp;</a></span>nrf_drv_usbd_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the USBD port. </p>
<p>After calling this function USBD peripheral would be enabled. The USB LDO would be enabled. Enabled USBD peripheral would request HFCLK. This function does not enable external oscillator, so if it is not enabled by other part of the program after enabling USBD driver HFINT would be used for the USBD peripheral. It is perfectly fine until USBD is started. See <a class="el" href="group__nrf__drv__usbd.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a>.</p>
<p>In normal situation this function should be called in reaction to USBDETECTED event from POWER peripheral.</p>
<p>Interrupts and USB pins pull-up would stay disabled until <a class="el" href="group__nrf__drv__usbd.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a> function is called. </p>

</div>
</div>
<a id="ga5c2099f06bc27e498d058226019d8e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c2099f06bc27e498d058226019d8e8a">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>This function locks interrupts that may be costly. It is good idea to test if the endpoint is still busy before calling this function: <div class="fragment"><div class="line">(m_ep_dma_waiting &amp; (1U &lt;&lt; ep2bit(ep)))</div>
</div><!-- fragment --> This function would check it again, but it makes it inside critical section. </dd></dl>

</div>
</div>
<a id="ga10bdc10e75a2e5c45251024e19120b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10bdc10e75a2e5c45251024e19120b2e">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_default_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_default_config </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable all endpoints except for EP0. </p>
<p>Disable all endpoints that can be disabled in USB device while it is still active. </p>

</div>
</div>
<a id="gacedb19d74504654d1628e0e3ca4976ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacedb19d74504654d1628e0e3ca4976ba">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable selected endpoint. </p>
<p>This function disables endpoint itself and its interrupts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab1df2a11e0d7dcf23c3aade30779a1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1df2a11e0d7dcf23c3aade30779a1dc">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_dtoggle_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_dtoggle_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear current endpoint data toggle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4dd2c52f807f3663cc864f358fd53ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd2c52f807f3663cc864f358fd53ac6">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable selected endpoint. </p>
<p>This function enables endpoint itself and its interrupts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to enable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Max packet size is set to endpoint default maximum value.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__usbd.html#ga2cea23d18bfb29af3b36aa53b32fca14" title="Configure packet size that should be supported by the endpoint.">nrf_drv_usbd_ep_max_packet_size_set</a> </dd></dl>

</div>
</div>
<a id="gacd74bb1091ba7fb9a710ef98caf04df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd74bb1091ba7fb9a710ef98caf04df3">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_enable_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_ep_enable_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the selected endpoint is enabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Endpoint is enabled. </td></tr>
    <tr><td class="paramname">false</td><td>Endpoint is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1219e767791807d91d92871e95346f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1219e767791807d91d92871e95346f91">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_handled_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_ep_handled_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__drv__usbd__handler__desc__t.html">nrf_drv_usbd_handler_desc_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start sending data over the endpoint using the transfer handler function. </p>
<p>This function initializes an endpoint transmission. Just before data is transmitted, the transfer handler is called and it prepares a data chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. For an IN endpoint, sending is initiated. For an OUT endpoint, receiving is initiated. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">p_handler</td><td>Transfer handler - feeder for IN direction and consumer for OUT direction.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Selected endpoint is pending. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>Unexpected transfer on EPIN0 or EPOUT0. </td></tr>
    <tr><td class="paramname">NRF_ERROR_FORBIDDEN</td><td>Endpoint stalled. </td></tr>
    <tr><td class="paramname">NRF_SUCCESS</td><td>Transfer queued or started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga73852623b474a7626496366089cb1d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73852623b474a7626496366089cb1d85">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_is_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_ep_is_busy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if endpoint buffer is ready or is under USB IP control. </p>
<p>Function to test if endpoint is busy. Endpoint that is busy cannot be accessed by MCU. It means that:</p><ul>
<li>OUT (TX) endpoint: Last uploaded data is still in endpoint and is waiting to be received by the host.</li>
<li>IN (RX) endpoint: Endpoint is ready to receive data from the host and the endpoint does not have any data. When endpoint is not busy:</li>
<li>OUT (TX) endpoint: New data can be uploaded.</li>
<li>IN (RX) endpoint: New data can be downloaded using <a class="el" href="group__nrf__drv__usbd.html#gabfed547bace8fe28d0142ad1af18a008">nrf_drv_usbd_ep_transfer</a> function. </li>
</ul>

</div>
</div>
<a id="ga693c13c49ab1fbe7ffa42386de8a15af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga693c13c49ab1fbe7ffa42386de8a15af">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_max_packet_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t nrf_drv_usbd_ep_max_packet_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get configured endpoint packet size. </p>
<p>Function to get configured endpoint size on the buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Maximum pocket size configured on selected endpoint </dd></dl>

</div>
</div>
<a id="ga2cea23d18bfb29af3b36aa53b32fca14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2cea23d18bfb29af3b36aa53b32fca14">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_max_packet_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_max_packet_size_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure packet size that should be supported by the endpoint. </p>
<p>The real endpoint buffer size is always the same. This value sets max packet size that would be transmitted over the endpoint. This is required by the library</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>Required maximum packet size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Endpoint size is always set to <a class="el" href="group__nrf__drv__usbd.html#ga3ecfa2bc5ba0c2b9c7cd384290f27739">NRF_DRV_USBD_EPSIZE</a> or <a class="el" href="group__nrf__drv__usbd.html#ga2482239c2133ddfe1fd269f8d2c44f6c">NRF_DRV_USBD_ISOSIZE</a> / 2 when <a class="el" href="group__nrf__drv__usbd.html#ga4dd2c52f807f3663cc864f358fd53ac6">nrf_drv_usbd_ep_enable</a> function is called. </dd></dl>

</div>
</div>
<a id="ga51ca226d86703aad748af44ca24dd819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51ca226d86703aad748af44ca24dd819">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_stall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_stall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stall endpoint. </p>
<p>Stall endpoit to send error information during next transfer request from the host.</p>
<dl class="section note"><dt>Note</dt><dd>To stall endpoint it is safer to use <a class="el" href="group__nrf__drv__usbd.html#ga680eae1b344512f9e7c166a740bfa5ba">nrf_drv_usbd_setup_stall</a> </dd>
<dd>
Stalled endpoint would not be cleared when DMA transfer finishes.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to stall </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaca00e5defeb5986340ecd0e7e9c364b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca00e5defeb5986340ecd0e7e9c364b9">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_stall_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_ep_stall_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if endpoint is stalled. </p>
<p>This function gets stall state of selected endpoint</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number to check </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga58141094e1a11a5b0e91e4a3b0f02784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58141094e1a11a5b0e91e4a3b0f02784">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_stall_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_ep_stall_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear stall flag on endpoint. </p>
<p>This function clears endpoint that is stalled. </p><dl class="section note"><dt>Note</dt><dd>If it is OUT endpoint (receiving) it would be also prepared for reception. It means that busy flag would be set. </dd>
<dd>
In endpoint (transmitting) would not be cleared - it gives possibility to write new data before transmitting. </dd></dl>

</div>
</div>
<a id="ga5d3467a64cb0eba21868aa9a1e96f0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3467a64cb0eba21868aa9a1e96f0d4">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_status_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_ep_status_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>p_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about last finished or current transfer. </p>
<p>Function returns the status of the last buffer set for transfer on selected endpoint. The status considers last buffer set by <a class="el" href="group__nrf__drv__usbd.html#gabfed547bace8fe28d0142ad1af18a008">nrf_drv_usbd_ep_transfer</a> function or by transfer callback function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_size</td><td>Information about the current/last transfer size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Transfer already finished </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Ongoing transfer </td></tr>
    <tr><td class="paramname">NRF_ERROR_DATA_SIZE</td><td>Too much of data received that cannot fit into buffer and cannot be splited into chunks. This may happen if buffer size is not a multiplication of endpoint buffer size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabfed547bace8fe28d0142ad1af18a008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfed547bace8fe28d0142ad1af18a008">&#9670;&nbsp;</a></span>nrf_drv_usbd_ep_transfer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_ep_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__drv__usbd__transfer__t.html">nrf_drv_usbd_transfer_t</a> const *const&#160;</td>
          <td class="paramname"><em>p_transfer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start sending data over endpoint. </p>
<p>Function initializes endpoint transmission. This is asynchronous function - it finishes immediately after configuration for transmission is prepared.</p>
<dl class="section note"><dt>Note</dt><dd>Data buffer pointed by p_data have to be kept active till <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dab9887fadb83f5b3193b45845a62180df">NRF_DRV_USBD_EVT_EPTRANSFER</a> event is generated.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>Endpoint number. For IN endpoint sending would be initiated. For OUT endpoint receiving would be initiated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_transfer</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>Selected endpoint is pending. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>Unexpected transfer on EPIN0 or EPOUT0. </td></tr>
    <tr><td class="paramname">NRF_ERROR_FORBIDDEN</td><td>Endpoint stalled. </td></tr>
    <tr><td class="paramname">NRF_SUCCESS</td><td>Transfer queued or started. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada3a71a437745665c288110fdb0356b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada3a71a437745665c288110fdb0356b8">&#9670;&nbsp;</a></span>nrf_drv_usbd_epout_size_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t nrf_drv_usbd_epout_size_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of received bytes. </p>
<p>Get the number of received bytes. The function behavior is undefined when called on IN endpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ep</td><td>Endpoint number.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of received bytes </dd></dl>

</div>
</div>
<a id="gad844c7b3654777b8e3a2c8d0b5657d26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad844c7b3654777b8e3a2c8d0b5657d26">&#9670;&nbsp;</a></span>nrf_drv_usbd_feeder_buffer_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* nrf_drv_usbd_feeder_buffer_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the temporary buffer to be used by the feeder. </p>
<p>This buffer is used for TX transfers and it can be reused automatically when the transfer is finished. Use it for transfer preparation.</p>
<p>May be used inside the feeder configured in <a class="el" href="group__nrf__drv__usbd.html#ga1219e767791807d91d92871e95346f91">nrf_drv_usbd_ep_handled_transfer</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the buffer that can be used temporarily.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__usbd.html#gab4bbed2bd99a3c54cc5956f16b72061c" title="The size of internal feeder buffer.">NRF_DRV_USBD_FEEDER_BUFFER_SIZE</a> </dd></dl>

</div>
</div>
<a id="gabf8b527764aefdbe4859981c56f96dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf8b527764aefdbe4859981c56f96dd5">&#9670;&nbsp;</a></span>nrf_drv_usbd_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaedc9aa1b393e8a00fe0aec2e756d3397">nrf_drv_usbd_event_handler_t</a> const&#160;</td>
          <td class="paramname"><em>event_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Library initialization. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>Event handler provided by the user. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb2723c73382ccd1db168d6e79d53e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb2723c73382ccd1db168d6e79d53e47">&#9670;&nbsp;</a></span>nrf_drv_usbd_is_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_is_enabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if driver is enabled. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Driver is disabled </td></tr>
    <tr><td class="paramname">true</td><td>Driver is enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ecb8a9633445fd9e2eb79f956e69361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ecb8a9633445fd9e2eb79f956e69361">&#9670;&nbsp;</a></span>nrf_drv_usbd_is_initialized()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_is_initialized </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if driver is initialized. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Driver is not initialized </td></tr>
    <tr><td class="paramname">true</td><td>Driver is initialized </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77db8d2bb83b5d393bd7b179f065fac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77db8d2bb83b5d393bd7b179f065fac6">&#9670;&nbsp;</a></span>nrf_drv_usbd_is_started()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_is_started </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if driver is started. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>Driver is not started </td></tr>
    <tr><td class="paramname">true</td><td>Driver is started (fully functional) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The USBD peripheral interrupt state is checked </dd></dl>

</div>
</div>
<a id="ga569381189170f7bbce7995894bcfaa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga569381189170f7bbce7995894bcfaa87">&#9670;&nbsp;</a></span>nrf_drv_usbd_last_setup_dir_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a> nrf_drv_usbd_last_setup_dir_get </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the information about expected transfer SETUP data direction. </p>
<p>Function returns the information about last expected transfer direction.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_DRV_USBD_EPOUT0</td><td>Expecting OUT (Host-&gt;Device) direction or no data </td></tr>
    <tr><td class="paramname">NRF_DRV_USBD_EPIN0</td><td>Expecting IN (Device-&gt;Host) direction </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa8aa78cfbacee0edfc5f43d184aaaddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8aa78cfbacee0edfc5f43d184aaaddc">&#9670;&nbsp;</a></span>nrf_drv_usbd_setup_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear setup endpoint. </p>
<p>This function acknowledges setup when SETUP command was received and processed. It has to be called if no data respond for the SETUP command is sent. </p>

</div>
</div>
<a id="gac6a84106ecef4effd20d615fb985ecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6a84106ecef4effd20d615fb985ecb8">&#9670;&nbsp;</a></span>nrf_drv_usbd_setup_data_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_data_clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear only for data transmission on setup endpoint. </p>
<p>This function may be called if any more data in control write transfer is expected. Clears only OUT endpoint to be able to take another OUT data token. It does not allow STATUS stage. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__usbd.html#gaa8aa78cfbacee0edfc5f43d184aaaddc" title="Clear setup endpoint.">nrf_drv_usbd_setup_clear</a> </dd></dl>

</div>
</div>
<a id="gae47e5d114e751ae88feee568a7dda845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae47e5d114e751ae88feee568a7dda845">&#9670;&nbsp;</a></span>nrf_drv_usbd_setup_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__usbd__setup__t.html">nrf_drv_usbd_setup_t</a> *const&#160;</td>
          <td class="paramname"><em>p_setup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get parsed setup data. </p>
<p>Function fills the parsed setup data structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_setup</td><td>Pointer to data structure that would be filled by parsed data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga680eae1b344512f9e7c166a740bfa5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga680eae1b344512f9e7c166a740bfa5ba">&#9670;&nbsp;</a></span>nrf_drv_usbd_setup_stall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_setup_stall </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stall setup endpoint. </p>
<p>Mark and error on setup endpoint. </p>

</div>
</div>
<a id="gacb757b8af8c827b45e306cfbd2d38045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb757b8af8c827b45e306cfbd2d38045">&#9670;&nbsp;</a></span>nrf_drv_usbd_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_start </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enable_sof</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start USB functionality. </p>
<p>After calling this function USBD peripheral should be fully functional and all new incoming events / interrupts would be processed by the library.</p>
<p>Also only after calling this function host sees new connected device.</p>
<p>Call this function when USBD power LDO regulator is ready - on USBPWRRDY event from POWER peripheral.</p>
<p>Before USBD interrupts are enabled, external HFXO is requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable_sof</td><td>The flag that is used to enable SOF processing. If it is false, SOF interrupt is left disabled and will not be generated. This improves power saving if SOF is not required.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the isochronous endpoints are going to be used, it is required to enable the SOF. In other case any isochronous endpoint would stay busy after first transmission. </dd></dl>

</div>
</div>
<a id="ga1ad60ee9a55f2be757f63b83ec7e45ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ad60ee9a55f2be757f63b83ec7e45ce">&#9670;&nbsp;</a></span>nrf_drv_usbd_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop USB functionality. </p>
<p>This function disables USBD pull-up and interrupts.</p>
<p>The HFXO request is released in this function.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used to logically disconnect USB from the HOST that would force it to enumerate device after calling <a class="el" href="group__nrf__drv__usbd.html#gacb757b8af8c827b45e306cfbd2d38045">nrf_drv_usbd_start</a>. </dd></dl>

</div>
</div>
<a id="gae40c7a874e4591d3b3b9e52d4d5721e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae40c7a874e4591d3b3b9e52d4d5721e8">&#9670;&nbsp;</a></span>nrf_drv_usbd_suspend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_suspend </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suspend USBD operation. </p>
<p>The USBD peripheral is forced to go into the low power mode. The function has to be called in the reaction to <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3da610d9052eed8b8fa98d6d66a9b4cfd78">NRF_DRV_USBD_EVT_SUSPEND</a> event when the firmware is ready.</p>
<p>After successful call of this function most of the USBD registers would be unavailable.</p>
<dl class="section note"><dt>Note</dt><dd>Check returned value for the feedback if suspending was successful.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>USBD peripheral successfully suspended </td></tr>
    <tr><td class="paramname">false</td><td>USBD peripheral was not suspended due to resume detection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ffc1368c7aa7251e9c609c15b935a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ffc1368c7aa7251e9c609c15b935a0b">&#9670;&nbsp;</a></span>nrf_drv_usbd_suspend_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_suspend_check </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if USBD is in SUSPEND mode. </p>
<dl class="section note"><dt>Note</dt><dd>This is the information about peripheral itself, not about the bus state.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>USBD peripheral is suspended </td></tr>
    <tr><td class="paramname">false</td><td>USBD peripheral is active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e3453e96cdb567f163877a7c605162d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e3453e96cdb567f163877a7c605162d">&#9670;&nbsp;</a></span>nrf_drv_usbd_suspend_irq_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_suspend_irq_config </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable only interrupts that should be processed in SUSPEND mode. </p>
<p>Auxiliary function to help with SUSPEND mode integration. It enables only the interrupts that can be properly processed without stable HFCLK.</p>
<p>Normally all the interrupts are enabled. Use this function to suspend interrupt processing that may require stable HFCLK until the clock is enabled.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__usbd.html#ga00d06c84ee4b51980f4411ca86ff1b31" title="Default active interrupt configuration.">nrf_drv_usbd_active_irq_config</a> </dd></dl>

</div>
</div>
<a id="ga52acb0c56ab24137f5e6d45f47e46a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52acb0c56ab24137f5e6d45f47e46a46">&#9670;&nbsp;</a></span>nrf_drv_usbd_transfer_out_drop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_drv_usbd_transfer_out_drop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__usbd.html#gaaa65ebeb12443fd8325e7447a2187f70">nrf_drv_usbd_ep_t</a>&#160;</td>
          <td class="paramname"><em>ep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drop transfer on OUT endpoint. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ep</td><td>OUT endpoint ID </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07274745cf2ca5867c1c50192aadaa43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07274745cf2ca5867c1c50192aadaa43">&#9670;&nbsp;</a></span>nrf_drv_usbd_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_usbd_uninit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Library deinitialization. </p>

</div>
</div>
<a id="gae12a91b95970c3b95fa2427c92e12297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae12a91b95970c3b95fa2427c92e12297">&#9670;&nbsp;</a></span>nrf_drv_usbd_wakeup_req()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_drv_usbd_wakeup_req </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start wake up procedure. </p>
<p>The USBD peripheral is forced to quit the low power mode. After calling this function all the USBD registers would be available.</p>
<p>The hardware starts measuring time when wake up is possible. This may take 0-5&#160;ms depending on how long the SUSPEND state was kept on the USB line.</p>
<p>When NRF_DRV_USBD_EVT_WUREQ event is generated it means that Wake Up signaling has just been started on the USB lines.</p>
<dl class="section note"><dt>Note</dt><dd>Do not expect only <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3dad801b6ddca9ca53d8d3493675600a1bd">NRF_DRV_USBD_EVT_WUREQ</a> event. There always may appear <a class="el" href="group__nrf__drv__usbd.html#gga9f0b03e5a41539896e07ccba22b67b3da773b2df8b85d14aae8e75b85dc75be32">NRF_DRV_USBD_EVT_RESUME</a> event. </dd>
<dd>
NRF_DRV_USBD_EVT_WUREQ event means that Remote WakeUp signal has just begun to be generated. This may take up to 20&#160;ms for the bus to become active.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>WakeUp procedure started. </td></tr>
    <tr><td class="paramname">false</td><td>No WakeUp procedure started - bus is already active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
