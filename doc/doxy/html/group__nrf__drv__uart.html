<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: UART driver - legacy layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nrf__drv__uart.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART driver - legacy layer<div class="ingroups"><a class="el" href="group__nrfx__drivers.html">Drivers</a> &raquo; <a class="el" href="group__nrf__uart.html">UART</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Layer providing compatibility with the former API.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for the UART driver instance.  <a href="structnrf__drv__uart__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__uart__config__t.html">nrf_drv_uart_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for UART configuration.  <a href="structnrf__drv__uart__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__uart__xfer__evt__t.html">nrf_drv_uart_xfer_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for UART transfer completion event.  <a href="structnrf__drv__uart__xfer__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__uart__error__evt__t.html">nrf_drv_uart_error_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for UART error event.  <a href="structnrf__drv__uart__error__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__drv__uart__event__t.html">nrf_drv_uart_event_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for UART event.  <a href="structnrf__drv__uart__event__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga79b31597ab0897dec549cdeb2d1ff2fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga79b31597ab0897dec549cdeb2d1ff2fb">NRF_DRV_UART_INSTANCE</a>(id)</td></tr>
<tr class="memdesc:ga79b31597ab0897dec549cdeb2d1ff2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for creating an UART driver instance.  <a href="group__nrf__drv__uart.html#ga79b31597ab0897dec549cdeb2d1ff2fb">More...</a><br /></td></tr>
<tr class="separator:ga79b31597ab0897dec549cdeb2d1ff2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996a4cdd2dddf38dffa0e990d60dacd1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga996a4cdd2dddf38dffa0e990d60dacd1">NRF_DRV_UART_DEFAULT_CONFIG_USE_EASY_DMA</a></td></tr>
<tr class="separator:ga996a4cdd2dddf38dffa0e990d60dacd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a3aff706907c73109fc26e21c373d2a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga2a3aff706907c73109fc26e21c373d2a">NRF_DRV_UART_DEFAULT_CONFIG</a></td></tr>
<tr class="memdesc:ga2a3aff706907c73109fc26e21c373d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART default configuration.  <a href="group__nrf__drv__uart.html#ga2a3aff706907c73109fc26e21c373d2a">More...</a><br /></td></tr>
<tr class="separator:ga2a3aff706907c73109fc26e21c373d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f81b61f2a164653c9f7e08be1d05de6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga0f81b61f2a164653c9f7e08be1d05de6">NRF_DRV_UART_USE_UARTE</a>&#160;&#160;&#160;false</td></tr>
<tr class="separator:ga0f81b61f2a164653c9f7e08be1d05de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26ce7bca9e6de00df0dda9424de4484e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga26ce7bca9e6de00df0dda9424de4484e">NRF_DRV_UART_USE_UART</a>&#160;&#160;&#160;(!<a class="el" href="group__nrf__drv__uart.html#ga0f81b61f2a164653c9f7e08be1d05de6">NRF_DRV_UART_USE_UARTE</a>)</td></tr>
<tr class="separator:ga26ce7bca9e6de00df0dda9424de4484e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae8b6e65fc9eeef778cc9f2d3283c65a9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gae8b6e65fc9eeef778cc9f2d3283c65a9">nrf_uart_event_handler_t</a>) (<a class="el" href="structnrf__drv__uart__event__t.html">nrf_drv_uart_event_t</a> *p_event, void *p_context)</td></tr>
<tr class="memdesc:gae8b6e65fc9eeef778cc9f2d3283c65a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">UART interrupt event handler.  <a href="group__nrf__drv__uart.html#gae8b6e65fc9eeef778cc9f2d3283c65a9">More...</a><br /></td></tr>
<tr class="separator:gae8b6e65fc9eeef778cc9f2d3283c65a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaa84abd1db22d7293580ea4a589e8b454"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gaa84abd1db22d7293580ea4a589e8b454">nrf_drv_uart_evt_type_t</a> { <a class="el" href="group__nrf__drv__uart.html#ggaa84abd1db22d7293580ea4a589e8b454aeb6251f9633625fc1b6c9f24640592ae">NRF_DRV_UART_EVT_TX_DONE</a>
, <a class="el" href="group__nrf__drv__uart.html#ggaa84abd1db22d7293580ea4a589e8b454ae9ce9d9931f6f453cbbbdf86962c7e37">NRF_DRV_UART_EVT_RX_DONE</a>
, <a class="el" href="group__nrf__drv__uart.html#ggaa84abd1db22d7293580ea4a589e8b454aa3e91b71c14e29ca3f2ea8f4d90d1545">NRF_DRV_UART_EVT_ERROR</a>
 }</td></tr>
<tr class="memdesc:gaa84abd1db22d7293580ea4a589e8b454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of UART driver events.  <a href="group__nrf__drv__uart.html#gaa84abd1db22d7293580ea4a589e8b454">More...</a><br /></td></tr>
<tr class="separator:gaa84abd1db22d7293580ea4a589e8b454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad7c986a0f927c30d6b1964609876045a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gad7c986a0f927c30d6b1964609876045a">nrf_drv_uart_init</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance, <a class="el" href="structnrf__drv__uart__config__t.html">nrf_drv_uart_config_t</a> const *p_config, <a class="el" href="group__nrf__drv__uart.html#gae8b6e65fc9eeef778cc9f2d3283c65a9">nrf_uart_event_handler_t</a> event_handler)</td></tr>
<tr class="memdesc:gad7c986a0f927c30d6b1964609876045a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the UART driver.  <a href="group__nrf__drv__uart.html#gad7c986a0f927c30d6b1964609876045a">More...</a><br /></td></tr>
<tr class="separator:gad7c986a0f927c30d6b1964609876045a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9a26fbbed87cef98549e48ca83237e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gad9a26fbbed87cef98549e48ca83237e7">nrf_drv_uart_uninit</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gad9a26fbbed87cef98549e48ca83237e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing the UART driver.  <a href="group__nrf__drv__uart.html#gad9a26fbbed87cef98549e48ca83237e7">More...</a><br /></td></tr>
<tr class="separator:gad9a26fbbed87cef98549e48ca83237e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86901e1da42ca27af748ed1af532165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gaf86901e1da42ca27af748ed1af532165">nrf_drv_uart_task_address_get</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance, <a class="el" href="group__nrf__uart__hal.html#ga61ed3c0eb7723a0dfda76d7d5025e5a8">nrf_uart_task_t</a> task)</td></tr>
<tr class="memdesc:gaf86901e1da42ca27af748ed1af532165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the address of a specific UART task.  <a href="group__nrf__drv__uart.html#gaf86901e1da42ca27af748ed1af532165">More...</a><br /></td></tr>
<tr class="separator:gaf86901e1da42ca27af748ed1af532165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga467a4611051e16c4cee46de16dd63862"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga467a4611051e16c4cee46de16dd63862">nrf_drv_uart_event_address_get</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance, <a class="el" href="group__nrf__uart__hal.html#gad1710c9c8832f8d4b3264cca8029b730">nrf_uart_event_t</a> event)</td></tr>
<tr class="memdesc:ga467a4611051e16c4cee46de16dd63862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the address of a specific UART event.  <a href="group__nrf__drv__uart.html#ga467a4611051e16c4cee46de16dd63862">More...</a><br /></td></tr>
<tr class="separator:ga467a4611051e16c4cee46de16dd63862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba674e6c4f1d17cf233cb21c4a237b6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> <a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gaba674e6c4f1d17cf233cb21c4a237b6b">nrf_drv_uart_tx</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance, uint8_t const *const p_data, uint8_t length)</td></tr>
<tr class="memdesc:gaba674e6c4f1d17cf233cb21c4a237b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for sending data over UART.  <a href="group__nrf__drv__uart.html#gaba674e6c4f1d17cf233cb21c4a237b6b">More...</a><br /></td></tr>
<tr class="separator:gaba674e6c4f1d17cf233cb21c4a237b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44803e6c4e004b9015d87b305f76e7b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga44803e6c4e004b9015d87b305f76e7b5">nrf_drv_uart_tx_in_progress</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga44803e6c4e004b9015d87b305f76e7b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for checking if UART is currently transmitting.  <a href="group__nrf__drv__uart.html#ga44803e6c4e004b9015d87b305f76e7b5">More...</a><br /></td></tr>
<tr class="separator:ga44803e6c4e004b9015d87b305f76e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb540dc7802b104aa0cc109c0d27e451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gafb540dc7802b104aa0cc109c0d27e451">nrf_drv_uart_tx_abort</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gafb540dc7802b104aa0cc109c0d27e451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for aborting any ongoing transmission.  <a href="group__nrf__drv__uart.html#gafb540dc7802b104aa0cc109c0d27e451">More...</a><br /></td></tr>
<tr class="separator:gafb540dc7802b104aa0cc109c0d27e451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a3b2215181a0a0956ed945a687f68a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> <a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga4a3b2215181a0a0956ed945a687f68a2">nrf_drv_uart_rx</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance, uint8_t *p_data, uint8_t length)</td></tr>
<tr class="memdesc:ga4a3b2215181a0a0956ed945a687f68a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for receiving data over UART.  <a href="group__nrf__drv__uart.html#ga4a3b2215181a0a0956ed945a687f68a2">More...</a><br /></td></tr>
<tr class="separator:ga4a3b2215181a0a0956ed945a687f68a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ef64957b4178d1650aa52a79e0ff873"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga4ef64957b4178d1650aa52a79e0ff873">nrf_drv_uart_rx_ready</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga4ef64957b4178d1650aa52a79e0ff873"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for testing the receiver state in blocking mode.  <a href="group__nrf__drv__uart.html#ga4ef64957b4178d1650aa52a79e0ff873">More...</a><br /></td></tr>
<tr class="separator:ga4ef64957b4178d1650aa52a79e0ff873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd920847cf9dd669908efcdf30cc12ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gabd920847cf9dd669908efcdf30cc12ac">nrf_drv_uart_rx_enable</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gabd920847cf9dd669908efcdf30cc12ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for enabling the receiver.  <a href="group__nrf__drv__uart.html#gabd920847cf9dd669908efcdf30cc12ac">More...</a><br /></td></tr>
<tr class="separator:gabd920847cf9dd669908efcdf30cc12ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae0761affc9c108fd22dccdd8a95d320"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#gaae0761affc9c108fd22dccdd8a95d320">nrf_drv_uart_rx_disable</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:gaae0761affc9c108fd22dccdd8a95d320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for disabling the receiver.  <a href="group__nrf__drv__uart.html#gaae0761affc9c108fd22dccdd8a95d320">More...</a><br /></td></tr>
<tr class="separator:gaae0761affc9c108fd22dccdd8a95d320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32deffd7c6b14ee0ff9557f4cfe67e10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga32deffd7c6b14ee0ff9557f4cfe67e10">nrf_drv_uart_rx_abort</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga32deffd7c6b14ee0ff9557f4cfe67e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for aborting any ongoing reception.  <a href="group__nrf__drv__uart.html#ga32deffd7c6b14ee0ff9557f4cfe67e10">More...</a><br /></td></tr>
<tr class="separator:ga32deffd7c6b14ee0ff9557f4cfe67e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e333662596e6c9090e77629c92c0bfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__drv__uart.html#ga2e333662596e6c9090e77629c92c0bfa">nrf_drv_uart_errorsrc_get</a> (<a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *p_instance)</td></tr>
<tr class="memdesc:ga2e333662596e6c9090e77629c92c0bfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading error source mask. Mask contains values from <a class="el" href="nrf__drv__uart_8h.html#a2fdd75e4c04752d66986b9afcee1d961">nrf_uart_error_mask_t</a>.  <a href="group__nrf__drv__uart.html#ga2e333662596e6c9090e77629c92c0bfa">More...</a><br /></td></tr>
<tr class="separator:ga2e333662596e6c9090e77629c92c0bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Layer providing compatibility with the former API. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga2a3aff706907c73109fc26e21c373d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a3aff706907c73109fc26e21c373d2a">&#9670;&nbsp;</a></span>NRF_DRV_UART_DEFAULT_CONFIG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_UART_DEFAULT_CONFIG</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                            \</div>
<div class="line">    .pseltxd            = <a class="code" href="nrf__drv__uart_8h.html#a505f00f51ff5b93317032f1e3b5ba1a6">NRF_UART_PSEL_DISCONNECTED</a>,                        \</div>
<div class="line">    .pselrxd            = <a class="code" href="nrf__drv__uart_8h.html#a505f00f51ff5b93317032f1e3b5ba1a6">NRF_UART_PSEL_DISCONNECTED</a>,                        \</div>
<div class="line">    .pselcts            = <a class="code" href="nrf__drv__uart_8h.html#a505f00f51ff5b93317032f1e3b5ba1a6">NRF_UART_PSEL_DISCONNECTED</a>,                        \</div>
<div class="line">    .pselrts            = <a class="code" href="nrf__drv__uart_8h.html#a505f00f51ff5b93317032f1e3b5ba1a6">NRF_UART_PSEL_DISCONNECTED</a>,                        \</div>
<div class="line">    .p_context          = <a class="code" href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,                                              \</div>
<div class="line">    .hwfc               = (<a class="code" href="nrf__drv__uart_8h.html#a4d6d2a5af17a32cfea4c39980a73c650">nrf_uart_hwfc_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a65718c0fda0721bc5a8e72892483325e">UART_DEFAULT_CONFIG_HWFC</a>,         \</div>
<div class="line">    .parity             = (<a class="code" href="group__nrf__uart__hal.html#ga26a900177fa34963f4ac68f3896ad803">nrf_uart_parity_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a0dc2bad231549336c5530bcd4cff8a8a">UART_DEFAULT_CONFIG_PARITY</a>,     \</div>
<div class="line">    .baudrate           = (<a class="code" href="nrf__drv__uart_8h.html#a62646cac20b888cd87c8ef5a504506fd">nrf_uart_baudrate_t</a>)<a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a59676f98ac47b00144dbaca39fd8689b">UART_DEFAULT_CONFIG_BAUDRATE</a>, \</div>
<div class="line">    .interrupt_priority = <a class="code" href="config_2nrf52810_2config_2sdk__config_8h.html#a944f5ac0da3660a39ebd3bbf1a879894">UART_DEFAULT_CONFIG_IRQ_PRIORITY</a>,                  \</div>
<div class="line">    <a class="code" href="group__nrf__drv__uart.html#ga996a4cdd2dddf38dffa0e990d60dacd1">NRF_DRV_UART_DEFAULT_CONFIG_USE_EASY_DMA</a>                                 \</div>
<div class="line">}</div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a0dc2bad231549336c5530bcd4cff8a8a"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a0dc2bad231549336c5530bcd4cff8a8a">UART_DEFAULT_CONFIG_PARITY</a></div><div class="ttdeci">#define UART_DEFAULT_CONFIG_PARITY</div><div class="ttdef"><b>Definition:</b> sdk_config.h:4577</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a59676f98ac47b00144dbaca39fd8689b"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a59676f98ac47b00144dbaca39fd8689b">UART_DEFAULT_CONFIG_BAUDRATE</a></div><div class="ttdeci">#define UART_DEFAULT_CONFIG_BAUDRATE</div><div class="ttdef"><b>Definition:</b> sdk_config.h:4600</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a65718c0fda0721bc5a8e72892483325e"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a65718c0fda0721bc5a8e72892483325e">UART_DEFAULT_CONFIG_HWFC</a></div><div class="ttdeci">#define UART_DEFAULT_CONFIG_HWFC</div><div class="ttdef"><b>Definition:</b> sdk_config.h:4568</div></div>
<div class="ttc" id="aconfig_2nrf52810_2config_2sdk__config_8h_html_a944f5ac0da3660a39ebd3bbf1a879894"><div class="ttname"><a href="config_2nrf52810_2config_2sdk__config_8h.html#a944f5ac0da3660a39ebd3bbf1a879894">UART_DEFAULT_CONFIG_IRQ_PRIORITY</a></div><div class="ttdeci">#define UART_DEFAULT_CONFIG_IRQ_PRIORITY</div><div class="ttdef"><b>Definition:</b> sdk_config.h:4617</div></div>
<div class="ttc" id="adef_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="def_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> def.h:70</div></div>
<div class="ttc" id="agroup__nrf__drv__uart_html_ga996a4cdd2dddf38dffa0e990d60dacd1"><div class="ttname"><a href="group__nrf__drv__uart.html#ga996a4cdd2dddf38dffa0e990d60dacd1">NRF_DRV_UART_DEFAULT_CONFIG_USE_EASY_DMA</a></div><div class="ttdeci">#define NRF_DRV_UART_DEFAULT_CONFIG_USE_EASY_DMA</div><div class="ttdef"><b>Definition:</b> nrf_drv_uart.h:200</div></div>
<div class="ttc" id="agroup__nrf__uart__hal_html_ga26a900177fa34963f4ac68f3896ad803"><div class="ttname"><a href="group__nrf__uart__hal.html#ga26a900177fa34963f4ac68f3896ad803">nrf_uart_parity_t</a></div><div class="ttdeci">nrf_uart_parity_t</div><div class="ttdoc">Types of UART parity modes.</div><div class="ttdef"><b>Definition:</b> nrf_uart.h:149</div></div>
<div class="ttc" id="anrf__drv__uart_8h_html_a4d6d2a5af17a32cfea4c39980a73c650"><div class="ttname"><a href="nrf__drv__uart_8h.html#a4d6d2a5af17a32cfea4c39980a73c650">nrf_uart_hwfc_t</a></div><div class="ttdeci">nrf_uarte_hwfc_t nrf_uart_hwfc_t</div><div class="ttdef"><b>Definition:</b> nrf_drv_uart.h:124</div></div>
<div class="ttc" id="anrf__drv__uart_8h_html_a505f00f51ff5b93317032f1e3b5ba1a6"><div class="ttname"><a href="nrf__drv__uart_8h.html#a505f00f51ff5b93317032f1e3b5ba1a6">NRF_UART_PSEL_DISCONNECTED</a></div><div class="ttdeci">#define NRF_UART_PSEL_DISCONNECTED</div><div class="ttdef"><b>Definition:</b> nrf_drv_uart.h:130</div></div>
<div class="ttc" id="anrf__drv__uart_8h_html_a62646cac20b888cd87c8ef5a504506fd"><div class="ttname"><a href="nrf__drv__uart_8h.html#a62646cac20b888cd87c8ef5a504506fd">nrf_uart_baudrate_t</a></div><div class="ttdeci">nrf_uarte_baudrate_t nrf_uart_baudrate_t</div><div class="ttdef"><b>Definition:</b> nrf_drv_uart.h:116</div></div>
</div><!-- fragment -->
<p>UART default configuration. </p>

</div>
</div>
<a id="ga996a4cdd2dddf38dffa0e990d60dacd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996a4cdd2dddf38dffa0e990d60dacd1">&#9670;&nbsp;</a></span>NRF_DRV_UART_DEFAULT_CONFIG_USE_EASY_DMA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_UART_DEFAULT_CONFIG_USE_EASY_DMA</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga79b31597ab0897dec549cdeb2d1ff2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79b31597ab0897dec549cdeb2d1ff2fb">&#9670;&nbsp;</a></span>NRF_DRV_UART_INSTANCE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_UART_INSTANCE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">id</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                 \</div>
<div class="line">    .inst_idx = id,               \</div>
<div class="line">    NRF_DRV_UART_CREATE_UARTE(<span class="keywordtype">id</span>) \</div>
<div class="line">    NRF_DRV_UART_CREATE_UART(<span class="keywordtype">id</span>)  \</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Macro for creating an UART driver instance. </p>

</div>
</div>
<a id="ga26ce7bca9e6de00df0dda9424de4484e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26ce7bca9e6de00df0dda9424de4484e">&#9670;&nbsp;</a></span>NRF_DRV_UART_USE_UART</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_UART_USE_UART&#160;&#160;&#160;(!<a class="el" href="group__nrf__drv__uart.html#ga0f81b61f2a164653c9f7e08be1d05de6">NRF_DRV_UART_USE_UARTE</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga0f81b61f2a164653c9f7e08be1d05de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f81b61f2a164653c9f7e08be1d05de6">&#9670;&nbsp;</a></span>NRF_DRV_UART_USE_UARTE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_DRV_UART_USE_UARTE&#160;&#160;&#160;false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gae8b6e65fc9eeef778cc9f2d3283c65a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8b6e65fc9eeef778cc9f2d3283c65a9">&#9670;&nbsp;</a></span>nrf_uart_event_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nrf_uart_event_handler_t) (<a class="el" href="structnrf__drv__uart__event__t.html">nrf_drv_uart_event_t</a> *p_event, void *p_context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UART interrupt event handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>Pointer to event structure. Event is allocated on the stack so it is available only within the context of the event handler. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>Context passed to interrupt handler, set on initialization. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaa84abd1db22d7293580ea4a589e8b454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa84abd1db22d7293580ea4a589e8b454">&#9670;&nbsp;</a></span>nrf_drv_uart_evt_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__drv__uart.html#gaa84abd1db22d7293580ea4a589e8b454">nrf_drv_uart_evt_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of UART driver events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaa84abd1db22d7293580ea4a589e8b454aeb6251f9633625fc1b6c9f24640592ae"></a>NRF_DRV_UART_EVT_TX_DONE&#160;</td><td class="fielddoc"><p>Requested TX transfer completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa84abd1db22d7293580ea4a589e8b454ae9ce9d9931f6f453cbbbdf86962c7e37"></a>NRF_DRV_UART_EVT_RX_DONE&#160;</td><td class="fielddoc"><p>Requested RX transfer completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaa84abd1db22d7293580ea4a589e8b454aa3e91b71c14e29ca3f2ea8f4d90d1545"></a>NRF_DRV_UART_EVT_ERROR&#160;</td><td class="fielddoc"><p>Error reported by UART peripheral. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2e333662596e6c9090e77629c92c0bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e333662596e6c9090e77629c92c0bfa">&#9670;&nbsp;</a></span>nrf_drv_uart_errorsrc_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t nrf_drv_uart_errorsrc_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading error source mask. Mask contains values from <a class="el" href="nrf__drv__uart_8h.html#a2fdd75e4c04752d66986b9afcee1d961">nrf_uart_error_mask_t</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Function should be used in blocking mode only. In case of non-blocking mode, an error event is generated. Function clears error sources after reading.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Mask</td><td>of reported errors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga467a4611051e16c4cee46de16dd63862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga467a4611051e16c4cee46de16dd63862">&#9670;&nbsp;</a></span>nrf_drv_uart_event_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t nrf_drv_uart_event_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__uart__hal.html#gad1710c9c8832f8d4b3264cca8029b730">nrf_uart_event_t</a>&#160;</td>
          <td class="paramname"><em>event</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the address of a specific UART event. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td>Event.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event address. </dd></dl>

</div>
</div>
<a id="gad7c986a0f927c30d6b1964609876045a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7c986a0f927c30d6b1964609876045a">&#9670;&nbsp;</a></span>nrf_drv_uart_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_uart_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__config__t.html">nrf_drv_uart_config_t</a> const *&#160;</td>
          <td class="paramname"><em>p_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__drv__uart.html#gae8b6e65fc9eeef778cc9f2d3283c65a9">nrf_uart_event_handler_t</a>&#160;</td>
          <td class="paramname"><em>event_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the UART driver. </p>
<p>This function configures and enables UART. After this function GPIO pins are controlled by UART.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_config</td><td>Initial configuration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>Event handler provided by the user. If not provided driver works in blocking mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_STATE</td><td>If driver is already initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4a3b2215181a0a0956ed945a687f68a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a3b2215181a0a0956ed945a687f68a2">&#9670;&nbsp;</a></span>nrf_drv_uart_rx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> <a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_uart_rx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for receiving data over UART. </p>
<p>If an event handler was provided in the <a class="el" href="group__nrf__drv__uart.html#gad7c986a0f927c30d6b1964609876045a" title="Function for initializing the UART driver.">nrf_drv_uart_init()</a> call, this function returns immediately and the handler is called when the transfer is done. Otherwise, the transfer is performed in blocking mode, i.e. this function returns when the transfer is finished. Blocking mode is not using interrupt so there is no context switching inside the function. The receive buffer pointer is double buffered in non-blocking mode. The secondary buffer can be set immediately after starting the transfer and will be filled when the primary buffer is full. The double buffering feature allows receiving data continuously.</p>
<dl class="section note"><dt>Note</dt><dd>Peripherals using EasyDMA (i.e. UARTE) require that the transfer buffers are placed in the Data RAM region. If they are not and UARTE driver instance is used, this function will fail with error code NRFX_ERROR_INVALID_ADDR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_data</td><td>Pointer to data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to receive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>If the driver is already receiving (and the secondary buffer has already been set in non-blocking mode). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_FORBIDDEN</td><td>If the transfer was aborted from a different context (blocking mode only, also see <a class="el" href="group__nrf__drv__uart.html#gaae0761affc9c108fd22dccdd8a95d320">nrf_drv_uart_rx_disable</a>). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INTERNAL</td><td>If UART peripheral reported an error. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_ADDR</td><td>If p_data does not point to RAM buffer (UARTE only). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga32deffd7c6b14ee0ff9557f4cfe67e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32deffd7c6b14ee0ff9557f4cfe67e10">&#9670;&nbsp;</a></span>nrf_drv_uart_rx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrf_drv_uart_rx_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for aborting any ongoing reception. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__nrf__drv__uart.html#ggaa84abd1db22d7293580ea4a589e8b454ae9ce9d9931f6f453cbbbdf86962c7e37">NRF_DRV_UART_EVT_RX_DONE</a> event will be generated in non-blocking mode. The event will contain the number of bytes received until abort was called. The event is called from UART interrupt context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae0761affc9c108fd22dccdd8a95d320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae0761affc9c108fd22dccdd8a95d320">&#9670;&nbsp;</a></span>nrf_drv_uart_rx_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrf_drv_uart_rx_disable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for disabling the receiver. </p>
<p>This function must be called to close the receiver after it has been explicitly enabled by </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__uart.html#gabd920847cf9dd669908efcdf30cc12ac" title="Function for enabling the receiver.">nrf_drv_uart_rx_enable</a>. The feature is supported only in UART mode (without Easy DMA). The function asserts if mode is wrong.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabd920847cf9dd669908efcdf30cc12ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd920847cf9dd669908efcdf30cc12ac">&#9670;&nbsp;</a></span>nrf_drv_uart_rx_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrf_drv_uart_rx_enable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for enabling the receiver. </p>
<p>UART has a 6-byte-long RX FIFO and it is used to store incoming data. If a user does not call the UART receive function before the FIFO is filled, an overrun error will appear. Enabling the receiver without specifying an RX buffer is supported only in UART mode (without Easy DMA). The receiver must be explicitly closed by the user </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__nrf__drv__uart.html#gaae0761affc9c108fd22dccdd8a95d320" title="Function for disabling the receiver.">nrf_drv_uart_rx_disable</a>. This function asserts if the mode is wrong.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4ef64957b4178d1650aa52a79e0ff873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ef64957b4178d1650aa52a79e0ff873">&#9670;&nbsp;</a></span>nrf_drv_uart_rx_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> bool nrf_drv_uart_rx_ready </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for testing the receiver state in blocking mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the receiver has at least one byte of data to get. </td></tr>
    <tr><td class="paramname">false</td><td>If the receiver is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf86901e1da42ca27af748ed1af532165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86901e1da42ca27af748ed1af532165">&#9670;&nbsp;</a></span>nrf_drv_uart_task_address_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t nrf_drv_uart_task_address_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__uart__hal.html#ga61ed3c0eb7723a0dfda76d7d5025e5a8">nrf_uart_task_t</a>&#160;</td>
          <td class="paramname"><em>task</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the address of a specific UART task. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">task</td><td>Task.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Task address. </dd></dl>

</div>
</div>
<a id="gaba674e6c4f1d17cf233cb21c4a237b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba674e6c4f1d17cf233cb21c4a237b6b">&#9670;&nbsp;</a></span>nrf_drv_uart_tx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> <a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_drv_uart_tx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t const *const&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for sending data over UART. </p>
<p>If an event handler was provided in <a class="el" href="group__nrf__drv__uart.html#gad7c986a0f927c30d6b1964609876045a" title="Function for initializing the UART driver.">nrf_drv_uart_init()</a> call, this function returns immediately and the handler is called when the transfer is done. Otherwise, the transfer is performed in blocking mode, i.e. this function returns when the transfer is finished. Blocking mode is not using interrupt so there is no context switching inside the function.</p>
<dl class="section note"><dt>Note</dt><dd>Peripherals using EasyDMA (i.e. UARTE) require that the transfer buffers are placed in the Data RAM region. If they are not and UARTE instance is used, this function will fail with error code NRFX_ERROR_INVALID_ADDR.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_data</td><td>Pointer to data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of bytes to send.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRFX_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_BUSY</td><td>If driver is already transferring. </td></tr>
    <tr><td class="paramname">NRFX_ERROR_FORBIDDEN</td><td>If the transfer was aborted from a different context (blocking mode only, also see <a class="el" href="group__nrf__drv__uart.html#gaae0761affc9c108fd22dccdd8a95d320">nrf_drv_uart_rx_disable</a>). </td></tr>
    <tr><td class="paramname">NRFX_ERROR_INVALID_ADDR</td><td>If p_data does not point to RAM buffer (UARTE only). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb540dc7802b104aa0cc109c0d27e451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb540dc7802b104aa0cc109c0d27e451">&#9670;&nbsp;</a></span>nrf_drv_uart_tx_abort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrf_drv_uart_tx_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for aborting any ongoing transmission. </p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__nrf__drv__uart.html#ggaa84abd1db22d7293580ea4a589e8b454aeb6251f9633625fc1b6c9f24640592ae">NRF_DRV_UART_EVT_TX_DONE</a> event will be generated in non-blocking mode. Event will contain number of bytes sent until abort was called. If Easy DMA is not used event will be called from the function context. If Easy DMA is used it will be called from UART interrupt context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44803e6c4e004b9015d87b305f76e7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44803e6c4e004b9015d87b305f76e7b5">&#9670;&nbsp;</a></span>nrf_drv_uart_tx_in_progress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> bool nrf_drv_uart_tx_in_progress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for checking if UART is currently transmitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If UART is transmitting. </td></tr>
    <tr><td class="paramname">false</td><td>If UART is not transmitting. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad9a26fbbed87cef98549e48ca83237e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9a26fbbed87cef98549e48ca83237e7">&#9670;&nbsp;</a></span>nrf_drv_uart_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mock__pb__decode_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void nrf_drv_uart_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__drv__uart__t.html">nrf_drv_uart_t</a> const *&#160;</td>
          <td class="paramname"><em>p_instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing the UART driver. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_instance</td><td>Pointer to the driver instance structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
