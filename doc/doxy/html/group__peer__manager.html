<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: Peer Manager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__peer__manager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Peer Manager</div>  </div>
</div><!--header-->
<div class="contents">

<p>Module for managing BLE bonding, which includes controlling encryption and pairing procedures as well as persistently storing different pieces of data that must be stored when bonded.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group___p_m___s_e_c___e_r_r_o_r_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_m___s_e_c___e_r_r_o_r_s.html">Peer Manager defined security errors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group___p_m___p_e_e_r___i_d___v_e_r_s_i_o_n_s"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___p_m___p_e_e_r___i_d___v_e_r_s_i_o_n_s.html">All versions of Peer IDs.</a></td></tr>
<tr class="memdesc:group___p_m___p_e_e_r___i_d___v_e_r_s_i_o_n_s"><td class="mdescLeft">&#160;</td><td class="mdescRight">The data ID for each iteration of the data formats in flash. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__conn__sec__status__t.html">pm_conn_sec_status_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Security status of a connection.  <a href="structpm__conn__sec__status__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__conn__sec__config__t.html">pm_conn_sec_config_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration of a security procedure.  <a href="structpm__conn__sec__config__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data associated with a bond to a peer.  <a href="structpm__peer__data__bonding__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__peer__data__local__gatt__db__t.html">pm_peer_data_local_gatt_db_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data on a local GATT database.  <a href="structpm__peer__data__local__gatt__db__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__conn__sec__start__evt__t.html">pm_conn_sec_start_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Events parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bae2a89b2bbba5a84adf4df81741e35316">PM_EVT_CONN_SEC_START</a> event.  <a href="structpm__conn__sec__start__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__conn__secured__evt__t.html">pm_conn_secured_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba029dc0c5885544eb721fa5ea9b478047">PM_EVT_CONN_SEC_SUCCEEDED</a> event.  <a href="structpm__conn__secured__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__conn__secure__failed__evt__t.html">pm_conn_secure_failed_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba91fc8b7bc151fc0028fbc03ced08eea4">PM_EVT_CONN_SEC_FAILED</a> event.  <a href="structpm__conn__secure__failed__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__conn__sec__params__req__evt__t.html">pm_conn_sec_params_req_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba7ebd4003aafe1f0987f8ddacbb13444a">PM_EVT_CONN_SEC_PARAMS_REQ</a> event.  <a href="structpm__conn__sec__params__req__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__peer__data__update__succeeded__evt__t.html">pm_peer_data_update_succeeded_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808badfca2d9adc511c7bf5652f4741c0cead">PM_EVT_PEER_DATA_UPDATE_SUCCEEDED</a> event.  <a href="structpm__peer__data__update__succeeded__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__peer__data__update__failed__t.html">pm_peer_data_update_failed_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba0bc454bb2f85cd7b6a05b3e4e8abeb83">PM_EVT_PEER_DATA_UPDATE_FAILED</a> event.  <a href="structpm__peer__data__update__failed__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__failure__evt__t.html">pm_failure_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard parameters for failure events.  <a href="structpm__failure__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__evt__slave__security__req__t.html">pm_evt_slave_security_req_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Events parameters specific to the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba56cbbcf8f7f6492c7ffe3ede8a1d1e78">PM_EVT_SLAVE_SECURITY_REQ</a> event.  <a href="structpm__evt__slave__security__req__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpm__evt__t.html">pm_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An event from the <a class="el" href="group__peer__manager.html">Peer Manager</a> module.  <a href="structpm__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga8a57c33c829ad19bc6a2cd655b40dc9b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a>&#160;&#160;&#160;0xFFFF</td></tr>
<tr class="memdesc:ga8a57c33c829ad19bc6a2cd655b40dc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid value for <a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>.  <a href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">More...</a><br /></td></tr>
<tr class="separator:ga8a57c33c829ad19bc6a2cd655b40dc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb8282ab380eb5e409449155b3c18f26"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gadb8282ab380eb5e409449155b3c18f26">PM_STORE_TOKEN_INVALID</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:gadb8282ab380eb5e409449155b3c18f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid value for store token.  <a href="group__peer__manager.html#gadb8282ab380eb5e409449155b3c18f26">More...</a><br /></td></tr>
<tr class="separator:gadb8282ab380eb5e409449155b3c18f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbbdb8df64d46e64e6817782f9568eaa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gabbbdb8df64d46e64e6817782f9568eaa">PM_PEER_ID_N_AVAILABLE_IDS</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:gabbbdb8df64d46e64e6817782f9568eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of available peer IDs.  <a href="group__peer__manager.html#gabbbdb8df64d46e64e6817782f9568eaa">More...</a><br /></td></tr>
<tr class="separator:gabbbdb8df64d46e64e6817782f9568eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99076c351109c551432b53af13466ec9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga99076c351109c551432b53af13466ec9">PM_LOCAL_DB_LEN_OVERHEAD_BYTES</a>&#160;&#160;&#160;offsetof(<a class="el" href="structpm__peer__data__local__gatt__db__t.html">pm_peer_data_local_gatt_db_t</a>, data)</td></tr>
<tr class="memdesc:ga99076c351109c551432b53af13466ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The static-length part of the local GATT data struct.  <a href="group__peer__manager.html#ga99076c351109c551432b53af13466ec9">More...</a><br /></td></tr>
<tr class="separator:ga99076c351109c551432b53af13466ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c89b6d900d78158b76b4f57bed47a25"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga1c89b6d900d78158b76b4f57bed47a25">PM_CONN_SEC_ERROR_BASE</a>&#160;&#160;&#160;0x1000</td></tr>
<tr class="memdesc:ga1c89b6d900d78158b76b4f57bed47a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base for Peer Manager defined errors. See <a class="el" href="group___p_m___s_e_c___e_r_r_o_r_s.html">Peer Manager defined security errors</a> and <a class="el" href="group__peer__manager.html#gaa15b5088baabcad882f2f6484dc4d70e">pm_sec_error_code_t</a>.  <a href="group__peer__manager.html#ga1c89b6d900d78158b76b4f57bed47a25">More...</a><br /></td></tr>
<tr class="separator:ga1c89b6d900d78158b76b4f57bed47a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0aa174d9642816af3ba36db985465f46"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a></td></tr>
<tr class="memdesc:ga0aa174d9642816af3ba36db985465f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to uniquely identify a peer for which we have persistently stored data.  <a href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">More...</a><br /></td></tr>
<tr class="separator:ga0aa174d9642816af3ba36db985465f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f3a50ca5645386b3f6cd7ebbee84264"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga5f3a50ca5645386b3f6cd7ebbee84264">pm_prepare_token_t</a></td></tr>
<tr class="memdesc:ga5f3a50ca5645386b3f6cd7ebbee84264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that is used for write prepares (used to reserve space in flash).  <a href="group__peer__manager.html#ga5f3a50ca5645386b3f6cd7ebbee84264">More...</a><br /></td></tr>
<tr class="separator:ga5f3a50ca5645386b3f6cd7ebbee84264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga090324ad9f53add6b9a1e971f953f452"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a></td></tr>
<tr class="memdesc:ga090324ad9f53add6b9a1e971f953f452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that is used to hold a reference to a stored item in flash.  <a href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">More...</a><br /></td></tr>
<tr class="separator:ga090324ad9f53add6b9a1e971f953f452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa15b5088baabcad882f2f6484dc4d70e"><td class="memItemLeft" align="right" valign="top">typedef uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaa15b5088baabcad882f2f6484dc4d70e">pm_sec_error_code_t</a></td></tr>
<tr class="memdesc:gaa15b5088baabcad882f2f6484dc4d70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Errors from security procedures in Peer Manager.  <a href="group__peer__manager.html#gaa15b5088baabcad882f2f6484dc4d70e">More...</a><br /></td></tr>
<tr class="separator:gaa15b5088baabcad882f2f6484dc4d70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d267fa432149f37e231c8f11ad8a395"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structble__gap__privacy__params__t.html">ble_gap_privacy_params_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">pm_privacy_params_t</a></td></tr>
<tr class="memdesc:ga5d267fa432149f37e231c8f11ad8a395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Device Privacy.  <a href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">More...</a><br /></td></tr>
<tr class="separator:ga5d267fa432149f37e231c8f11ad8a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de7838090b1a30c2077c82618a608e9"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga8de7838090b1a30c2077c82618a608e9">pm_evt_handler_t</a>) (<a class="el" href="structpm__evt__t.html">pm_evt_t</a> const *p_event)</td></tr>
<tr class="memdesc:ga8de7838090b1a30c2077c82618a608e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler for events from the <a class="el" href="group__peer__manager.html">Peer Manager</a> module.  <a href="group__peer__manager.html#ga8de7838090b1a30c2077c82618a608e9">More...</a><br /></td></tr>
<tr class="separator:ga8de7838090b1a30c2077c82618a608e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaea4a3fb3906fefa79138b7b5cc61cd06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a> { <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a655a3e24e52b51ff7fc9c61e3159fc9f">PM_PEER_DATA_ID_FIRST</a> = PM_PEER_DATA_ID_FIRST_VX
, <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7">PM_PEER_DATA_ID_BONDING</a> = PM_PEER_DATA_ID_BONDING_V2
, <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06aa6c9a805f9747146e0861d2098a246cc">PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING</a> = PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING_V1
, <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a27cb8c2c966a150a1f9c32c680130e34">PM_PEER_DATA_ID_GATT_LOCAL</a> = PM_PEER_DATA_ID_GATT_LOCAL_V2
, <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a757fefd5a70664382abbebf21f33ef80">PM_PEER_DATA_ID_GATT_REMOTE</a> = PM_PEER_DATA_ID_GATT_REMOTE_V2
, <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ae45494c5b327f12cc44c5fea0b1389d5">PM_PEER_DATA_ID_PEER_RANK</a> = PM_PEER_DATA_ID_PEER_RANK_V1
, <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06aa9b452e4a0ce00318a533d7fdc8761fa">PM_PEER_DATA_ID_APPLICATION</a> = PM_PEER_DATA_ID_APPLICATION_V1
, <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a1ac55b1d873bd8f6ab3db7d8e601409f">PM_PEER_DATA_ID_LAST</a> = PM_PEER_DATA_ID_LAST_VX
, <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a9d6acbe4976a664ec352bc3b636c483a">PM_PEER_DATA_ID_INVALID</a> = PM_PEER_DATA_ID_INVALID_VX
<br />
 }</td></tr>
<tr class="memdesc:gaea4a3fb3906fefa79138b7b5cc61cd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">The different types of data associated with a peer.  <a href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">More...</a><br /></td></tr>
<tr class="separator:gaea4a3fb3906fefa79138b7b5cc61cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a9645419b808367eb1e6ec3c3523928"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga2a9645419b808367eb1e6ec3c3523928">pm_conn_sec_procedure_t</a> { <a class="el" href="group__peer__manager.html#gga2a9645419b808367eb1e6ec3c3523928a9ebc61cb7f55a893b34712f153e4ec5e">PM_CONN_SEC_PROCEDURE_ENCRYPTION</a>
, <a class="el" href="group__peer__manager.html#gga2a9645419b808367eb1e6ec3c3523928a1e42f2dd921f6612b2f0b9cfefc95ee8">PM_CONN_SEC_PROCEDURE_BONDING</a>
, <a class="el" href="group__peer__manager.html#gga2a9645419b808367eb1e6ec3c3523928a3eba0a0e5c105e196869e0b8f7c40286">PM_CONN_SEC_PROCEDURE_PAIRING</a>
 }</td></tr>
<tr class="memdesc:ga2a9645419b808367eb1e6ec3c3523928"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different procedures that can lead to an encrypted link.  <a href="group__peer__manager.html#ga2a9645419b808367eb1e6ec3c3523928">More...</a><br /></td></tr>
<tr class="separator:ga2a9645419b808367eb1e6ec3c3523928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a0e37cf07eb91e1a1808995b957808b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga4a0e37cf07eb91e1a1808995b957808b">pm_evt_id_t</a> { <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba06f00dfb16c0013be0d7d44f2f6b0dff">PM_EVT_BONDED_PEER_CONNECTED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bae2a89b2bbba5a84adf4df81741e35316">PM_EVT_CONN_SEC_START</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba029dc0c5885544eb721fa5ea9b478047">PM_EVT_CONN_SEC_SUCCEEDED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba91fc8b7bc151fc0028fbc03ced08eea4">PM_EVT_CONN_SEC_FAILED</a>
, <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808baf320c093a9a132737fe1fa0bd2389e99">PM_EVT_CONN_SEC_CONFIG_REQ</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba7ebd4003aafe1f0987f8ddacbb13444a">PM_EVT_CONN_SEC_PARAMS_REQ</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba9e538deb20a3950d6c58fbd6c90a4759">PM_EVT_STORAGE_FULL</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba56b1d688f1eb67509a718e480317fec5">PM_EVT_ERROR_UNEXPECTED</a>
, <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808badfca2d9adc511c7bf5652f4741c0cead">PM_EVT_PEER_DATA_UPDATE_SUCCEEDED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba0bc454bb2f85cd7b6a05b3e4e8abeb83">PM_EVT_PEER_DATA_UPDATE_FAILED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bac60e271288362aa95be06402d9c219a2">PM_EVT_PEER_DELETE_SUCCEEDED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808baa52faff4d0a1b48a24480e9af75e97ff">PM_EVT_PEER_DELETE_FAILED</a>
, <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba01bb9681e844d97e0635298e318e69e2">PM_EVT_PEERS_DELETE_SUCCEEDED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba5c48d50f7c84fe454340c787b5006125">PM_EVT_PEERS_DELETE_FAILED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808badd3b8f9cd903b462a19a156de9cb0d97">PM_EVT_LOCAL_DB_CACHE_APPLIED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba9ceea8b032be26d02790014b31961e3f">PM_EVT_LOCAL_DB_CACHE_APPLY_FAILED</a>
, <br />
&#160;&#160;<a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba30262da2e6eb8e00f9dc1bd0ba6dfaf3">PM_EVT_SERVICE_CHANGED_IND_SENT</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bade6db0b8e2357b6ce937e72bf7e1f6eb">PM_EVT_SERVICE_CHANGED_IND_CONFIRMED</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba56cbbcf8f7f6492c7ffe3ede8a1d1e78">PM_EVT_SLAVE_SECURITY_REQ</a>
, <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba3c92e804391b7666aa77b6274b33998b">PM_EVT_FLASH_GARBAGE_COLLECTED</a>
<br />
 }</td></tr>
<tr class="memdesc:ga4a0e37cf07eb91e1a1808995b957808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of events that can come from the <a class="el" href="group__peer__manager.html">Peer Manager</a> module.  <a href="group__peer__manager.html#ga4a0e37cf07eb91e1a1808995b957808b">More...</a><br /></td></tr>
<tr class="separator:ga4a0e37cf07eb91e1a1808995b957808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaffb6cdaf370a5e805416964c6d127da"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaaffb6cdaf370a5e805416964c6d127da">pm_peer_data_op_t</a> { <a class="el" href="group__peer__manager.html#ggaaffb6cdaf370a5e805416964c6d127daa1bcb803c1651f5b2b82c7fad6ecee059">PM_PEER_DATA_OP_UPDATE</a>
, <a class="el" href="group__peer__manager.html#ggaaffb6cdaf370a5e805416964c6d127daa6e471c4022ad2551d15092fce16e2567">PM_PEER_DATA_OP_DELETE</a>
 }</td></tr>
<tr class="memdesc:gaaffb6cdaf370a5e805416964c6d127da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actions that can be performed to peer data in persistent storage.  <a href="group__peer__manager.html#gaaffb6cdaf370a5e805416964c6d127da">More...</a><br /></td></tr>
<tr class="separator:gaaffb6cdaf370a5e805416964c6d127da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8380e1f31d34cdacd511734cae8b6dde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga8380e1f31d34cdacd511734cae8b6dde">pm_init</a> (void)</td></tr>
<tr class="memdesc:ga8380e1f31d34cdacd511734cae8b6dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the Peer Manager.  <a href="group__peer__manager.html#ga8380e1f31d34cdacd511734cae8b6dde">More...</a><br /></td></tr>
<tr class="separator:ga8380e1f31d34cdacd511734cae8b6dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18de76ca580459402d43073519287b4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga18de76ca580459402d43073519287b4a">pm_register</a> (<a class="el" href="group__peer__manager.html#ga8de7838090b1a30c2077c82618a608e9">pm_evt_handler_t</a> event_handler)</td></tr>
<tr class="memdesc:ga18de76ca580459402d43073519287b4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for registering an event handler with the Peer Manager.  <a href="group__peer__manager.html#ga18de76ca580459402d43073519287b4a">More...</a><br /></td></tr>
<tr class="separator:ga18de76ca580459402d43073519287b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac27a2cc39be9fce1bd866ba4c6b18349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">pm_sec_params_set</a> (<a class="el" href="structble__gap__sec__params__t.html">ble_gap_sec_params_t</a> *p_sec_params)</td></tr>
<tr class="memdesc:gac27a2cc39be9fce1bd866ba4c6b18349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for providing pairing and bonding parameters to use for pairing procedures.  <a href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">More...</a><br /></td></tr>
<tr class="separator:gac27a2cc39be9fce1bd866ba4c6b18349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46dfaf46c0aa94fc15017d42b3a2e514"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga46dfaf46c0aa94fc15017d42b3a2e514">pm_conn_secure</a> (uint16_t conn_handle, bool force_repairing)</td></tr>
<tr class="memdesc:ga46dfaf46c0aa94fc15017d42b3a2e514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for establishing encryption on a connection, and optionally establishing a bond.  <a href="group__peer__manager.html#ga46dfaf46c0aa94fc15017d42b3a2e514">More...</a><br /></td></tr>
<tr class="separator:ga46dfaf46c0aa94fc15017d42b3a2e514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcb0dc53ebee5a8561774909df7b4d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gadcb0dc53ebee5a8561774909df7b4d13">pm_conn_sec_config_reply</a> (uint16_t conn_handle, <a class="el" href="structpm__conn__sec__config__t.html">pm_conn_sec_config_t</a> *p_conn_sec_config)</td></tr>
<tr class="memdesc:gadcb0dc53ebee5a8561774909df7b4d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for providing security configuration for a link.  <a href="group__peer__manager.html#gadcb0dc53ebee5a8561774909df7b4d13">More...</a><br /></td></tr>
<tr class="separator:gadcb0dc53ebee5a8561774909df7b4d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81e56cb4bade3444d360211e136a55f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga81e56cb4bade3444d360211e136a55f1">pm_conn_sec_params_reply</a> (uint16_t conn_handle, <a class="el" href="structble__gap__sec__params__t.html">ble_gap_sec_params_t</a> *p_sec_params, void const *p_context)</td></tr>
<tr class="memdesc:ga81e56cb4bade3444d360211e136a55f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for providing security parameters for a link.  <a href="group__peer__manager.html#ga81e56cb4bade3444d360211e136a55f1">More...</a><br /></td></tr>
<tr class="separator:ga81e56cb4bade3444d360211e136a55f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaecb7f99f58d71f085f62f5cc5267508"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaaecb7f99f58d71f085f62f5cc5267508">pm_local_database_has_changed</a> (void)</td></tr>
<tr class="memdesc:gaaecb7f99f58d71f085f62f5cc5267508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for manually informing that the local database has changed.  <a href="group__peer__manager.html#gaaecb7f99f58d71f085f62f5cc5267508">More...</a><br /></td></tr>
<tr class="separator:gaaecb7f99f58d71f085f62f5cc5267508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a2760d50178059a4156f00bb6c0eb56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga5a2760d50178059a4156f00bb6c0eb56">pm_conn_sec_status_get</a> (uint16_t conn_handle, <a class="el" href="structpm__conn__sec__status__t.html">pm_conn_sec_status_t</a> *p_conn_sec_status)</td></tr>
<tr class="memdesc:ga5a2760d50178059a4156f00bb6c0eb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the security status of a connection.  <a href="group__peer__manager.html#ga5a2760d50178059a4156f00bb6c0eb56">More...</a><br /></td></tr>
<tr class="separator:ga5a2760d50178059a4156f00bb6c0eb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab69b5939738b54f1df6b2209a19397da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gab69b5939738b54f1df6b2209a19397da">pm_lesc_public_key_set</a> (<a class="el" href="structble__gap__lesc__p256__pk__t.html">ble_gap_lesc_p256_pk_t</a> *p_public_key)</td></tr>
<tr class="memdesc:gab69b5939738b54f1df6b2209a19397da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental function for specifying the public key to use for LESC operations.  <a href="group__peer__manager.html#gab69b5939738b54f1df6b2209a19397da">More...</a><br /></td></tr>
<tr class="separator:gab69b5939738b54f1df6b2209a19397da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56e6bbda42ceae2d56520786e4d9730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga56e6bbda42ceae2d56520786e4d9730d">pm_whitelist_set</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> const *p_peers, uint32_t peer_cnt)</td></tr>
<tr class="memdesc:ga56e6bbda42ceae2d56520786e4d9730d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting or clearing the whitelist.  <a href="group__peer__manager.html#ga56e6bbda42ceae2d56520786e4d9730d">More...</a><br /></td></tr>
<tr class="separator:ga56e6bbda42ceae2d56520786e4d9730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa49e1efd56574674353e1d4f1c4a026a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaa49e1efd56574674353e1d4f1c4a026a">pm_whitelist_get</a> (<a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> *p_addrs, uint32_t *p_addr_cnt, <a class="el" href="structble__gap__irk__t.html">ble_gap_irk_t</a> *p_irks, uint32_t *p_irk_cnt)</td></tr>
<tr class="memdesc:gaa49e1efd56574674353e1d4f1c4a026a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the previously set whitelist.  <a href="group__peer__manager.html#gaa49e1efd56574674353e1d4f1c4a026a">More...</a><br /></td></tr>
<tr class="separator:gaa49e1efd56574674353e1d4f1c4a026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01c4803ee9857ee105eba76db8fec8dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga01c4803ee9857ee105eba76db8fec8dd">pm_device_identities_list_set</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> const *p_peers, uint32_t peer_cnt)</td></tr>
<tr class="memdesc:ga01c4803ee9857ee105eba76db8fec8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting and clearing the device identities list.  <a href="group__peer__manager.html#ga01c4803ee9857ee105eba76db8fec8dd">More...</a><br /></td></tr>
<tr class="separator:ga01c4803ee9857ee105eba76db8fec8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga780f7978bfd31ded77908e2b33e8d05e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga780f7978bfd31ded77908e2b33e8d05e">pm_id_addr_set</a> (<a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> const *p_addr)</td></tr>
<tr class="memdesc:ga780f7978bfd31ded77908e2b33e8d05e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting the local <em>Bluetooth</em> identity address.  <a href="group__peer__manager.html#ga780f7978bfd31ded77908e2b33e8d05e">More...</a><br /></td></tr>
<tr class="separator:ga780f7978bfd31ded77908e2b33e8d05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97374b3a6c4a1618a82760218ecdb157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga97374b3a6c4a1618a82760218ecdb157">pm_id_addr_get</a> (<a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> *p_addr)</td></tr>
<tr class="memdesc:ga97374b3a6c4a1618a82760218ecdb157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the local <em>Bluetooth</em> identity address.  <a href="group__peer__manager.html#ga97374b3a6c4a1618a82760218ecdb157">More...</a><br /></td></tr>
<tr class="separator:ga97374b3a6c4a1618a82760218ecdb157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga097a70106c2c2cdd1d34f710e6a9258c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga097a70106c2c2cdd1d34f710e6a9258c">pm_privacy_set</a> (<a class="el" href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">pm_privacy_params_t</a> const *p_privacy_params)</td></tr>
<tr class="memdesc:ga097a70106c2c2cdd1d34f710e6a9258c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for configuring privacy settings.  <a href="group__peer__manager.html#ga097a70106c2c2cdd1d34f710e6a9258c">More...</a><br /></td></tr>
<tr class="separator:ga097a70106c2c2cdd1d34f710e6a9258c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad36f14ee236eb8cf038a31b07034dab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gad36f14ee236eb8cf038a31b07034dab3">pm_privacy_get</a> (<a class="el" href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">pm_privacy_params_t</a> *p_privacy_params)</td></tr>
<tr class="memdesc:gad36f14ee236eb8cf038a31b07034dab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving privacy settings.  <a href="group__peer__manager.html#gad36f14ee236eb8cf038a31b07034dab3">More...</a><br /></td></tr>
<tr class="separator:gad36f14ee236eb8cf038a31b07034dab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5795d90d84ec2d3bb907f06f410fb71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaf5795d90d84ec2d3bb907f06f410fb71">pm_address_resolve</a> (<a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> const *p_addr, <a class="el" href="structble__gap__irk__t.html">ble_gap_irk_t</a> const *p_irk)</td></tr>
<tr class="memdesc:gaf5795d90d84ec2d3bb907f06f410fb71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for resolving a resolvable address with an identity resolution key (IRK).  <a href="group__peer__manager.html#gaf5795d90d84ec2d3bb907f06f410fb71">More...</a><br /></td></tr>
<tr class="separator:gaf5795d90d84ec2d3bb907f06f410fb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f83f99848f22494ee5c231aa5324f61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga5f83f99848f22494ee5c231aa5324f61">pm_conn_handle_get</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, uint16_t *p_conn_handle)</td></tr>
<tr class="memdesc:ga5f83f99848f22494ee5c231aa5324f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the connection handle of the connection with a bonded peer.  <a href="group__peer__manager.html#ga5f83f99848f22494ee5c231aa5324f61">More...</a><br /></td></tr>
<tr class="separator:ga5f83f99848f22494ee5c231aa5324f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga753b87346d599de963c65adb4d8c1b5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga753b87346d599de963c65adb4d8c1b5c">pm_peer_id_get</a> (uint16_t conn_handle, <a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *p_peer_id)</td></tr>
<tr class="memdesc:ga753b87346d599de963c65adb4d8c1b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving the ID of a peer, given its connection handle.  <a href="group__peer__manager.html#ga753b87346d599de963c65adb4d8c1b5c">More...</a><br /></td></tr>
<tr class="separator:ga753b87346d599de963c65adb4d8c1b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6840dd6bb6ece5da0d30ef2c873ef9a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga6840dd6bb6ece5da0d30ef2c873ef9a1">pm_next_peer_id_get</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> prev_peer_id)</td></tr>
<tr class="memdesc:ga6840dd6bb6ece5da0d30ef2c873ef9a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the next peer ID in the sequence of all used peer IDs.  <a href="group__peer__manager.html#ga6840dd6bb6ece5da0d30ef2c873ef9a1">More...</a><br /></td></tr>
<tr class="separator:ga6840dd6bb6ece5da0d30ef2c873ef9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a567e24c36e7c496d4c8975994b10e1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga4a567e24c36e7c496d4c8975994b10e1">pm_peer_count</a> (void)</td></tr>
<tr class="memdesc:ga4a567e24c36e7c496d4c8975994b10e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for querying the number of valid peer IDs that are available.  <a href="group__peer__manager.html#ga4a567e24c36e7c496d4c8975994b10e1">More...</a><br /></td></tr>
<tr class="separator:ga4a567e24c36e7c496d4c8975994b10e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Functions (Peer Data)</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp918fa30157aa9ca5413b65454a0ba301"></a><a class="anchor" id="PM_PEER_DATA_FUNCTIONS"></a> Functions for manipulating peer data. </p>
</td></tr>
<tr class="memitem:ga84eebadf6d2f5531eb8d1e1157123b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga84eebadf6d2f5531eb8d1e1157123b5d">pm_peer_data_load</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a> data_id, void *p_data, uint16_t *p_len)</td></tr>
<tr class="memdesc:ga84eebadf6d2f5531eb8d1e1157123b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving stored data of a peer.  <a href="group__peer__manager.html#ga84eebadf6d2f5531eb8d1e1157123b5d">More...</a><br /></td></tr>
<tr class="separator:ga84eebadf6d2f5531eb8d1e1157123b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf148a0bb89fadfaae7f93bbda4e93ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gabf148a0bb89fadfaae7f93bbda4e93ef">pm_peer_data_bonding_load</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a> *p_data)</td></tr>
<tr class="memdesc:gabf148a0bb89fadfaae7f93bbda4e93ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading a peer's bonding data (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7">PM_PEER_DATA_ID_BONDING</a>).  <a href="group__peer__manager.html#gabf148a0bb89fadfaae7f93bbda4e93ef">More...</a><br /></td></tr>
<tr class="separator:gabf148a0bb89fadfaae7f93bbda4e93ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857d0229ac9ab4d2d77341ec4bc3e4c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga857d0229ac9ab4d2d77341ec4bc3e4c2">pm_peer_data_remote_db_load</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="structble__gatt__db__srv__t.html">ble_gatt_db_srv_t</a> *p_data, uint16_t *p_len)</td></tr>
<tr class="memdesc:ga857d0229ac9ab4d2d77341ec4bc3e4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading a peer's remote DB values. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a757fefd5a70664382abbebf21f33ef80">PM_PEER_DATA_ID_GATT_REMOTE</a>).  <a href="group__peer__manager.html#ga857d0229ac9ab4d2d77341ec4bc3e4c2">More...</a><br /></td></tr>
<tr class="separator:ga857d0229ac9ab4d2d77341ec4bc3e4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3baa6c3b0a1ac2f3983f3704d6c2406c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga3baa6c3b0a1ac2f3983f3704d6c2406c">pm_peer_data_app_data_load</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, void *p_data, uint16_t *p_len)</td></tr>
<tr class="memdesc:ga3baa6c3b0a1ac2f3983f3704d6c2406c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading a peer's application data. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06aa9b452e4a0ce00318a533d7fdc8761fa">PM_PEER_DATA_ID_APPLICATION</a>).  <a href="group__peer__manager.html#ga3baa6c3b0a1ac2f3983f3704d6c2406c">More...</a><br /></td></tr>
<tr class="separator:ga3baa6c3b0a1ac2f3983f3704d6c2406c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga686445a2134e8b1222f9318caf78b4ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga686445a2134e8b1222f9318caf78b4ab">pm_peer_data_store</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a> data_id, void const *p_data, uint16_t len, <a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga686445a2134e8b1222f9318caf78b4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting or updating stored data of a peer.  <a href="group__peer__manager.html#ga686445a2134e8b1222f9318caf78b4ab">More...</a><br /></td></tr>
<tr class="separator:ga686445a2134e8b1222f9318caf78b4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga967910e510aa10b371a234cf0a2d2e5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga967910e510aa10b371a234cf0a2d2e5a">pm_peer_data_bonding_store</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a> const *p_data, <a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga967910e510aa10b371a234cf0a2d2e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting or updating a peer's bonding data (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7">PM_PEER_DATA_ID_BONDING</a>).  <a href="group__peer__manager.html#ga967910e510aa10b371a234cf0a2d2e5a">More...</a><br /></td></tr>
<tr class="separator:ga967910e510aa10b371a234cf0a2d2e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa43da60a5452c269fe2723b58cdd6b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaa43da60a5452c269fe2723b58cdd6b3a">pm_peer_data_remote_db_store</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="structble__gatt__db__srv__t.html">ble_gatt_db_srv_t</a> const *p_data, uint16_t len, <a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *p_token)</td></tr>
<tr class="memdesc:gaa43da60a5452c269fe2723b58cdd6b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting or updating a peer's remote DB values. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a757fefd5a70664382abbebf21f33ef80">PM_PEER_DATA_ID_GATT_REMOTE</a>).  <a href="group__peer__manager.html#gaa43da60a5452c269fe2723b58cdd6b3a">More...</a><br /></td></tr>
<tr class="separator:gaa43da60a5452c269fe2723b58cdd6b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12897bd899eaaff0ca43560ac00662cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga12897bd899eaaff0ca43560ac00662cf">pm_peer_data_app_data_store</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, void const *p_data, uint16_t len, <a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga12897bd899eaaff0ca43560ac00662cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting or updating a peer's application data. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06aa9b452e4a0ce00318a533d7fdc8761fa">PM_PEER_DATA_ID_APPLICATION</a>).  <a href="group__peer__manager.html#ga12897bd899eaaff0ca43560ac00662cf">More...</a><br /></td></tr>
<tr class="separator:ga12897bd899eaaff0ca43560ac00662cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7292e5ea2f00b2384b01460aba0e7a8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga7292e5ea2f00b2384b01460aba0e7a8f">pm_peer_data_delete</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id, <a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a> data_id)</td></tr>
<tr class="memdesc:ga7292e5ea2f00b2384b01460aba0e7a8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for deleting a peer's stored pieces of data.  <a href="group__peer__manager.html#ga7292e5ea2f00b2384b01460aba0e7a8f">More...</a><br /></td></tr>
<tr class="separator:ga7292e5ea2f00b2384b01460aba0e7a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcba9818cc93048b269c766df95b0ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#ga0fcba9818cc93048b269c766df95b0ff">pm_peer_new</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *p_new_peer_id, <a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a> *p_bonding_data, <a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga0fcba9818cc93048b269c766df95b0ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for manually adding a peer to the persistent storage.  <a href="group__peer__manager.html#ga0fcba9818cc93048b269c766df95b0ff">More...</a><br /></td></tr>
<tr class="separator:ga0fcba9818cc93048b269c766df95b0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20bb7430862e537e4219cf9fd8c5f98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gad20bb7430862e537e4219cf9fd8c5f98">pm_peer_delete</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id)</td></tr>
<tr class="memdesc:gad20bb7430862e537e4219cf9fd8c5f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for freeing persistent storage for a peer.  <a href="group__peer__manager.html#gad20bb7430862e537e4219cf9fd8c5f98">More...</a><br /></td></tr>
<tr class="separator:gad20bb7430862e537e4219cf9fd8c5f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa99779ab5b8b4cfde65974bdf75a1e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gaa99779ab5b8b4cfde65974bdf75a1e7c">pm_peers_delete</a> (void)</td></tr>
<tr class="memdesc:gaa99779ab5b8b4cfde65974bdf75a1e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for deleting all data stored for all peers.  <a href="group__peer__manager.html#gaa99779ab5b8b4cfde65974bdf75a1e7c">More...</a><br /></td></tr>
<tr class="separator:gaa99779ab5b8b4cfde65974bdf75a1e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5d71e8a81c55d6df58b8025b49da1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gacc5d71e8a81c55d6df58b8025b49da1c">pm_peer_ranks_get</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *p_highest_ranked_peer, uint32_t *p_highest_rank, <a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *p_lowest_ranked_peer, uint32_t *p_lowest_rank)</td></tr>
<tr class="memdesc:gacc5d71e8a81c55d6df58b8025b49da1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding the highest and lowest ranked peers.  <a href="group__peer__manager.html#gacc5d71e8a81c55d6df58b8025b49da1c">More...</a><br /></td></tr>
<tr class="separator:gacc5d71e8a81c55d6df58b8025b49da1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc58adc899853649726001da3350b56c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__peer__manager.html#gabc58adc899853649726001da3350b56c">pm_peer_rank_highest</a> (<a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> peer_id)</td></tr>
<tr class="memdesc:gabc58adc899853649726001da3350b56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating the rank of a peer to be highest among all stored peers.  <a href="group__peer__manager.html#gabc58adc899853649726001da3350b56c">More...</a><br /></td></tr>
<tr class="separator:gabc58adc899853649726001da3350b56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Module for managing BLE bonding, which includes controlling encryption and pairing procedures as well as persistently storing different pieces of data that must be stored when bonded. </p>
<p>The API consists of functions for configuring the pairing and encryption behavior of the device and functions for manipulating the stored data.</p>
<p>This module uses Flash Data Storage (FDS) to interface with persistent storage. The Peer Manager needs exclusive use of certain FDS file IDs and record keys. See lib_fds_functionality_keys for more information. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga1c89b6d900d78158b76b4f57bed47a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c89b6d900d78158b76b4f57bed47a25">&#9670;&nbsp;</a></span>PM_CONN_SEC_ERROR_BASE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_CONN_SEC_ERROR_BASE&#160;&#160;&#160;0x1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base for Peer Manager defined errors. See <a class="el" href="group___p_m___s_e_c___e_r_r_o_r_s.html">Peer Manager defined security errors</a> and <a class="el" href="group__peer__manager.html#gaa15b5088baabcad882f2f6484dc4d70e">pm_sec_error_code_t</a>. </p>

</div>
</div>
<a id="ga99076c351109c551432b53af13466ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99076c351109c551432b53af13466ec9">&#9670;&nbsp;</a></span>PM_LOCAL_DB_LEN_OVERHEAD_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_LOCAL_DB_LEN_OVERHEAD_BYTES&#160;&#160;&#160;offsetof(<a class="el" href="structpm__peer__data__local__gatt__db__t.html">pm_peer_data_local_gatt_db_t</a>, data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The static-length part of the local GATT data struct. </p>

</div>
</div>
<a id="ga8a57c33c829ad19bc6a2cd655b40dc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a57c33c829ad19bc6a2cd655b40dc9b">&#9670;&nbsp;</a></span>PM_PEER_ID_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_PEER_ID_INVALID&#160;&#160;&#160;0xFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid value for <a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>. </p>

</div>
</div>
<a id="gabbbdb8df64d46e64e6817782f9568eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabbbdb8df64d46e64e6817782f9568eaa">&#9670;&nbsp;</a></span>PM_PEER_ID_N_AVAILABLE_IDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_PEER_ID_N_AVAILABLE_IDS&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of available peer IDs. </p>

</div>
</div>
<a id="gadb8282ab380eb5e409449155b3c18f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb8282ab380eb5e409449155b3c18f26">&#9670;&nbsp;</a></span>PM_STORE_TOKEN_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_STORE_TOKEN_INVALID&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid value for store token. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8de7838090b1a30c2077c82618a608e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8de7838090b1a30c2077c82618a608e9">&#9670;&nbsp;</a></span>pm_evt_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pm_evt_handler_t) (<a class="el" href="structpm__evt__t.html">pm_evt_t</a> const *p_event)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event handler for events from the <a class="el" href="group__peer__manager.html">Peer Manager</a> module. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__peer__manager.html#ga18de76ca580459402d43073519287b4a" title="Function for registering an event handler with the Peer Manager.">pm_register</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_event</td><td>The event that has occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aa174d9642816af3ba36db985465f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa174d9642816af3ba36db985465f46">&#9670;&nbsp;</a></span>pm_peer_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to uniquely identify a peer for which we have persistently stored data. </p>

</div>
</div>
<a id="ga5f3a50ca5645386b3f6cd7ebbee84264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f3a50ca5645386b3f6cd7ebbee84264">&#9670;&nbsp;</a></span>pm_prepare_token_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__peer__manager.html#ga5f3a50ca5645386b3f6cd7ebbee84264">pm_prepare_token_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that is used for write prepares (used to reserve space in flash). </p>

</div>
</div>
<a id="ga5d267fa432149f37e231c8f11ad8a395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d267fa432149f37e231c8f11ad8a395">&#9670;&nbsp;</a></span>pm_privacy_params_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structble__gap__privacy__params__t.html">ble_gap_privacy_params_t</a> <a class="el" href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">pm_privacy_params_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Device Privacy. </p>
<pre class="fragment">   The privacy feature provides a way for the device to avoid being tracked over a period of
   time. The privacy feature, when enabled, hides the local device identity and replaces it
   with a private address that is automatically refreshed at a specified interval.

   If a device still wants to be recognized by other peers, it needs to share it's Identity
   Resolving Key (IRK). With this key, a device can generate a random private address that
   can only be recognized by peers in possession of that key, and devices can establish
   connections without revealing their real identities.
</pre> <dl class="section note"><dt>Note</dt><dd>If the device IRK is updated, the new IRK becomes the one to be distributed in all bonding procedures performed after sd_ble_gap_privacy_set returns. The IRK distributed during bonding procedure is the device IRK that is active when sd_ble_gap_sec_params_reply is called. </dd></dl>

</div>
</div>
<a id="gaa15b5088baabcad882f2f6484dc4d70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa15b5088baabcad882f2f6484dc4d70e">&#9670;&nbsp;</a></span>pm_sec_error_code_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint16_t <a class="el" href="group__peer__manager.html#gaa15b5088baabcad882f2f6484dc4d70e">pm_sec_error_code_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Errors from security procedures in Peer Manager. </p>
<p>Possible values are defined in <a class="el" href="group___p_m___s_e_c___e_r_r_o_r_s.html">Peer Manager defined security errors</a> and <a class="el" href="group___b_l_e___g_a_p___s_e_c___s_t_a_t_u_s.html">GAP Security status</a>. </p>

</div>
</div>
<a id="ga090324ad9f53add6b9a1e971f953f452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga090324ad9f53add6b9a1e971f953f452">&#9670;&nbsp;</a></span>pm_store_token_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type that is used to hold a reference to a stored item in flash. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga2a9645419b808367eb1e6ec3c3523928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a9645419b808367eb1e6ec3c3523928">&#9670;&nbsp;</a></span>pm_conn_sec_procedure_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__peer__manager.html#ga2a9645419b808367eb1e6ec3c3523928">pm_conn_sec_procedure_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different procedures that can lead to an encrypted link. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga2a9645419b808367eb1e6ec3c3523928a9ebc61cb7f55a893b34712f153e4ec5e"></a>PM_CONN_SEC_PROCEDURE_ENCRYPTION&#160;</td><td class="fielddoc"><p>Using an LTK that was shared during a previous bonding procedure to encrypt the link. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2a9645419b808367eb1e6ec3c3523928a1e42f2dd921f6612b2f0b9cfefc95ee8"></a>PM_CONN_SEC_PROCEDURE_BONDING&#160;</td><td class="fielddoc"><p>A pairing procedure, followed by a bonding procedure. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga2a9645419b808367eb1e6ec3c3523928a3eba0a0e5c105e196869e0b8f7c40286"></a>PM_CONN_SEC_PROCEDURE_PAIRING&#160;</td><td class="fielddoc"><p>A pairing procedure with no bonding. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4a0e37cf07eb91e1a1808995b957808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a0e37cf07eb91e1a1808995b957808b">&#9670;&nbsp;</a></span>pm_evt_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__peer__manager.html#ga4a0e37cf07eb91e1a1808995b957808b">pm_evt_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Types of events that can come from the <a class="el" href="group__peer__manager.html">Peer Manager</a> module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba06f00dfb16c0013be0d7d44f2f6b0dff"></a>PM_EVT_BONDED_PEER_CONNECTED&#160;</td><td class="fielddoc"><p>A connected peer has been identified as one with which we have a bond. When performing bonding with a peer for the first time, this event will not be sent until a new connection is established with the peer. When we are central, this event is always sent when the Peer Manager receives the <a class="el" href="group___b_l_e___g_a_p___e_n_u_m_e_r_a_t_i_o_n_s.html#ggada486dd3c0cce897b23a887bed284fefaa0b4789724d202a13a5e7eab85c52957">BLE_GAP_EVT_CONNECTED</a> event. When we are peripheral, this event might in rare cases arrive later. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808bae2a89b2bbba5a84adf4df81741e35316"></a>PM_EVT_CONN_SEC_START&#160;</td><td class="fielddoc"><p>A security procedure has started on a link, initiated either locally or remotely. The security procedure is using the last parameters provided via <a class="el" href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">pm_sec_params_set</a>. This event is always followed by either a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba029dc0c5885544eb721fa5ea9b478047">PM_EVT_CONN_SEC_SUCCEEDED</a> or a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba91fc8b7bc151fc0028fbc03ced08eea4">PM_EVT_CONN_SEC_FAILED</a> event. This is an informational event; no action is needed for the procedure to proceed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba029dc0c5885544eb721fa5ea9b478047"></a>PM_EVT_CONN_SEC_SUCCEEDED&#160;</td><td class="fielddoc"><p>A link has been encrypted, either as a result of a call to <a class="el" href="group__peer__manager.html#ga46dfaf46c0aa94fc15017d42b3a2e514">pm_conn_secure</a> or a result of an action by the peer. The event structure contains more information about the circumstances. This event might contain a peer ID with the value <a class="el" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a>, which means that the peer (central) used an address that could not be identified, but it used an encryption key (LTK) that is present in the database. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba91fc8b7bc151fc0028fbc03ced08eea4"></a>PM_EVT_CONN_SEC_FAILED&#160;</td><td class="fielddoc"><p>A pairing or encryption procedure has failed. In some cases, this means that security is not possible on this link (temporarily or permanently). How to handle this error depends on the application. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808baf320c093a9a132737fe1fa0bd2389e99"></a>PM_EVT_CONN_SEC_CONFIG_REQ&#160;</td><td class="fielddoc"><p>The peer (central) has requested pairing, but a bond already exists with that peer. Reply by calling <a class="el" href="group__peer__manager.html#gadcb0dc53ebee5a8561774909df7b4d13">pm_conn_sec_config_reply</a> before the event handler returns. If no reply is sent, a default is used. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba7ebd4003aafe1f0987f8ddacbb13444a"></a>PM_EVT_CONN_SEC_PARAMS_REQ&#160;</td><td class="fielddoc"><p>Security parameters (<a class="el" href="structble__gap__sec__params__t.html">ble_gap_sec_params_t</a>) are needed for an ongoing security procedure. Reply with <a class="el" href="group__peer__manager.html#ga81e56cb4bade3444d360211e136a55f1">pm_conn_sec_params_reply</a> before the event handler returns. If no reply is sent, the parameters given in <a class="el" href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">pm_sec_params_set</a> are used. If a peripheral connection, the central's sec_params will be available in the event. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba9e538deb20a3950d6c58fbd6c90a4759"></a>PM_EVT_STORAGE_FULL&#160;</td><td class="fielddoc"><p>There is no more room for peer data in flash storage. To solve this problem, delete data that is not needed anymore and run a garbage collection procedure in FDS. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba56b1d688f1eb67509a718e480317fec5"></a>PM_EVT_ERROR_UNEXPECTED&#160;</td><td class="fielddoc"><p>An unrecoverable error happened inside Peer Manager. An operation failed with the provided error. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808badfca2d9adc511c7bf5652f4741c0cead"></a>PM_EVT_PEER_DATA_UPDATE_SUCCEEDED&#160;</td><td class="fielddoc"><p>A piece of peer data was stored, updated, or cleared in flash storage. This event is sent for all successful changes to peer data, also those initiated internally in Peer Manager. To identify an operation, compare the store token in the event with the store token received during the initiating function call. Events from internally initiated changes might have invalid store tokens. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba0bc454bb2f85cd7b6a05b3e4e8abeb83"></a>PM_EVT_PEER_DATA_UPDATE_FAILED&#160;</td><td class="fielddoc"><p>A piece of peer data could not be stored, updated, or cleared in flash storage. This event is sent instead of <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808badfca2d9adc511c7bf5652f4741c0cead">PM_EVT_PEER_DATA_UPDATE_SUCCEEDED</a> for the failed operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808bac60e271288362aa95be06402d9c219a2"></a>PM_EVT_PEER_DELETE_SUCCEEDED&#160;</td><td class="fielddoc"><p>A peer was cleared from flash storage, for example because a call to <a class="el" href="group__peer__manager.html#gad20bb7430862e537e4219cf9fd8c5f98">pm_peer_delete</a> succeeded. This event can also be sent as part of a call to <a class="el" href="group__peer__manager.html#gaa99779ab5b8b4cfde65974bdf75a1e7c">pm_peers_delete</a> or internal cleanup. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808baa52faff4d0a1b48a24480e9af75e97ff"></a>PM_EVT_PEER_DELETE_FAILED&#160;</td><td class="fielddoc"><p>A peer could not be cleared from flash storage. This event is sent instead of <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bac60e271288362aa95be06402d9c219a2">PM_EVT_PEER_DELETE_SUCCEEDED</a> for the failed operation. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba01bb9681e844d97e0635298e318e69e2"></a>PM_EVT_PEERS_DELETE_SUCCEEDED&#160;</td><td class="fielddoc"><p>A call to <a class="el" href="group__peer__manager.html#gaa99779ab5b8b4cfde65974bdf75a1e7c">pm_peers_delete</a> has completed successfully. Flash storage now contains no peer data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba5c48d50f7c84fe454340c787b5006125"></a>PM_EVT_PEERS_DELETE_FAILED&#160;</td><td class="fielddoc"><p>A call to <a class="el" href="group__peer__manager.html#gaa99779ab5b8b4cfde65974bdf75a1e7c">pm_peers_delete</a> has failed, which means that at least one of the peers could not be deleted. Other peers might have been deleted, or might still be queued to be deleted. No more <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba01bb9681e844d97e0635298e318e69e2">PM_EVT_PEERS_DELETE_SUCCEEDED</a> or <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba5c48d50f7c84fe454340c787b5006125">PM_EVT_PEERS_DELETE_FAILED</a> events are sent until the next time <a class="el" href="group__peer__manager.html#gaa99779ab5b8b4cfde65974bdf75a1e7c">pm_peers_delete</a> is called. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808badd3b8f9cd903b462a19a156de9cb0d97"></a>PM_EVT_LOCAL_DB_CACHE_APPLIED&#160;</td><td class="fielddoc"><p>Local database values for a peer (taken from flash storage) have been provided to the SoftDevice. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba9ceea8b032be26d02790014b31961e3f"></a>PM_EVT_LOCAL_DB_CACHE_APPLY_FAILED&#160;</td><td class="fielddoc"><p>Local database values for a peer (taken from flash storage) were rejected by the SoftDevice, which means that either the database has changed or the user has manually set the local database to an invalid value (using <a class="el" href="group__peer__manager.html#ga686445a2134e8b1222f9318caf78b4ab">pm_peer_data_store</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba30262da2e6eb8e00f9dc1bd0ba6dfaf3"></a>PM_EVT_SERVICE_CHANGED_IND_SENT&#160;</td><td class="fielddoc"><p>A service changed indication has been sent to a peer, as a result of a call to <a class="el" href="group__peer__manager.html#gaaecb7f99f58d71f085f62f5cc5267508">pm_local_database_has_changed</a>. This event will be followed by a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bade6db0b8e2357b6ce937e72bf7e1f6eb">PM_EVT_SERVICE_CHANGED_IND_CONFIRMED</a> event if the peer acknowledges the indication. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808bade6db0b8e2357b6ce937e72bf7e1f6eb"></a>PM_EVT_SERVICE_CHANGED_IND_CONFIRMED&#160;</td><td class="fielddoc"><p>A service changed indication that was sent has been confirmed by a peer. The peer can now be considered aware that the local database has changed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba56cbbcf8f7f6492c7ffe3ede8a1d1e78"></a>PM_EVT_SLAVE_SECURITY_REQ&#160;</td><td class="fielddoc"><p>The peer (peripheral) has requested link encryption, which has been enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4a0e37cf07eb91e1a1808995b957808ba3c92e804391b7666aa77b6274b33998b"></a>PM_EVT_FLASH_GARBAGE_COLLECTED&#160;</td><td class="fielddoc"><p>The flash has been garbage collected (By FDS), possibly freeing up space. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaea4a3fb3906fefa79138b7b5cc61cd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea4a3fb3906fefa79138b7b5cc61cd06">&#9670;&nbsp;</a></span>pm_peer_data_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The different types of data associated with a peer. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06a655a3e24e52b51ff7fc9c61e3159fc9f"></a>PM_PEER_DATA_ID_FIRST&#160;</td><td class="fielddoc"><p>The smallest data ID. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7"></a>PM_PEER_DATA_ID_BONDING&#160;</td><td class="fielddoc"><p>The data ID for bonding data. Type: <a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06aa6c9a805f9747146e0861d2098a246cc"></a>PM_PEER_DATA_ID_SERVICE_CHANGED_PENDING&#160;</td><td class="fielddoc"><p>The data ID for service changed state. Type: bool. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06a27cb8c2c966a150a1f9c32c680130e34"></a>PM_PEER_DATA_ID_GATT_LOCAL&#160;</td><td class="fielddoc"><p>The data ID for local GATT data (sys attributes). Type: <a class="el" href="structpm__peer__data__local__gatt__db__t.html">pm_peer_data_local_gatt_db_t</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06a757fefd5a70664382abbebf21f33ef80"></a>PM_PEER_DATA_ID_GATT_REMOTE&#160;</td><td class="fielddoc"><p>The data ID for remote GATT data. Type: uint8_t array. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06ae45494c5b327f12cc44c5fea0b1389d5"></a>PM_PEER_DATA_ID_PEER_RANK&#160;</td><td class="fielddoc"><p>The data ID for peer rank. See <a class="el" href="group__peer__manager.html#gabc58adc899853649726001da3350b56c">pm_peer_rank_highest</a>. Type: uint32_t. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06aa9b452e4a0ce00318a533d7fdc8761fa"></a>PM_PEER_DATA_ID_APPLICATION&#160;</td><td class="fielddoc"><p>The data ID for application data. Type: uint8_t array. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06a1ac55b1d873bd8f6ab3db7d8e601409f"></a>PM_PEER_DATA_ID_LAST&#160;</td><td class="fielddoc"><p>One more than the highest data ID. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaea4a3fb3906fefa79138b7b5cc61cd06a9d6acbe4976a664ec352bc3b636c483a"></a>PM_PEER_DATA_ID_INVALID&#160;</td><td class="fielddoc"><p>A data ID guaranteed to be invalid. </p>
</td></tr>
</table>

</div>
</div>
<a id="gaaffb6cdaf370a5e805416964c6d127da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaffb6cdaf370a5e805416964c6d127da">&#9670;&nbsp;</a></span>pm_peer_data_op_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__peer__manager.html#gaaffb6cdaf370a5e805416964c6d127da">pm_peer_data_op_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actions that can be performed to peer data in persistent storage. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaffb6cdaf370a5e805416964c6d127daa1bcb803c1651f5b2b82c7fad6ecee059"></a>PM_PEER_DATA_OP_UPDATE&#160;</td><td class="fielddoc"><p>Writing or overwriting the data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaffb6cdaf370a5e805416964c6d127daa6e471c4022ad2551d15092fce16e2567"></a>PM_PEER_DATA_OP_DELETE&#160;</td><td class="fielddoc"><p>Removing the data. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf5795d90d84ec2d3bb907f06f410fb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5795d90d84ec2d3bb907f06f410fb71">&#9670;&nbsp;</a></span>pm_address_resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pm_address_resolve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> const *&#160;</td>
          <td class="paramname"><em>p_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structble__gap__irk__t.html">ble_gap_irk_t</a> const *&#160;</td>
          <td class="paramname"><em>p_irk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for resolving a resolvable address with an identity resolution key (IRK). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_addr</td><td>A private random resolvable address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_irk</td><td>An identity resolution key (IRK).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>The IRK used matched the one used to create the address. </td></tr>
    <tr><td class="paramname">false</td><td>The IRK used did not match the one used to create the address, or an argument was NULL or invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5f83f99848f22494ee5c231aa5324f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f83f99848f22494ee5c231aa5324f61">&#9670;&nbsp;</a></span>pm_conn_handle_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_conn_handle_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_conn_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the connection handle of the connection with a bonded peer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_id</td><td>The peer ID of the bonded peer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_conn_handle</td><td>Connection handle, or <a class="el" href="group__ble__err.html#gabdc27cbc2ffac4a50640a0ce992c03af">BLE_ERROR_INVALID_CONN_HANDLE</a> if the peer is not connected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the connection handle was retrieved successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_conn_handle</code> was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcb0dc53ebee5a8561774909df7b4d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcb0dc53ebee5a8561774909df7b4d13">&#9670;&nbsp;</a></span>pm_conn_sec_config_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_conn_sec_config_reply </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>conn_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpm__conn__sec__config__t.html">pm_conn_sec_config_t</a> *&#160;</td>
          <td class="paramname"><em>p_conn_sec_config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for providing security configuration for a link. </p>
<p>This function is optional, and must be called in reply to a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808baf320c093a9a132737fe1fa0bd2389e99">PM_EVT_CONN_SEC_CONFIG_REQ</a> event, before the Peer Manager event handler returns. If it is not called in time, a default configuration is used. See <a class="el" href="structpm__conn__sec__config__t.html">pm_conn_sec_config_t</a> for the value of the default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_handle</td><td>The connection to set the configuration for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_conn_sec_config</td><td>The configuration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga81e56cb4bade3444d360211e136a55f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81e56cb4bade3444d360211e136a55f1">&#9670;&nbsp;</a></span>pm_conn_sec_params_reply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_conn_sec_params_reply </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>conn_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structble__gap__sec__params__t.html">ble_gap_sec_params_t</a> *&#160;</td>
          <td class="paramname"><em>p_sec_params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for providing security parameters for a link. </p>
<p>This function is optional, and must be called in reply to a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba7ebd4003aafe1f0987f8ddacbb13444a">PM_EVT_CONN_SEC_PARAMS_REQ</a> event, before the Peer Manager event handler returns. If it is not called in time, the parameters given in <a class="el" href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">pm_sec_params_set</a> are used. See <a class="el" href="structpm__conn__sec__config__t.html">pm_conn_sec_config_t</a> for the value of the default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_handle</td><td>The connection to set the parameters for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sec_params</td><td>The parameters. If NULL, the security procedure is rejected. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_context</td><td>The context found in the request event that this function replies to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Successful reply. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>p_sec_params or p_context was null. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>Value of p_sec_params was invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>This module is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a2760d50178059a4156f00bb6c0eb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a2760d50178059a4156f00bb6c0eb56">&#9670;&nbsp;</a></span>pm_conn_sec_status_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_conn_sec_status_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>conn_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpm__conn__sec__status__t.html">pm_conn_sec_status_t</a> *&#160;</td>
          <td class="paramname"><em>p_conn_sec_status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the security status of a connection. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_handle</td><td>Connection handle of the link as provided by the SoftDevice. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_conn_sec_status</td><td>Security status of the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If pairing was initiated successfully. </td></tr>
    <tr><td class="paramname">BLE_ERROR_INVALID_CONN_HANDLE</td><td>If the connection handle is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_conn_sec_status</code> was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga46dfaf46c0aa94fc15017d42b3a2e514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46dfaf46c0aa94fc15017d42b3a2e514">&#9670;&nbsp;</a></span>pm_conn_secure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_conn_secure </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>conn_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_repairing</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for establishing encryption on a connection, and optionally establishing a bond. </p>
<p>This function attempts to secure the link that is specified by <code>conn_handle</code>. It uses the parameters that were previously provided in a call to <a class="el" href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">pm_sec_params_set</a>.</p>
<p>If the connection is a master connection, calling this function starts a security procedure on the link. If we have keys from a previous bonding procedure with this peer and the keys meet the security requirements in the currently active security parameters, the function attempts to establish encryption with the existing keys. If no key exists, the function attempts to perform pairing and bonding according to the currently active security parameters.</p>
<p>If the function completes successfully, a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bae2a89b2bbba5a84adf4df81741e35316">PM_EVT_CONN_SEC_START</a> event is sent. The procedure might be queued, in which case the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bae2a89b2bbba5a84adf4df81741e35316">PM_EVT_CONN_SEC_START</a> event is delayed until the procedure is initiated in the SoftDevice.</p>
<p>If the connection is a slave connection, the function sends a security request to the peer (master). It is up to the peer then to initiate pairing or encryption. If the peer ignores the request, a <a class="el" href="group___b_l_e___g_a_p___e_n_u_m_e_r_a_t_i_o_n_s.html#ggada486dd3c0cce897b23a887bed284fefa8958220152f7547da3b250b4f724877c">BLE_GAP_EVT_AUTH_STATUS</a> event occurs with the status <a class="el" href="group___b_l_e___g_a_p___s_e_c___s_t_a_t_u_s.html#ga4bdb61f7294a378778fe478597b17e07">BLE_GAP_SEC_STATUS_TIMEOUT</a>. Otherwise, the peer initiates security, in which case things happen as if the peer had initiated security itself. See <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bae2a89b2bbba5a84adf4df81741e35316">PM_EVT_CONN_SEC_START</a> for information about peer-initiated security.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_handle</td><td>Connection handle of the link as provided by the SoftDevice. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">force_repairing</td><td>Whether to force a pairing procedure even if there is an existing encryption key. This argument is relevant only for the central role. Recommended value: false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the operation completed successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If a security procedure is already in progress on the link, or if the link is disconnecting or disconnected. </td></tr>
    <tr><td class="paramname">NRF_ERROR_TIMEOUT</td><td>If there was an SMP time-out, so that no more security operations can be performed on this link. </td></tr>
    <tr><td class="paramname">BLE_ERROR_INVALID_CONN_HANDLE</td><td>If the connection handle is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If the security parameters have not been set, either by <a class="el" href="group__peer__manager.html#gac27a2cc39be9fce1bd866ba4c6b18349">pm_sec_params_set</a> or by <a class="el" href="group__peer__manager.html#ga81e56cb4bade3444d360211e136a55f1">pm_conn_sec_params_reply</a>. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_DATA</td><td>If the peer is bonded, but no LTK was found in the stored bonding data. Repairing was not requested. </td></tr>
    <tr><td class="paramname">NRF_ERROR_STORAGE_FULL</td><td>If there is no more space in persistent storage. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>If no more authentication procedures can run in parallel for the given role. See sd_ble_gap_authenticate. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga01c4803ee9857ee105eba76db8fec8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01c4803ee9857ee105eba76db8fec8dd">&#9670;&nbsp;</a></span>pm_device_identities_list_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_device_identities_list_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> const *&#160;</td>
          <td class="paramname"><em>p_peers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>peer_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting and clearing the device identities list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_peers</td><td>The peers to add to the device identities list. Pass NULL to clear the device identities list. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_cnt</td><td>The number of peers. Pass zero to clear the device identities list.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the device identities list was successfully set or cleared. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If a peer is invalid or its data could not be found in flash. </td></tr>
    <tr><td class="paramname">BLE_ERROR_GAP_INVALID_BLE_ADDR</td><td>If a peer has an address that cannot be used for whitelisting. </td></tr>
    <tr><td class="paramname">BLE_ERROR_GAP_DEVICE_IDENTITIES_IN_USE</td><td>If the device identities list is in use and cannot be set. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If using a SoftDevice that does not support device identities, e.g. S130 v2.0. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga97374b3a6c4a1618a82760218ecdb157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97374b3a6c4a1618a82760218ecdb157">&#9670;&nbsp;</a></span>pm_id_addr_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_id_addr_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> *&#160;</td>
          <td class="paramname"><em>p_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the local <em>Bluetooth</em> identity address. </p>
<p>This function always returns the identity address, irrespective of the privacy settings. This means that the address type will always be either <a class="el" href="group___b_l_e___g_a_p___a_d_d_r___t_y_p_e_s.html#gaa5e499423d88b16817efd4d5ec10fd6e">BLE_GAP_ADDR_TYPE_PUBLIC</a> or <a class="el" href="group___b_l_e___g_a_p___a_d_d_r___t_y_p_e_s.html#gabe27b8f22c3a52413fa064c2ee1e4fba">BLE_GAP_ADDR_TYPE_RANDOM_STATIC</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_addr</td><td>Pointer to the address structure to be filled in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the address was retrieved successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_addr</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga780f7978bfd31ded77908e2b33e8d05e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga780f7978bfd31ded77908e2b33e8d05e">&#9670;&nbsp;</a></span>pm_id_addr_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_id_addr_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> const *&#160;</td>
          <td class="paramname"><em>p_addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting the local <em>Bluetooth</em> identity address. </p>
<p>The local <em>Bluetooth</em> identity address is the address that identifies the device to other peers. The address type must be either <a class="el" href="group___b_l_e___g_a_p___a_d_d_r___t_y_p_e_s.html#gaa5e499423d88b16817efd4d5ec10fd6e">BLE_GAP_ADDR_TYPE_PUBLIC</a> or <a class="el" href="group___b_l_e___g_a_p___a_d_d_r___t_y_p_e_s.html#gabe27b8f22c3a52413fa064c2ee1e4fba">BLE_GAP_ADDR_TYPE_RANDOM_STATIC</a>. The identity address cannot be changed while roles are running.</p>
<p>The SoftDevice sets a default address of type <a class="el" href="group___b_l_e___g_a_p___a_d_d_r___t_y_p_e_s.html#gabe27b8f22c3a52413fa064c2ee1e4fba">BLE_GAP_ADDR_TYPE_RANDOM_STATIC</a> when it is enabled. This default address is a random number that is populated during the IC manufacturing process. It remains unchanged for the lifetime of each IC, but the application can use this function to assign a different identity address.</p>
<p>The identity address is distributed to the peer during bonding. Changing the identity address means bonded devices might not recognize us.</p>
<dl class="section note"><dt>Note</dt><dd>The SoftDevice functions sd_ble_gap_addr_set and sd_ble_gap_privacy_set must not be called when using the Peer Manager. Use the Peer Manager equivalents instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_addr</td><td>The GAP address to be set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the identity address was set successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_addr</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If the <code>p_addr</code> pointer is invalid. </td></tr>
    <tr><td class="paramname">BLE_ERROR_GAP_INVALID_BLE_ADDR</td><td>If the BLE address is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If the SoftDevice was busy. Process SoftDevice events and retry. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized or if this function was called while advertising, scanning, or while connected. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8380e1f31d34cdacd511734cae8b6dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8380e1f31d34cdacd511734cae8b6dde">&#9670;&nbsp;</a></span>pm_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the Peer Manager. </p>
<p>You must initialize the Peer Manager before you can call any other Peer Manager functions.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab69b5939738b54f1df6b2209a19397da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab69b5939738b54f1df6b2209a19397da">&#9670;&nbsp;</a></span>pm_lesc_public_key_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_lesc_public_key_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structble__gap__lesc__p256__pk__t.html">ble_gap_lesc_p256_pk_t</a> *&#160;</td>
          <td class="paramname"><em>p_public_key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Experimental function for specifying the public key to use for LESC operations. </p>
<p>This function can be called multiple times. The specified public key will be used for all subsequent LESC (LE Secure Connections) operations until the next time this function is called.</p>
<dl class="section note"><dt>Note</dt><dd>The key must continue to reside in application memory as it is not copied by Peer Manager.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_public_key</td><td>The public key to use for all subsequent LESC operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If pairing was initiated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaecb7f99f58d71f085f62f5cc5267508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaecb7f99f58d71f085f62f5cc5267508">&#9670;&nbsp;</a></span>pm_local_database_has_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_local_database_has_changed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for manually informing that the local database has changed. </p>
<p>This function sends a service changed indication to all bonded and/or connected peers that subscribe to this indication. If a bonded peer is not connected, the indication is sent when it reconnects. Every time an indication is sent, a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba30262da2e6eb8e00f9dc1bd0ba6dfaf3">PM_EVT_SERVICE_CHANGED_IND_SENT</a> event occurs, followed by a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bade6db0b8e2357b6ce937e72bf7e1f6eb">PM_EVT_SERVICE_CHANGED_IND_CONFIRMED</a> when the peer sends its confirmation. Peers that are not subscribed to the service changed indication when this function is called do not receive an indication, and no events are sent to the user. Likewise, if the service changed characteristic is not present in the local database, or if the <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a32355467741b67375a73277afdf89b22">PM_SERVICE_CHANGED_ENABLED</a> is set to 0, no indications are sent peers, and no events are sent to the user. </p>

</div>
</div>
<a id="ga6840dd6bb6ece5da0d30ef2c873ef9a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6840dd6bb6ece5da0d30ef2c873ef9a1">&#9670;&nbsp;</a></span>pm_next_peer_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> pm_next_peer_id_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>prev_peer_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the next peer ID in the sequence of all used peer IDs. </p>
<p>This function can be used to loop through all used peer IDs. The order in which peer IDs are returned should be considered unpredictable. <a class="el" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a> is considered to be before the first and after the last used peer ID.</p>
<p>To loop through all peer IDs exactly once, use the following constuct: </p><div class="fragment"><div class="line"><a class="code" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> current_peer_id = <a class="code" href="group__peer__manager.html#ga6840dd6bb6ece5da0d30ef2c873ef9a1">pm_next_peer_id_get</a>(<a class="code" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a>);</div>
<div class="line"><span class="keywordflow">while</span> (current_peer_id != <a class="code" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Do something with current_peer_id.</span></div>
<div class="line">    current_peer_id = <a class="code" href="group__peer__manager.html#ga6840dd6bb6ece5da0d30ef2c873ef9a1">pm_next_peer_id_get</a>(current_peer_id)</div>
<div class="line">}</div>
<div class="ttc" id="agroup__peer__manager_html_ga0aa174d9642816af3ba36db985465f46"><div class="ttname"><a href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a></div><div class="ttdeci">uint16_t pm_peer_id_t</div><div class="ttdoc">Handle to uniquely identify a peer for which we have persistently stored data.</div><div class="ttdef"><b>Definition:</b> peer_manager_types.h:68</div></div>
<div class="ttc" id="agroup__peer__manager_html_ga6840dd6bb6ece5da0d30ef2c873ef9a1"><div class="ttname"><a href="group__peer__manager.html#ga6840dd6bb6ece5da0d30ef2c873ef9a1">pm_next_peer_id_get</a></div><div class="ttdeci">pm_peer_id_t pm_next_peer_id_get(pm_peer_id_t prev_peer_id)</div><div class="ttdoc">Function for getting the next peer ID in the sequence of all used peer IDs.</div></div>
<div class="ttc" id="agroup__peer__manager_html_ga8a57c33c829ad19bc6a2cd655b40dc9b"><div class="ttname"><a href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a></div><div class="ttdeci">#define PM_PEER_ID_INVALID</div><div class="ttdoc">Invalid value for pm_peer_id_t.</div><div class="ttdef"><b>Definition:</b> peer_manager_types.h:87</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev_peer_id</td><td>The previous peer ID.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The next peer ID. If <code>prev_peer_id</code> was <a class="el" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a>, the next peer ID is the first used peer ID. If <code>prev_peer_id</code> was the last used peer ID, the function returns <a class="el" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a>. </dd></dl>

</div>
</div>
<a id="ga4a567e24c36e7c496d4c8975994b10e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a567e24c36e7c496d4c8975994b10e1">&#9670;&nbsp;</a></span>pm_peer_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t pm_peer_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for querying the number of valid peer IDs that are available. </p>
<p>This function returns the number of peers for which there is data in persistent storage.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of valid peer IDs. </dd></dl>

</div>
</div>
<a id="ga3baa6c3b0a1ac2f3983f3704d6c2406c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3baa6c3b0a1ac2f3983f3704d6c2406c">&#9670;&nbsp;</a></span>pm_peer_data_app_data_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_app_data_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading a peer's application data. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06aa9b452e4a0ce00318a533d7fdc8761fa">PM_PEER_DATA_ID_APPLICATION</a>). </p>
<p>See <a class="el" href="group__peer__manager.html#ga84eebadf6d2f5531eb8d1e1157123b5d">pm_peer_data_load</a> for parameters and return values. </p>

</div>
</div>
<a id="ga12897bd899eaaff0ca43560ac00662cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12897bd899eaaff0ca43560ac00662cf">&#9670;&nbsp;</a></span>pm_peer_data_app_data_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_app_data_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting or updating a peer's application data. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06aa9b452e4a0ce00318a533d7fdc8761fa">PM_PEER_DATA_ID_APPLICATION</a>). </p>
<p>See <a class="el" href="group__peer__manager.html#ga686445a2134e8b1222f9318caf78b4ab">pm_peer_data_store</a> for parameters and return values. </p>

</div>
</div>
<a id="gabf148a0bb89fadfaae7f93bbda4e93ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf148a0bb89fadfaae7f93bbda4e93ef">&#9670;&nbsp;</a></span>pm_peer_data_bonding_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_bonding_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a> *&#160;</td>
          <td class="paramname"><em>p_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading a peer's bonding data (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7">PM_PEER_DATA_ID_BONDING</a>). </p>
<p>See <a class="el" href="group__peer__manager.html#ga84eebadf6d2f5531eb8d1e1157123b5d">pm_peer_data_load</a> for parameters and return values. </p>

</div>
</div>
<a id="ga967910e510aa10b371a234cf0a2d2e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga967910e510aa10b371a234cf0a2d2e5a">&#9670;&nbsp;</a></span>pm_peer_data_bonding_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_bonding_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a> const *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting or updating a peer's bonding data (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7">PM_PEER_DATA_ID_BONDING</a>). </p>
<p>See <a class="el" href="group__peer__manager.html#ga686445a2134e8b1222f9318caf78b4ab">pm_peer_data_store</a> for parameters and return values. </p>

</div>
</div>
<a id="ga7292e5ea2f00b2384b01460aba0e7a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7292e5ea2f00b2384b01460aba0e7a8f">&#9670;&nbsp;</a></span>pm_peer_data_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a>&#160;</td>
          <td class="paramname"><em>data_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for deleting a peer's stored pieces of data. </p>
<p>This function deletes specific data that is stored for a peer. Note that bonding data cannot be cleared separately.</p>
<p>To delete all data for a peer (including bonding data), use <a class="el" href="group__peer__manager.html#gad20bb7430862e537e4219cf9fd8c5f98">pm_peer_delete</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Clearing data in persistent storage happens asynchronously.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_id</td><td>Peer ID to clear data for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_id</td><td>Which data to clear.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the clear procedure was initiated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>If <code>data_id</code> was PM_PEER_DATA_ID_BONDING or invalid, or <code>peer_id</code> was invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If there was no data to clear for this peer ID/data ID combination. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If the underlying flash handler is busy with other flash operations. Try again after receiving a Peer Manager event. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84eebadf6d2f5531eb8d1e1157123b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84eebadf6d2f5531eb8d1e1157123b5d">&#9670;&nbsp;</a></span>pm_peer_data_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a>&#160;</td>
          <td class="paramname"><em>data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving stored data of a peer. </p>
<dl class="section note"><dt>Note</dt><dd>The length of the provided buffer must be a multiple of 4.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_id</td><td>Peer ID to get data for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_id</td><td>Which type of data to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_data</td><td>Where to put the retrieved data. The documentation for <a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a> specifies what data type each data ID is stored as. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_len</td><td>In: The length in bytes of <code>p_data</code>. Out: The length in bytes of the read data, if the read was successful.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the data was read successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>If the the data type or the peer ID was invalid or unallocated, or if the length in <code>p_length</code> was not a multiple of 4. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If a pointer parameter was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If no stored data was found for this peer ID/data ID combination. </td></tr>
    <tr><td class="paramname">NRF_ERROR_DATA_SIZE</td><td>If the provided buffer was not large enough. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga857d0229ac9ab4d2d77341ec4bc3e4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga857d0229ac9ab4d2d77341ec4bc3e4c2">&#9670;&nbsp;</a></span>pm_peer_data_remote_db_load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_remote_db_load </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structble__gatt__db__srv__t.html">ble_gatt_db_srv_t</a> *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>p_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading a peer's remote DB values. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a757fefd5a70664382abbebf21f33ef80">PM_PEER_DATA_ID_GATT_REMOTE</a>). </p>
<p>See <a class="el" href="group__peer__manager.html#ga84eebadf6d2f5531eb8d1e1157123b5d">pm_peer_data_load</a> for parameters and return values. </p>

</div>
</div>
<a id="gaa43da60a5452c269fe2723b58cdd6b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa43da60a5452c269fe2723b58cdd6b3a">&#9670;&nbsp;</a></span>pm_peer_data_remote_db_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_remote_db_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structble__gatt__db__srv__t.html">ble_gatt_db_srv_t</a> const *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting or updating a peer's remote DB values. (<a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06a757fefd5a70664382abbebf21f33ef80">PM_PEER_DATA_ID_GATT_REMOTE</a>). </p>
<p>See <a class="el" href="group__peer__manager.html#ga686445a2134e8b1222f9318caf78b4ab">pm_peer_data_store</a> for parameters and return values. </p>

</div>
</div>
<a id="ga686445a2134e8b1222f9318caf78b4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga686445a2134e8b1222f9318caf78b4ab">&#9670;&nbsp;</a></span>pm_peer_data_store()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_data_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a>&#160;</td>
          <td class="paramname"><em>data_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting or updating stored data of a peer. </p>
<dl class="section note"><dt>Note</dt><dd>Writing the data to persistent storage happens asynchronously. Therefore, the buffer that contains the data must be kept alive until the operation has completed.</dd>
<dd>
The data written using this function might later be overwritten as a result of internal operations in the Peer Manager. A Peer Manager event is sent each time data is updated, regardless of whether the operation originated internally or from action by the user.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_id</td><td>Peer ID to set data for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_id</td><td>Which type of data to set. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_data</td><td>New value to set. The documentation for <a class="el" href="group__peer__manager.html#gaea4a3fb3906fefa79138b7b5cc61cd06">pm_peer_data_id_t</a> specifies what data type each data ID should be stored as. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The length in bytes of <code>p_data</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token that identifies this particular store operation. The token can be used to identify events that pertain to this operation. This parameter can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the data is scheduled to be written to persistent storage. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_data</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If no peer was found for the peer ID. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If the underlying flash handler is busy with other flash operations. Try again after receiving a Peer Manager event. </td></tr>
    <tr><td class="paramname">NRF_ERROR_FORBIDDEN</td><td>If data ID is <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ad3697b5719db0cf46d26b08aa396f2a7">PM_PEER_DATA_ID_BONDING</a> and the new bonding data also corresponds to another bonded peer. No data is written so duplicate entries are avoided. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad20bb7430862e537e4219cf9fd8c5f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad20bb7430862e537e4219cf9fd8c5f98">&#9670;&nbsp;</a></span>pm_peer_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for freeing persistent storage for a peer. </p>
<p>This function deletes every piece of data that is associated with the specified peer and frees the peer ID to be used for another peer. The deletion happens asynchronously, and the peer ID is not freed until the data is deleted. When the operation finishes, a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bac60e271288362aa95be06402d9c219a2">PM_EVT_PEER_DELETE_SUCCEEDED</a> or <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808baa52faff4d0a1b48a24480e9af75e97ff">PM_EVT_PEER_DELETE_FAILED</a> event is sent.</p>
<dl class="section warning"><dt>Warning</dt><dd>Use this function only when not connected to or connectable for the peer that is being deleted. If the peer is or becomes connected or data is manually written in flash during this procedure (until the success or failure event happens), the behavior is undefined.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_id</td><td>Peer ID to be freed and have all associated data deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the operation was initiated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>If the peer ID was not valid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga753b87346d599de963c65adb4d8c1b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga753b87346d599de963c65adb4d8c1b5c">&#9670;&nbsp;</a></span>pm_peer_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_id_get </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>conn_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *&#160;</td>
          <td class="paramname"><em>p_peer_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the ID of a peer, given its connection handle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">conn_handle</td><td>The connection handle of the peer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_peer_id</td><td>The peer ID, or <a class="el" href="group__peer__manager.html#ga8a57c33c829ad19bc6a2cd655b40dc9b">PM_PEER_ID_INVALID</a> if the peer is not bonded or <code>conn_handle</code> does not refer to a valid connection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the peer ID was retrieved successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_peer_id</code> was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fcba9818cc93048b269c766df95b0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fcba9818cc93048b269c766df95b0ff">&#9670;&nbsp;</a></span>pm_peer_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_new </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *&#160;</td>
          <td class="paramname"><em>p_new_peer_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpm__peer__data__bonding__t.html">pm_peer_data_bonding_t</a> *&#160;</td>
          <td class="paramname"><em>p_bonding_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga090324ad9f53add6b9a1e971f953f452">pm_store_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for manually adding a peer to the persistent storage. </p>
<p>This function allocates a new peer ID and stores bonding data for the new peer. The bonding data is necessary to prevent ambiguity/inconsistency in peer data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_bonding_data</td><td>The bonding data of the new peer (must contain a public/static address or a non-zero IRK). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_new_peer_id</td><td>Peer ID for the new peer, or an existing peer if a match was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token that identifies this particular store operation (storing the bonding data). The token can be used to identify events that pertain to this operation. This parameter can be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the store operation for bonding data was initiated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_bonding_data</code> or <code>p_new_peer_id</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_STORAGE_FULL</td><td>If there is no more space in persistent storage. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>If there are no more available peer IDs. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If the underlying flash filesystem is busy with other flash operations. Try again after receiving a Peer Manager event. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabc58adc899853649726001da3350b56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc58adc899853649726001da3350b56c">&#9670;&nbsp;</a></span>pm_peer_rank_highest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_rank_highest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a>&#160;</td>
          <td class="paramname"><em>peer_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating the rank of a peer to be highest among all stored peers. </p>
<p>If this function returns <a class="el" href="group__nrf__error.html#ga7e6367efeaac363d8cf024940b4ec123">NRF_SUCCESS</a>, either a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808badfca2d9adc511c7bf5652f4741c0cead">PM_EVT_PEER_DATA_UPDATE_SUCCEEDED</a> or a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba0bc454bb2f85cd7b6a05b3e4e8abeb83">PM_EVT_PEER_DATA_UPDATE_FAILED</a> event is sent with a <a class="el" href="group__peer__manager.html#gadb8282ab380eb5e409449155b3c18f26">PM_STORE_TOKEN_INVALID</a> store token when the operation is complete. Until the operation is complete, this function returns <a class="el" href="group__nrf__error.html#ga5d2d8608f6d6a0329f58961a969e946e">NRF_ERROR_BUSY</a>.</p>
<p>When the operation is complete, the peer is the highest ranked peer as reported by <a class="el" href="group__peer__manager.html#gacc5d71e8a81c55d6df58b8025b49da1c">pm_peer_ranks_get</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808badfca2d9adc511c7bf5652f4741c0cead">PM_EVT_PEER_DATA_UPDATE_SUCCEEDED</a> event can arrive before the function returns if the peer is already ranked highest. In this case, the <a class="el" href="structpm__peer__data__update__succeeded__evt__t.html#adc19b1e2649d80b82e820ecb6d36ccb8">pm_peer_data_update_succeeded_evt_t::flash_changed</a> flag in the event will be false.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_id</td><td>The peer to rank highest.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the peer's rank is, or will be updated to be highest. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If the underlying flash handler is busy with other flash operations, or if a previous call to this function has not completed. Try again after receiving a Peer Manager event. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_RESOURCES</td><td>If the highest rank is UINT32_MAX, so the new rank would wrap around to 0. To fix this, manually update all ranks to smaller values, while still keeping their order. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If peer rank functionality has been disabled via the <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a810aff10490e8d9d00c147242af0b9c9">PM_PEER_RANKS_ENABLED</a> configuration option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacc5d71e8a81c55d6df58b8025b49da1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc5d71e8a81c55d6df58b8025b49da1c">&#9670;&nbsp;</a></span>pm_peer_ranks_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peer_ranks_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *&#160;</td>
          <td class="paramname"><em>p_highest_ranked_peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_highest_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> *&#160;</td>
          <td class="paramname"><em>p_lowest_ranked_peer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_lowest_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for finding the highest and lowest ranked peers. </p>
<p>The rank is saved in persistent storage under the data ID <a class="el" href="group__peer__manager.html#ggaea4a3fb3906fefa79138b7b5cc61cd06ae45494c5b327f12cc44c5fea0b1389d5">PM_PEER_DATA_ID_PEER_RANK</a>.</p>
<p>The interpretation of rank is up to the user, because the rank is only updated by calling <a class="el" href="group__peer__manager.html#gabc58adc899853649726001da3350b56c">pm_peer_rank_highest</a> or by manipulating the value using a <a class="el" href="group__peer__manager.html#PM_PEER_DATA_FUNCTIONS">PM_PEER_DATA_FUNCTIONS</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>Any argument that is NULL is ignored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_highest_ranked_peer</td><td>The peer ID with the highest rank of all peers, for example, the most recently used peer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_highest_rank</td><td>The highest rank. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_lowest_ranked_peer</td><td>The peer ID with the lowest rank of all peers, for example, the least recently used peer. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_lowest_rank</td><td>The lowest rank.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the operation completed successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If no peers were found. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_SUPPORTED</td><td>If peer rank functionality has been disabled via the <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a810aff10490e8d9d00c147242af0b9c9">PM_PEER_RANKS_ENABLED</a> configuration option. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa99779ab5b8b4cfde65974bdf75a1e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa99779ab5b8b4cfde65974bdf75a1e7c">&#9670;&nbsp;</a></span>pm_peers_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_peers_delete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for deleting all data stored for all peers. </p>
<p>This function sends either a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba01bb9681e844d97e0635298e318e69e2">PM_EVT_PEERS_DELETE_SUCCEEDED</a> or a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808ba5c48d50f7c84fe454340c787b5006125">PM_EVT_PEERS_DELETE_FAILED</a> event. In addition, a <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bac60e271288362aa95be06402d9c219a2">PM_EVT_PEER_DELETE_SUCCEEDED</a> or <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808baa52faff4d0a1b48a24480e9af75e97ff">PM_EVT_PEER_DELETE_FAILED</a> event is sent for each deleted peer.</p>
<dl class="section note"><dt>Note</dt><dd>When there is no peer data in flash the <a class="el" href="group__peer__manager.html#gga4a0e37cf07eb91e1a1808995b957808bac60e271288362aa95be06402d9c219a2">PM_EVT_PEER_DELETE_SUCCEEDED</a> event is sent synchronously.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Use this function only when not connected or connectable. If a peer is or becomes connected or a <a class="el" href="group__peer__manager.html#PM_PEER_DATA_FUNCTIONS">PM_PEER_DATA_FUNCTIONS</a> function is used during this procedure (until the success or failure event happens), the behavior is undefined.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the deletion process was initiated successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad36f14ee236eb8cf038a31b07034dab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad36f14ee236eb8cf038a31b07034dab3">&#9670;&nbsp;</a></span>pm_privacy_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_privacy_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">pm_privacy_params_t</a> *&#160;</td>
          <td class="paramname"><em>p_privacy_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving privacy settings. </p>
<p>The privacy settings that are returned include the current IRK as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_privacy_params</td><td>Privacy settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the privacy settings were retrieved successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_privacy_params</code> or <code>p_privacy_params-&gt;p_device_irk</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga097a70106c2c2cdd1d34f710e6a9258c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga097a70106c2c2cdd1d34f710e6a9258c">&#9670;&nbsp;</a></span>pm_privacy_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_privacy_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga5d267fa432149f37e231c8f11ad8a395">pm_privacy_params_t</a> const *&#160;</td>
          <td class="paramname"><em>p_privacy_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for configuring privacy settings. </p>
<p>The privacy settings cannot be configured while advertising, scanning, or while in a connection.</p>
<dl class="section note"><dt>Note</dt><dd>The SoftDevice functions sd_ble_gap_addr_set and sd_ble_gap_privacy_set must not be called when using the Peer Manager. Use this function instead.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_privacy_params</td><td>Privacy settings.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the privacy settings were configured successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_privacy_params</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_BUSY</td><td>If the operation could not be performed at this time. Process SoftDevice events and retry. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>If the address type is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If this function is called while BLE roles using privacy are enabled. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18de76ca580459402d43073519287b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18de76ca580459402d43073519287b4a">&#9670;&nbsp;</a></span>pm_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga8de7838090b1a30c2077c82618a608e9">pm_evt_handler_t</a>&#160;</td>
          <td class="paramname"><em>event_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for registering an event handler with the Peer Manager. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">event_handler</td><td>Callback for events from the <a class="el" href="group__peer__manager.html">Peer Manager</a> module. <code>event_handler</code> is called for every event that the Peer Manager sends after this function is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>event_handler</code> was NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>If no more registrations can happen. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac27a2cc39be9fce1bd866ba4c6b18349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac27a2cc39be9fce1bd866ba4c6b18349">&#9670;&nbsp;</a></span>pm_sec_params_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_sec_params_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structble__gap__sec__params__t.html">ble_gap_sec_params_t</a> *&#160;</td>
          <td class="paramname"><em>p_sec_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for providing pairing and bonding parameters to use for pairing procedures. </p>
<p>Until this function is called, all bonding procedures that are initiated by the peer are rejected.</p>
<p>This function can be called multiple times with different parameters, even with NULL as <code>p_sec_params</code>, in which case the Peer Manager starts rejecting all procedures again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_sec_params</td><td>Security parameters to be used for subsequent security procedures.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the parameters were set successfully. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_PARAM</td><td>If the combination of parameters is invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If an internal error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa49e1efd56574674353e1d4f1c4a026a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa49e1efd56574674353e1d4f1c4a026a">&#9670;&nbsp;</a></span>pm_whitelist_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_whitelist_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structble__gap__addr__t.html">ble_gap_addr_t</a> *&#160;</td>
          <td class="paramname"><em>p_addrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_addr_cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structble__gap__irk__t.html">ble_gap_irk_t</a> *&#160;</td>
          <td class="paramname"><em>p_irks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_irk_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving the previously set whitelist. </p>
<p>The function retrieves the whitelist of GAP addresses and IRKs that was previously set by <a class="el" href="group__peer__manager.html#ga56e6bbda42ceae2d56520786e4d9730d">pm_whitelist_set</a>.</p>
<p>To retrieve only GAP addresses or only IRKs, provide only one of the buffers. If a buffer is provided, its size must be specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_addrs</td><td>The buffer where to store GAP addresses. Pass NULL to retrieve only IRKs (in that case, <code>p_irks</code> must not be NULL). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_addr_cnt</td><td>In: The size of the <code>p_addrs</code> buffer. May be NULL if and only if <code>p_addrs</code> is NULL. Out: The number of GAP addresses copied into the buffer. If <code>p_addrs</code> is NULL, this parameter remains unchanged. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_irks</td><td>The buffer where to store IRKs. Pass NULL to retrieve only GAP addresses (in that case, <code>p_addrs</code> must not NULL). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_irk_cnt</td><td>In: The size of the <code>p_irks</code> buffer. May be NULL if and only if <code>p_irks</code> is NULL. Out: The number of IRKs copied into the buffer. If <code>p_irks</code> is NULL, this paramater remains unchanged.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the whitelist was successfully retrieved. </td></tr>
    <tr><td class="paramname">BLE_ERROR_GAP_INVALID_BLE_ADDR</td><td>If a peer has an address that cannot be used for whitelisting (this error can occur only when using the S13x SoftDevice v2.x). </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If a required parameter is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>If the provided buffers are too small. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If the data for any of the cached whitelisted peers cannot be found. It might have been deleted. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga56e6bbda42ceae2d56520786e4d9730d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga56e6bbda42ceae2d56520786e4d9730d">&#9670;&nbsp;</a></span>pm_whitelist_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> pm_whitelist_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__peer__manager.html#ga0aa174d9642816af3ba36db985465f46">pm_peer_id_t</a> const *&#160;</td>
          <td class="paramname"><em>p_peers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>peer_cnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting or clearing the whitelist. </p>
<p>When using the S13x SoftDevice v3.x, this function sets or clears the whitelist. When using the S13x SoftDevice v2.x, this function caches a list of peers that can be retrieved later by <a class="el" href="group__peer__manager.html#gaa49e1efd56574674353e1d4f1c4a026a">pm_whitelist_get</a> to pass to the lib_ble_advertising.</p>
<p>To clear the current whitelist, pass either NULL as <code>p_peers</code> or zero as <code>peer_cnt</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_peers</td><td>The peers to add to the whitelist. Pass NULL to clear the current whitelist. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peer_cnt</td><td>The number of peers to add to the whitelist. The number must not be greater than <a class="el" href="group___b_l_e___g_a_p___d_e_f_i_n_e_s.html#ga0e1bde4f7e3b124dc8aa2e7b032b8313">BLE_GAP_WHITELIST_ADDR_MAX_COUNT</a>. Pass zero to clear the current whitelist.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the whitelist was successfully set or cleared. </td></tr>
    <tr><td class="paramname">BLE_GAP_ERROR_WHITELIST_IN_USE</td><td>If a whitelist is already in use and cannot be set. </td></tr>
    <tr><td class="paramname">BLE_ERROR_GAP_INVALID_BLE_ADDR</td><td>If a peer in <code>p_peers</code> has an address that cannot be used for whitelisting. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NOT_FOUND</td><td>If any of the peers in <code>p_peers</code> cannot be found. </td></tr>
    <tr><td class="paramname">NRF_ERROR_DATA_SIZE</td><td>If <code>peer_cnt</code> is greater than <a class="el" href="group___b_l_e___g_a_p___d_e_f_i_n_e_s.html#ga0e1bde4f7e3b124dc8aa2e7b032b8313">BLE_GAP_WHITELIST_ADDR_MAX_COUNT</a>. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the Peer Manager is not initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
