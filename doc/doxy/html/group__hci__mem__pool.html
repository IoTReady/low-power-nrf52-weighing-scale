<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: Memory pool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__hci__mem__pool.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory pool</div>  </div>
</div><!--header-->
<div class="contents">

<p>Memory pool implementation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaadd0dcc9a737d2401c05dbd0cd350a13"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#gaadd0dcc9a737d2401c05dbd0cd350a13">hci_mem_pool_open</a> (void)</td></tr>
<tr class="memdesc:gaadd0dcc9a737d2401c05dbd0cd350a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for opening the module.  <a href="group__hci__mem__pool.html#gaadd0dcc9a737d2401c05dbd0cd350a13">More...</a><br /></td></tr>
<tr class="separator:gaadd0dcc9a737d2401c05dbd0cd350a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46bf92027fa4fe402e53a8764713c99f"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#ga46bf92027fa4fe402e53a8764713c99f">hci_mem_pool_close</a> (void)</td></tr>
<tr class="memdesc:ga46bf92027fa4fe402e53a8764713c99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for closing the module.  <a href="group__hci__mem__pool.html#ga46bf92027fa4fe402e53a8764713c99f">More...</a><br /></td></tr>
<tr class="separator:ga46bf92027fa4fe402e53a8764713c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1da3c1e38317a5c312650396d9da6e8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#gad1da3c1e38317a5c312650396d9da6e8">hci_mem_pool_tx_alloc</a> (void **pp_buffer)</td></tr>
<tr class="memdesc:gad1da3c1e38317a5c312650396d9da6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for allocating requested amount of TX memory.  <a href="group__hci__mem__pool.html#gad1da3c1e38317a5c312650396d9da6e8">More...</a><br /></td></tr>
<tr class="separator:gad1da3c1e38317a5c312650396d9da6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44dd78500f42bf6cddc5f90a03abd7af"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#ga44dd78500f42bf6cddc5f90a03abd7af">hci_mem_pool_tx_free</a> (void)</td></tr>
<tr class="memdesc:ga44dd78500f42bf6cddc5f90a03abd7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for freeing previously allocated TX memory.  <a href="group__hci__mem__pool.html#ga44dd78500f42bf6cddc5f90a03abd7af">More...</a><br /></td></tr>
<tr class="separator:ga44dd78500f42bf6cddc5f90a03abd7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c527499f6006d354a540268b4ea124"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#ga06c527499f6006d354a540268b4ea124">hci_mem_pool_rx_produce</a> (uint32_t length, void **pp_buffer)</td></tr>
<tr class="memdesc:ga06c527499f6006d354a540268b4ea124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for producing a free RX memory block for usage.  <a href="group__hci__mem__pool.html#ga06c527499f6006d354a540268b4ea124">More...</a><br /></td></tr>
<tr class="separator:ga06c527499f6006d354a540268b4ea124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aae0da2e09ccedb4deb30e01940c303"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#ga7aae0da2e09ccedb4deb30e01940c303">hci_mem_pool_rx_data_size_set</a> (uint32_t length)</td></tr>
<tr class="memdesc:ga7aae0da2e09ccedb4deb30e01940c303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for setting the length of the last produced RX memory block.  <a href="group__hci__mem__pool.html#ga7aae0da2e09ccedb4deb30e01940c303">More...</a><br /></td></tr>
<tr class="separator:ga7aae0da2e09ccedb4deb30e01940c303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf29059c4fa6204e2313069e90e7db51a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#gaf29059c4fa6204e2313069e90e7db51a">hci_mem_pool_rx_extract</a> (uint8_t **pp_buffer, uint32_t *p_length)</td></tr>
<tr class="memdesc:gaf29059c4fa6204e2313069e90e7db51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for extracting a packet, which has been filled with read data, for further processing.  <a href="group__hci__mem__pool.html#gaf29059c4fa6204e2313069e90e7db51a">More...</a><br /></td></tr>
<tr class="separator:gaf29059c4fa6204e2313069e90e7db51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga961c95e86995f3a6ad1a14822745c368"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hci__mem__pool.html#ga961c95e86995f3a6ad1a14822745c368">hci_mem_pool_rx_consume</a> (uint8_t *p_buffer)</td></tr>
<tr class="memdesc:ga961c95e86995f3a6ad1a14822745c368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for freeing previously extracted packet, which has been filled with read data.  <a href="group__hci__mem__pool.html#ga961c95e86995f3a6ad1a14822745c368">More...</a><br /></td></tr>
<tr class="separator:ga961c95e86995f3a6ad1a14822745c368"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Memory pool implementation. </p>
<p>Memory pool implementation, based on circular buffer data structure, which supports asynchronous processing of RX data. The current default implementation supports 1 TX buffer and 4 RX buffers. The memory managed by the pool is allocated from static storage instead of heap. The internal design of the circular buffer implementing the RX memory layout is illustrated in the picture below.</p>
<div class="image">
<object type="image/svg+xml" data="memory_pool.svg" style="pointer-events: none;"></object>
<div class="caption">
Circular buffer design</div></div>
<p>The expected call order for the RX APIs is as follows:</p><ul>
<li>hci_mem_pool_rx_produce</li>
<li>hci_mem_pool_rx_data_size_set</li>
<li>hci_mem_pool_rx_extract</li>
<li>hci_mem_pool_rx_consume</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>If the above mentioned expected call order is violated the end result can be undefined.</dd></dl>
<dl class="section user"><dt>Component specific configuration options</dt><dd></dd></dl>
<p>The following compile time configuration options are available to suit various implementations:</p><ul>
<li>TX_BUF_SIZE TX buffer size in bytes.</li>
<li>RX_BUF_SIZE RX buffer size in bytes.</li>
<li>RX_BUF_QUEUE_SIZE RX buffer element size. </li>
</ul>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga46bf92027fa4fe402e53a8764713c99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46bf92027fa4fe402e53a8764713c99f">&#9670;&nbsp;</a></span>hci_mem_pool_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_close </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for closing the module. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaadd0dcc9a737d2401c05dbd0cd350a13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadd0dcc9a737d2401c05dbd0cd350a13">&#9670;&nbsp;</a></span>hci_mem_pool_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_open </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for opening the module. </p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga961c95e86995f3a6ad1a14822745c368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga961c95e86995f3a6ad1a14822745c368">&#9670;&nbsp;</a></span>hci_mem_pool_rx_consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_rx_consume </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>p_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for freeing previously extracted packet, which has been filled with read data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_buffer</td><td>Pointer to consumed buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>Operation failure. No packet available to free. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>Operation failure. Not a valid pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7aae0da2e09ccedb4deb30e01940c303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aae0da2e09ccedb4deb30e01940c303">&#9670;&nbsp;</a></span>hci_mem_pool_rx_data_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_rx_data_size_set </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for setting the length of the last produced RX memory block. </p>
<dl class="section warning"><dt>Warning</dt><dd>If call to this API is omitted the end result is that the following call to mem_pool_rx_extract will return incorrect data in the p_length output parameter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Amount, in bytes, of actual memory used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. Length was set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf29059c4fa6204e2313069e90e7db51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf29059c4fa6204e2313069e90e7db51a">&#9670;&nbsp;</a></span>hci_mem_pool_rx_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_rx_extract </td>
          <td>(</td>
          <td class="paramtype">uint8_t **&#160;</td>
          <td class="paramname"><em>pp_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for extracting a packet, which has been filled with read data, for further processing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pp_buffer</td><td>Pointer to the packet data. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_length</td><td>Length of packet data in bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>Operation failure. No packet available to extract. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>Operation failure. NULL pointer supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga06c527499f6006d354a540268b4ea124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c527499f6006d354a540268b4ea124">&#9670;&nbsp;</a></span>hci_mem_pool_rx_produce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_rx_produce </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pp_buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for producing a free RX memory block for usage. </p>
<dl class="section note"><dt>Note</dt><dd>Upon produce request amount being 0, NRF_SUCCESS is returned.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Amount, in bytes, of free memory to be produced. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pp_buffer</td><td>Pointer to the allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. Free RX memory block produced. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>Operation failure. No suitable memory available for allocation. </td></tr>
    <tr><td class="paramname">NRF_ERROR_DATA_SIZE</td><td>Operation failure. Request size exceeds limit. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>Operation failure. NULL pointer supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1da3c1e38317a5c312650396d9da6e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1da3c1e38317a5c312650396d9da6e8">&#9670;&nbsp;</a></span>hci_mem_pool_tx_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_tx_alloc </td>
          <td>(</td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>pp_buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for allocating requested amount of TX memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pp_buffer</td><td>Pointer to the allocated memory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. Memory was allocated. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>Operation failure. No memory available for allocation. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>Operation failure. NULL pointer supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga44dd78500f42bf6cddc5f90a03abd7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44dd78500f42bf6cddc5f90a03abd7af">&#9670;&nbsp;</a></span>hci_mem_pool_tx_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t hci_mem_pool_tx_free </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for freeing previously allocated TX memory. </p>
<dl class="section note"><dt>Note</dt><dd>Memory management follows the FIFO principle meaning that free() order must match the alloc(...) order, which is the reason for omitting exact memory block identifier as an input parameter.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>Operation success. Memory was freed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
