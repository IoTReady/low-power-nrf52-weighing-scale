<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: Flash storage (fstorage)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nrf__fstorage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Flash storage (fstorage)</div>  </div>
</div><!--header-->
<div class="contents">

<p>Flash abstraction library that provides basic read, write, and erase operations.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__nrf__fstorage__nvmc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage__nvmc.html">NVMC implementation</a></td></tr>
<tr class="memdesc:group__nrf__fstorage__nvmc"><td class="mdescLeft">&#160;</td><td class="mdescRight">API implementation of fstorage that uses the non-volatile memory controller (NVMC). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__nrf__fstorage__sd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage__sd.html">SoftDevice implementation</a></td></tr>
<tr class="memdesc:group__nrf__fstorage__sd"><td class="mdescLeft">&#160;</td><td class="mdescRight">API implementation of fstorage that uses the SoftDevice. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__fstorage__evt__t.html">nrf_fstorage_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An fstorage event.  <a href="structnrf__fstorage__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__fstorage__info__t.html">nrf_fstorage_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the implementation and the flash peripheral.  <a href="structnrf__fstorage__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An fstorage instance.  <a href="structnrf__fstorage__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structnrf__fstorage__api__s.html">nrf_fstorage_api_s</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions provided by the API implementation.  <a href="structnrf__fstorage__api__s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga0b8f6204f5f7feffac0ffba8bdc159ff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga0b8f6204f5f7feffac0ffba8bdc159ff">NRF_FSTORAGE_DEF</a>(inst)&#160;&#160;&#160;NRF_SECTION_ITEM_REGISTER(fs_data, inst)</td></tr>
<tr class="memdesc:ga0b8f6204f5f7feffac0ffba8bdc159ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for defining an fstorage instance.  <a href="group__nrf__fstorage.html#ga0b8f6204f5f7feffac0ffba8bdc159ff">More...</a><br /></td></tr>
<tr class="separator:ga0b8f6204f5f7feffac0ffba8bdc159ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e2e00d7399808c38921856f08b1188c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga3e2e00d7399808c38921856f08b1188c">NRF_FSTORAGE_INSTANCE_GET</a>(i)&#160;&#160;&#160;<a class="el" href="group__section__vars.html#ga1169bdbbfb338a99e3dc363202f783d1">NRF_SECTION_ITEM_GET</a>(fs_data, <a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a>, (i))</td></tr>
<tr class="memdesc:ga3e2e00d7399808c38921856f08b1188c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for retrieving an fstorage instance.  <a href="group__nrf__fstorage.html#ga3e2e00d7399808c38921856f08b1188c">More...</a><br /></td></tr>
<tr class="separator:ga3e2e00d7399808c38921856f08b1188c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8074da070786b1e2cfc51b73454fe0d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gad8074da070786b1e2cfc51b73454fe0d">NRF_FSTORAGE_INSTANCE_CNT</a>&#160;&#160;&#160;<a class="el" href="group__section__vars.html#gaa717ca9ff9f8d78c9857ef88efc91faa">NRF_SECTION_ITEM_COUNT</a>(fs_data, <a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a>)</td></tr>
<tr class="memdesc:gad8074da070786b1e2cfc51b73454fe0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for retrieving the total number of fstorage instances.  <a href="group__nrf__fstorage.html#gad8074da070786b1e2cfc51b73454fe0d">More...</a><br /></td></tr>
<tr class="separator:gad8074da070786b1e2cfc51b73454fe0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga9c8d489cd2c6d9b7f4dc531142e2725b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga9c8d489cd2c6d9b7f4dc531142e2725b">nrf_fstorage_evt_handler_t</a>) (<a class="el" href="structnrf__fstorage__evt__t.html">nrf_fstorage_evt_t</a> *p_evt)</td></tr>
<tr class="memdesc:ga9c8d489cd2c6d9b7f4dc531142e2725b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event handler function prototype.  <a href="group__nrf__fstorage.html#ga9c8d489cd2c6d9b7f4dc531142e2725b">More...</a><br /></td></tr>
<tr class="separator:ga9c8d489cd2c6d9b7f4dc531142e2725b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1813198950e3e067c62bcce577c23ad3"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structnrf__fstorage__api__s.html">nrf_fstorage_api_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga1813198950e3e067c62bcce577c23ad3">nrf_fstorage_api_t</a></td></tr>
<tr class="memdesc:ga1813198950e3e067c62bcce577c23ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functions provided by the API implementation.  <a href="group__nrf__fstorage.html#ga1813198950e3e067c62bcce577c23ad3">More...</a><br /></td></tr>
<tr class="separator:ga1813198950e3e067c62bcce577c23ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaaf3afe024c1f96a15b21f1241c860d2d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gaaf3afe024c1f96a15b21f1241c860d2d">nrf_fstorage_evt_id_t</a> { <a class="el" href="group__nrf__fstorage.html#ggaaf3afe024c1f96a15b21f1241c860d2dadbc798eedd868d0cc836958c7d6c2661">NRF_FSTORAGE_EVT_READ_RESULT</a>
, <a class="el" href="group__nrf__fstorage.html#ggaaf3afe024c1f96a15b21f1241c860d2da5e5fbe9199debbb6ace7aeaf777733d2">NRF_FSTORAGE_EVT_WRITE_RESULT</a>
, <a class="el" href="group__nrf__fstorage.html#ggaaf3afe024c1f96a15b21f1241c860d2da97fda985ee0e6f94971c354ccf6b3177">NRF_FSTORAGE_EVT_ERASE_RESULT</a>
 }</td></tr>
<tr class="memdesc:gaaf3afe024c1f96a15b21f1241c860d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event IDs.  <a href="group__nrf__fstorage.html#gaaf3afe024c1f96a15b21f1241c860d2d">More...</a><br /></td></tr>
<tr class="separator:gaaf3afe024c1f96a15b21f1241c860d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab79d5600c602c2aa0ac2ddd4e61ed449"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gab79d5600c602c2aa0ac2ddd4e61ed449">nrf_fstorage_init</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> *p_fs, <a class="el" href="group__nrf__fstorage.html#ga1813198950e3e067c62bcce577c23ad3">nrf_fstorage_api_t</a> *p_api, void *p_param)</td></tr>
<tr class="memdesc:gab79d5600c602c2aa0ac2ddd4e61ed449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing fstorage.  <a href="group__nrf__fstorage.html#gab79d5600c602c2aa0ac2ddd4e61ed449">More...</a><br /></td></tr>
<tr class="separator:gab79d5600c602c2aa0ac2ddd4e61ed449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf7a6c5bc9cd258469b828e3e3aa5083"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gaaf7a6c5bc9cd258469b828e3e3aa5083">nrf_fstorage_uninit</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> *p_fs, void *p_param)</td></tr>
<tr class="memdesc:gaaf7a6c5bc9cd258469b828e3e3aa5083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for uninitializing an fstorage instance.  <a href="group__nrf__fstorage.html#gaaf7a6c5bc9cd258469b828e3e3aa5083">More...</a><br /></td></tr>
<tr class="separator:gaaf7a6c5bc9cd258469b828e3e3aa5083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebb4176a9aa38b3398e446efa0592939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gaebb4176a9aa38b3398e446efa0592939">nrf_fstorage_read</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *p_fs, uint32_t addr, void *p_dest, uint32_t len)</td></tr>
<tr class="memdesc:gaebb4176a9aa38b3398e446efa0592939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reading data from flash.  <a href="group__nrf__fstorage.html#gaebb4176a9aa38b3398e446efa0592939">More...</a><br /></td></tr>
<tr class="separator:gaebb4176a9aa38b3398e446efa0592939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a37147f85e54eb049d3cad8bf59c807"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga5a37147f85e54eb049d3cad8bf59c807">nrf_fstorage_write</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *p_fs, uint32_t dest, void const *p_src, uint32_t len, void *p_param)</td></tr>
<tr class="memdesc:ga5a37147f85e54eb049d3cad8bf59c807"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing data to flash.  <a href="group__nrf__fstorage.html#ga5a37147f85e54eb049d3cad8bf59c807">More...</a><br /></td></tr>
<tr class="separator:ga5a37147f85e54eb049d3cad8bf59c807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f2e5019d0e6cbf6e45a51713dd5b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga23f2e5019d0e6cbf6e45a51713dd5b1a">nrf_fstorage_erase</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *p_fs, uint32_t page_addr, uint32_t len, void *p_param)</td></tr>
<tr class="memdesc:ga23f2e5019d0e6cbf6e45a51713dd5b1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for erasing flash pages.  <a href="group__nrf__fstorage.html#ga23f2e5019d0e6cbf6e45a51713dd5b1a">More...</a><br /></td></tr>
<tr class="separator:ga23f2e5019d0e6cbf6e45a51713dd5b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa02ea5ffd845fc4a5325befed1d5275d"><td class="memItemLeft" align="right" valign="top">uint8_t const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gaa02ea5ffd845fc4a5325befed1d5275d">nrf_fstorage_rmap</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *p_fs, uint32_t addr)</td></tr>
<tr class="memdesc:gaa02ea5ffd845fc4a5325befed1d5275d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a flash address to a pointer in the MCU address space that can be dereferenced.  <a href="group__nrf__fstorage.html#gaa02ea5ffd845fc4a5325befed1d5275d">More...</a><br /></td></tr>
<tr class="separator:gaa02ea5ffd845fc4a5325befed1d5275d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30ae28df395751bb059f8da16ad0a4d"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#gab30ae28df395751bb059f8da16ad0a4d">nrf_fstorage_wmap</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *p_fs, uint32_t addr)</td></tr>
<tr class="memdesc:gab30ae28df395751bb059f8da16ad0a4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map a flash address to a pointer in the MCU address space that can be written to.  <a href="group__nrf__fstorage.html#gab30ae28df395751bb059f8da16ad0a4d">More...</a><br /></td></tr>
<tr class="separator:gab30ae28df395751bb059f8da16ad0a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269ea68580fd2c072b602166cdfc16f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__fstorage.html#ga269ea68580fd2c072b602166cdfc16f8">nrf_fstorage_is_busy</a> (<a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *p_fs)</td></tr>
<tr class="memdesc:ga269ea68580fd2c072b602166cdfc16f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for querying the status of fstorage.  <a href="group__nrf__fstorage.html#ga269ea68580fd2c072b602166cdfc16f8">More...</a><br /></td></tr>
<tr class="separator:ga269ea68580fd2c072b602166cdfc16f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flash abstraction library that provides basic read, write, and erase operations. </p>
<p>The fstorage library can be implemented in different ways. Two implementations are provided:</p><ul>
<li>The <a class="el" href="group__nrf__fstorage__sd.html">SoftDevice implementation</a> implements flash access through the SoftDevice.</li>
<li>The <a class="el" href="group__nrf__fstorage__nvmc.html">NVMC implementation</a> implements flash access through the non-volatile memory controller.</li>
</ul>
<p>You can select the implementation that should be used independently for each instance of fstorage. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga0b8f6204f5f7feffac0ffba8bdc159ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b8f6204f5f7feffac0ffba8bdc159ff">&#9670;&nbsp;</a></span>NRF_FSTORAGE_DEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_FSTORAGE_DEF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">inst</td><td>)</td>
          <td>&#160;&#160;&#160;NRF_SECTION_ITEM_REGISTER(fs_data, inst)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for defining an fstorage instance. </p>
<p>Users of fstorage must define an instance variable by using this macro. Each instance is tied to an API implementation and contains information such as the program and erase units for the target flash peripheral. Instance variables are placed in the "fs_data" section of the binary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inst</td><td>A definition of an <a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> variable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8074da070786b1e2cfc51b73454fe0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8074da070786b1e2cfc51b73454fe0d">&#9670;&nbsp;</a></span>NRF_FSTORAGE_INSTANCE_CNT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_FSTORAGE_INSTANCE_CNT&#160;&#160;&#160;<a class="el" href="group__section__vars.html#gaa717ca9ff9f8d78c9857ef88efc91faa">NRF_SECTION_ITEM_COUNT</a>(fs_data, <a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for retrieving the total number of fstorage instances. </p>

</div>
</div>
<a id="ga3e2e00d7399808c38921856f08b1188c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e2e00d7399808c38921856f08b1188c">&#9670;&nbsp;</a></span>NRF_FSTORAGE_INSTANCE_GET</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_FSTORAGE_INSTANCE_GET</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">i</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="group__section__vars.html#ga1169bdbbfb338a99e3dc363202f783d1">NRF_SECTION_ITEM_GET</a>(fs_data, <a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a>, (i))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for retrieving an fstorage instance. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga1813198950e3e067c62bcce577c23ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1813198950e3e067c62bcce577c23ad3">&#9670;&nbsp;</a></span>nrf_fstorage_api_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structnrf__fstorage__api__s.html">nrf_fstorage_api_s</a> <a class="el" href="group__nrf__fstorage.html#ga1813198950e3e067c62bcce577c23ad3">nrf_fstorage_api_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Functions provided by the API implementation. </p>

</div>
</div>
<a id="ga9c8d489cd2c6d9b7f4dc531142e2725b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c8d489cd2c6d9b7f4dc531142e2725b">&#9670;&nbsp;</a></span>nrf_fstorage_evt_handler_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* nrf_fstorage_evt_handler_t) (<a class="el" href="structnrf__fstorage__evt__t.html">nrf_fstorage_evt_t</a> *p_evt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event handler function prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_evt</td><td>The event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gaaf3afe024c1f96a15b21f1241c860d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf3afe024c1f96a15b21f1241c860d2d">&#9670;&nbsp;</a></span>nrf_fstorage_evt_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__nrf__fstorage.html#gaaf3afe024c1f96a15b21f1241c860d2d">nrf_fstorage_evt_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event IDs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaaf3afe024c1f96a15b21f1241c860d2dadbc798eedd868d0cc836958c7d6c2661"></a>NRF_FSTORAGE_EVT_READ_RESULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ggaaf3afe024c1f96a15b21f1241c860d2da5e5fbe9199debbb6ace7aeaf777733d2"></a>NRF_FSTORAGE_EVT_WRITE_RESULT&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__nrf__fstorage.html#ga5a37147f85e54eb049d3cad8bf59c807">nrf_fstorage_write</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaaf3afe024c1f96a15b21f1241c860d2da97fda985ee0e6f94971c354ccf6b3177"></a>NRF_FSTORAGE_EVT_ERASE_RESULT&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__nrf__fstorage.html#ga23f2e5019d0e6cbf6e45a51713dd5b1a">nrf_fstorage_erase</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga23f2e5019d0e6cbf6e45a51713dd5b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23f2e5019d0e6cbf6e45a51713dd5b1a">&#9670;&nbsp;</a></span>nrf_fstorage_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_fstorage_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>page_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for erasing flash pages. </p>
<p>This function erases <code>len</code> pages starting from the page at address <code>page_addr</code>. The erase operation must be initiated on a page boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_fs</td><td>The fstorage instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">page_addr</td><td>Address of the page to erase. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of pages to erase. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_param</td><td>User-defined parameter passed to the event handler (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the operation was accepted. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_fs</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If <code>len</code> is zero. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If the address <code>page_addr</code> is outside the flash memory boundaries specified in <code>p_fs</code>, or if it is unaligned. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>If no memory is available to accept the operation. When using the <a class="el" href="group__nrf__fstorage__sd.html">SoftDevice implementation</a>, this error indicates that the internal queue of operations is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab79d5600c602c2aa0ac2ddd4e61ed449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab79d5600c602c2aa0ac2ddd4e61ed449">&#9670;&nbsp;</a></span>nrf_fstorage_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_fstorage_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__nrf__fstorage.html#ga1813198950e3e067c62bcce577c23ad3">nrf_fstorage_api_t</a> *&#160;</td>
          <td class="paramname"><em>p_api</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing fstorage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_fs</td><td>The fstorage instance to initialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_api</td><td>The API implementation to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_param</td><td>An optional parameter to pass to the implementation-specific API call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If initialization was successful. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_fs</code> or <code>p_api</code> field in <code>p_fs</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If another error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga269ea68580fd2c072b602166cdfc16f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga269ea68580fd2c072b602166cdfc16f8">&#9670;&nbsp;</a></span>nrf_fstorage_is_busy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_fstorage_is_busy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *&#160;</td>
          <td class="paramname"><em>p_fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for querying the status of fstorage. </p>
<p>An uninitialized instance of fstorage is treated as not busy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_fs</td><td>The fstorage instance. Pass NULL to query all instances.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>p_fs</code> is <code>NULL</code>, this function returns true if any fstorage instance is busy or false otherwise. </dd>
<dd>
If <code>p_fs</code> is not <code>NULL</code>, this function returns true if the fstorage instance is busy or false otherwise. </dd></dl>

</div>
</div>
<a id="gaebb4176a9aa38b3398e446efa0592939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaebb4176a9aa38b3398e446efa0592939">&#9670;&nbsp;</a></span>nrf_fstorage_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_fstorage_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reading data from flash. </p>
<p>Copy <code>len</code> bytes from <code>addr</code> to <code>p_dest</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_fs</td><td>The fstorage instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>Address in flash where to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_dest</td><td>Buffer where the data should be copied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data to be copied (in bytes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the operation was successful. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_fs</code> or <code>p_dest</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If <code>len</code> is zero or otherwise invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If the address <code>addr</code> is outside the flash memory boundaries specified in <code>p_fs</code>, or if it is unaligned. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa02ea5ffd845fc4a5325befed1d5275d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa02ea5ffd845fc4a5325befed1d5275d">&#9670;&nbsp;</a></span>nrf_fstorage_rmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t const* nrf_fstorage_rmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a flash address to a pointer in the MCU address space that can be dereferenced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_fs</td><td>The fstorage instance. </td></tr>
    <tr><td class="paramname">addr</td><td>The address to map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A</td><td>pointer to the specified address, or <code>NULL</code> if the address cannot be mapped or if <code>p_fs</code> is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaf7a6c5bc9cd258469b828e3e3aa5083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf7a6c5bc9cd258469b828e3e3aa5083">&#9670;&nbsp;</a></span>nrf_fstorage_uninit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_fstorage_uninit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for uninitializing an fstorage instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_fs</td><td>The fstorage instance to uninitialize. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_param</td><td>An optional parameter to pass to the implementation-specific API call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If uninitialization was successful. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_fs</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INTERNAL</td><td>If another error occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab30ae28df395751bb059f8da16ad0a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30ae28df395751bb059f8da16ad0a4d">&#9670;&nbsp;</a></span>nrf_fstorage_wmap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* nrf_fstorage_wmap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Map a flash address to a pointer in the MCU address space that can be written to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_fs</td><td>The fstorage instance. </td></tr>
    <tr><td class="paramname">addr</td><td>The address to map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A</td><td>pointer to the specified address, or <code>NULL</code> if the address cannot be mapped or if <code>p_fs</code> is <code>NULL</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5a37147f85e54eb049d3cad8bf59c807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a37147f85e54eb049d3cad8bf59c807">&#9670;&nbsp;</a></span>nrf_fstorage_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> nrf_fstorage_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnrf__fstorage__t.html">nrf_fstorage_t</a> const *&#160;</td>
          <td class="paramname"><em>p_fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void const *&#160;</td>
          <td class="paramname"><em>p_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p_param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing data to flash. </p>
<p>Write <code>len</code> bytes from <code>p_src</code> to <code>dest</code>.</p>
<p>When using <a class="el" href="group__nrf__fstorage__sd.html">SoftDevice implementation</a>, the data is written by several calls to sd_flash_write if the length of the data exceeds <a class="el" href="examples_2dfu_2secure__bootloader_2pca10040e__ble_2config_2sdk__config_8h.html#ad6e1d9ce4bc885ad5585f776e831b1dc">NRF_FSTORAGE_SD_MAX_WRITE_SIZE</a> bytes. Only one event is sent upon completion.</p>
<dl class="section note"><dt>Note</dt><dd>The data to be written to flash must be kept in memory until the operation has terminated and an event is received.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_fs</td><td>The fstorage instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Address in flash memory where to write the data. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_src</td><td>Data to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the data (in bytes). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_param</td><td>User-defined parameter passed to the event handler (may be NULL).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NRF_SUCCESS</td><td>If the operation was accepted. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NULL</td><td>If <code>p_fs</code> or <code>p_src</code> is NULL. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_STATE</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_LENGTH</td><td>If <code>len</code> is zero or not a multiple of the program unit, or if it is otherwise invalid. </td></tr>
    <tr><td class="paramname">NRF_ERROR_INVALID_ADDR</td><td>If the address <code>dest</code> is outside the flash memory boundaries specified in <code>p_fs</code>, or if it is unaligned. </td></tr>
    <tr><td class="paramname">NRF_ERROR_NO_MEM</td><td>If no memory is available to accept the operation. When using the <a class="el" href="group__nrf__fstorage__sd.html">SoftDevice implementation</a>, this error indicates that the internal queue of operations is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
