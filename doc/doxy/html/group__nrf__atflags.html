<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: Atomic flags (bitmaps)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__nrf__atflags.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Atomic flags (bitmaps)</div>  </div>
</div><!--header-->
<div class="contents">

<p>@tagAPI52 This module implements atomic flags as bitmaps.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9f5c51af723761fb0114e341f18c5ca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga9f5c51af723761fb0114e341f18c5ca0">NRF_ATFLAGS_FLAGS_PER_ELEMENT</a>&#160;&#160;&#160;(sizeof(<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a>) * 8)</td></tr>
<tr class="memdesc:ga9f5c51af723761fb0114e341f18c5ca0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of flags per <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a>.  <a href="group__nrf__atflags.html#ga9f5c51af723761fb0114e341f18c5ca0">More...</a><br /></td></tr>
<tr class="separator:ga9f5c51af723761fb0114e341f18c5ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f2af2fa5ef85445bdc4c003a69541fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga6f2af2fa5ef85445bdc4c003a69541fa">NRF_ATFLAGS_ARRAY_LEN</a>(flag_count)&#160;&#160;&#160;((flag_count - 1) / <a class="el" href="group__nrf__atflags.html#ga9f5c51af723761fb0114e341f18c5ca0">NRF_ATFLAGS_FLAGS_PER_ELEMENT</a>) + 1</td></tr>
<tr class="memdesc:ga6f2af2fa5ef85445bdc4c003a69541fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for the length of an array of <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> needed to keep <code>flag_count</code> flags.  <a href="group__nrf__atflags.html#ga6f2af2fa5ef85445bdc4c003a69541fa">More...</a><br /></td></tr>
<tr class="separator:ga6f2af2fa5ef85445bdc4c003a69541fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga561c7d03aaf2c989c11bc21bdbf78e51"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga561c7d03aaf2c989c11bc21bdbf78e51">NRF_ATFLAGS_DEF</a>(_name,  flag_count)&#160;&#160;&#160;    <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> _name[<a class="el" href="group__nrf__atflags.html#ga6f2af2fa5ef85445bdc4c003a69541fa">NRF_ATFLAGS_ARRAY_LEN</a>((flag_count))] = {0}</td></tr>
<tr class="memdesc:ga561c7d03aaf2c989c11bc21bdbf78e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for declaring a flag array with the right size and initial value.  <a href="group__nrf__atflags.html#ga561c7d03aaf2c989c11bc21bdbf78e51">More...</a><br /></td></tr>
<tr class="separator:ga561c7d03aaf2c989c11bc21bdbf78e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae16ecc46b087c5a2539f23c96d7e355c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#gae16ecc46b087c5a2539f23c96d7e355c">NRF_ATFLAGS_DEF_MEMBER</a>(_name,  flag_count)&#160;&#160;&#160;    <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> _name[<a class="el" href="group__nrf__atflags.html#ga6f2af2fa5ef85445bdc4c003a69541fa">NRF_ATFLAGS_ARRAY_LEN</a>((flag_count))]</td></tr>
<tr class="memdesc:gae16ecc46b087c5a2539f23c96d7e355c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro for declaring a flag array with the right size as a member of a struct.  <a href="group__nrf__atflags.html#gae16ecc46b087c5a2539f23c96d7e355c">More...</a><br /></td></tr>
<tr class="separator:gae16ecc46b087c5a2539f23c96d7e355c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaec8e6a0165a2ce1c13fb47e5b02b6e0a"><td class="memItemLeft" align="right" valign="top">typedef volatile uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a></td></tr>
<tr class="memdesc:gaec8e6a0165a2ce1c13fb47e5b02b6e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of atomic flags.  <a href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">More...</a><br /></td></tr>
<tr class="separator:gaec8e6a0165a2ce1c13fb47e5b02b6e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa020cddf61c0f419a17c4ac6bc0ce851"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#gaa020cddf61c0f419a17c4ac6bc0ce851">nrf_atflags_init</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flags_array_len, uint32_t flag_count)</td></tr>
<tr class="memdesc:gaa020cddf61c0f419a17c4ac6bc0ce851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for safely initializing a flag array to 0.  <a href="group__nrf__atflags.html#gaa020cddf61c0f419a17c4ac6bc0ce851">More...</a><br /></td></tr>
<tr class="separator:gaa020cddf61c0f419a17c4ac6bc0ce851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e086cda5edc720b46fa13ecbc076394"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga3e086cda5edc720b46fa13ecbc076394">nrf_atflags_set</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flag_index)</td></tr>
<tr class="memdesc:ga3e086cda5edc720b46fa13ecbc076394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for atomically setting a flag to 1.  <a href="group__nrf__atflags.html#ga3e086cda5edc720b46fa13ecbc076394">More...</a><br /></td></tr>
<tr class="separator:ga3e086cda5edc720b46fa13ecbc076394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad89d22a71ec4636e553a832fa4d4d01b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#gad89d22a71ec4636e553a832fa4d4d01b">nrf_atflags_fetch_set</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flag_index)</td></tr>
<tr class="memdesc:gad89d22a71ec4636e553a832fa4d4d01b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for atomically setting a flag to 1, returning the previous value of the flag.  <a href="group__nrf__atflags.html#gad89d22a71ec4636e553a832fa4d4d01b">More...</a><br /></td></tr>
<tr class="separator:gad89d22a71ec4636e553a832fa4d4d01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac52e3e802613a8a8f81a752d4e28b6f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#gac52e3e802613a8a8f81a752d4e28b6f6">nrf_atflags_clear</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flag_index)</td></tr>
<tr class="memdesc:gac52e3e802613a8a8f81a752d4e28b6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for atomically setting a flag to 0.  <a href="group__nrf__atflags.html#gac52e3e802613a8a8f81a752d4e28b6f6">More...</a><br /></td></tr>
<tr class="separator:gac52e3e802613a8a8f81a752d4e28b6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31b4932e7a61cdf7d5d2c8e376cd4436"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga31b4932e7a61cdf7d5d2c8e376cd4436">nrf_atflags_fetch_clear</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flag_index)</td></tr>
<tr class="memdesc:ga31b4932e7a61cdf7d5d2c8e376cd4436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for atomically setting a flag to 0, returning the previous value of the flag.  <a href="group__nrf__atflags.html#ga31b4932e7a61cdf7d5d2c8e376cd4436">More...</a><br /></td></tr>
<tr class="separator:ga31b4932e7a61cdf7d5d2c8e376cd4436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43dce365b655ae52d99c0ef37d9a3334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga43dce365b655ae52d99c0ef37d9a3334">nrf_atflags_get</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> const *p_flags, uint32_t flag_index)</td></tr>
<tr class="memdesc:ga43dce365b655ae52d99c0ef37d9a3334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for getting the value of a flag in a flag array.  <a href="group__nrf__atflags.html#ga43dce365b655ae52d99c0ef37d9a3334">More...</a><br /></td></tr>
<tr class="separator:ga43dce365b655ae52d99c0ef37d9a3334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f7f880092ca9775089c127ccba20048"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga0f7f880092ca9775089c127ccba20048">nrf_atflags_find_and_set_flag</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flag_count)</td></tr>
<tr class="memdesc:ga0f7f880092ca9775089c127ccba20048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a flag with value 0, and atomically setting it to one.  <a href="group__nrf__atflags.html#ga0f7f880092ca9775089c127ccba20048">More...</a><br /></td></tr>
<tr class="separator:ga0f7f880092ca9775089c127ccba20048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aacb081619e0078ba1aa971e58c7c77"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__nrf__atflags.html#ga5aacb081619e0078ba1aa971e58c7c77">nrf_atflags_find_and_clear_flag</a> (<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *p_flags, uint32_t flag_count)</td></tr>
<tr class="memdesc:ga5aacb081619e0078ba1aa971e58c7c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for finding a flag with value 1, and atomically clearing it to 0.  <a href="group__nrf__atflags.html#ga5aacb081619e0078ba1aa971e58c7c77">More...</a><br /></td></tr>
<tr class="separator:ga5aacb081619e0078ba1aa971e58c7c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>@tagAPI52 This module implements atomic flags as bitmaps. </p>
<p>Operations on the individual flags are atomic, meaning that you are always sure that the flag is set to the desired value, and you always know what value was there before. You also know that no other flags were affected by the operation.</p>
<p>Operations on the entire flag collection are NOT atomic. This essentially means that you can't know the order in which operations on different flags happened, and you can't know the state of the entire flag collection at any instant. These limitations can be overcome by protecting operations with a mutex. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga6f2af2fa5ef85445bdc4c003a69541fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f2af2fa5ef85445bdc4c003a69541fa">&#9670;&nbsp;</a></span>NRF_ATFLAGS_ARRAY_LEN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_ATFLAGS_ARRAY_LEN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flag_count</td><td>)</td>
          <td>&#160;&#160;&#160;((flag_count - 1) / <a class="el" href="group__nrf__atflags.html#ga9f5c51af723761fb0114e341f18c5ca0">NRF_ATFLAGS_FLAGS_PER_ELEMENT</a>) + 1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for the length of an array of <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> needed to keep <code>flag_count</code> flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag_count</td><td>Number of flags to keep in a flag array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the array needed to house flag_count flags. </dd></dl>

</div>
</div>
<a id="ga561c7d03aaf2c989c11bc21bdbf78e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga561c7d03aaf2c989c11bc21bdbf78e51">&#9670;&nbsp;</a></span>NRF_ATFLAGS_DEF</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_ATFLAGS_DEF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flag_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> _name[<a class="el" href="group__nrf__atflags.html#ga6f2af2fa5ef85445bdc4c003a69541fa">NRF_ATFLAGS_ARRAY_LEN</a>((flag_count))] = {0}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for declaring a flag array with the right size and initial value. </p>
<dl class="section note"><dt>Note</dt><dd>When using this macro, no call to <a class="el" href="group__nrf__atflags.html#gaa020cddf61c0f419a17c4ac6bc0ce851">nrf_atflags_init</a> is necessary for this array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name to be given to the array. </td></tr>
    <tr><td class="paramname">flag_count</td><td>Number of flags to be kept in the flag array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag array definition. </dd></dl>

</div>
</div>
<a id="gae16ecc46b087c5a2539f23c96d7e355c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae16ecc46b087c5a2539f23c96d7e355c">&#9670;&nbsp;</a></span>NRF_ATFLAGS_DEF_MEMBER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_ATFLAGS_DEF_MEMBER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">flag_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;    <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> _name[<a class="el" href="group__nrf__atflags.html#ga6f2af2fa5ef85445bdc4c003a69541fa">NRF_ATFLAGS_ARRAY_LEN</a>((flag_count))]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro for declaring a flag array with the right size as a member of a struct. </p>
<dl class="section note"><dt>Note</dt><dd>When using this macro, make sure to set the array to 0 or use <a class="el" href="group__nrf__atflags.html#gaa020cddf61c0f419a17c4ac6bc0ce851">nrf_atflags_init</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_name</td><td>Name to be given to the array. </td></tr>
    <tr><td class="paramname">flag_count</td><td>Number of flags to be kept in the flag array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag array definition. </dd></dl>

</div>
</div>
<a id="ga9f5c51af723761fb0114e341f18c5ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f5c51af723761fb0114e341f18c5ca0">&#9670;&nbsp;</a></span>NRF_ATFLAGS_FLAGS_PER_ELEMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NRF_ATFLAGS_FLAGS_PER_ELEMENT&#160;&#160;&#160;(sizeof(<a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a>) * 8)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of flags per <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gaec8e6a0165a2ce1c13fb47e5b02b6e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">&#9670;&nbsp;</a></span>nrf_atflags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef volatile uint32_t <a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array of atomic flags. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac52e3e802613a8a8f81a752d4e28b6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac52e3e802613a8a8f81a752d4e28b6f6">&#9670;&nbsp;</a></span>nrf_atflags_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_atflags_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for atomically setting a flag to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_index</td><td>Index of the flag in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31b4932e7a61cdf7d5d2c8e376cd4436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31b4932e7a61cdf7d5d2c8e376cd4436">&#9670;&nbsp;</a></span>nrf_atflags_fetch_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_atflags_fetch_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for atomically setting a flag to 0, returning the previous value of the flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_index</td><td>Index of the flag in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Old flag value. </dd></dl>

</div>
</div>
<a id="gad89d22a71ec4636e553a832fa4d4d01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad89d22a71ec4636e553a832fa4d4d01b">&#9670;&nbsp;</a></span>nrf_atflags_fetch_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_atflags_fetch_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for atomically setting a flag to 1, returning the previous value of the flag. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_index</td><td>Index of the flag in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Old flag value. </dd></dl>

</div>
</div>
<a id="ga5aacb081619e0078ba1aa971e58c7c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5aacb081619e0078ba1aa971e58c7c77">&#9670;&nbsp;</a></span>nrf_atflags_find_and_clear_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_atflags_find_and_clear_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for finding a flag with value 1, and atomically clearing it to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_count</td><td>The number of flags in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the set flag that has been cleared. </dd></dl>

</div>
</div>
<a id="ga0f7f880092ca9775089c127ccba20048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f7f880092ca9775089c127ccba20048">&#9670;&nbsp;</a></span>nrf_atflags_find_and_set_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_atflags_find_and_set_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for finding a flag with value 0, and atomically setting it to one. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_count</td><td>Number of flags in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the cleared flag that has been set. </dd></dl>

</div>
</div>
<a id="ga43dce365b655ae52d99c0ef37d9a3334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga43dce365b655ae52d99c0ef37d9a3334">&#9670;&nbsp;</a></span>nrf_atflags_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool nrf_atflags_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> const *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for getting the value of a flag in a flag array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_index</td><td>Index of the flag in the array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Flag value. </dd></dl>

</div>
</div>
<a id="gaa020cddf61c0f419a17c4ac6bc0ce851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa020cddf61c0f419a17c4ac6bc0ce851">&#9670;&nbsp;</a></span>nrf_atflags_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t nrf_atflags_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags_array_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for safely initializing a flag array to 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_flags</td><td>Flag array to initialize. </td></tr>
    <tr><td class="paramname">flags_array_len</td><td>Length of <code>p_flags</code>. </td></tr>
    <tr><td class="paramname">flag_count</td><td>Number of flags to be kept in the flag array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>if the given length is not sufficient to house <code>flag_count</code> flags in the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If successful: The actual length required. </dd></dl>

</div>
</div>
<a id="ga3e086cda5edc720b46fa13ecbc076394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e086cda5edc720b46fa13ecbc076394">&#9670;&nbsp;</a></span>nrf_atflags_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void nrf_atflags_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__nrf__atflags.html#gaec8e6a0165a2ce1c13fb47e5b02b6e0a">nrf_atflags_t</a> *&#160;</td>
          <td class="paramname"><em>p_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flag_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for atomically setting a flag to 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_flags</td><td>Atomic flag array. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flag_index</td><td>Index of the flag in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
