<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smart Weighing Scale: Flash Data Storage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smart Weighing Scale
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/weighing_scale_nrf>https://github.com/IoTReady/weighing_scale_nrf</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__fds.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Flash Data Storage</div>  </div>
</div><!--header-->
<div class="contents">

<p>Flash Data Storage (FDS).  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__header__t.html">fds_header_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The record metadata as stored in flash.  <a href="structfds__header__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The record descriptor structure that is used to manipulate records.  <a href="structfds__record__desc__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__flash__record__t.html">fds_flash_record_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that can be used to read the contents of a record stored in flash.  <a href="structfds__flash__record__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__record__t.html">fds_record_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A record to be written to flash.  <a href="structfds__record__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A token to a reserved space in flash, created by <a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a>.  <a href="structfds__reserve__token__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__find__token__t.html">fds_find_token_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A token to keep information about the progress of <a class="el" href="group__fds.html#ga15112e682cc2c4771945fcf5816e3b1b">fds_record_find</a>, <a class="el" href="group__fds.html#gad5a5ad980e0b2b27a693ca5c0296e9c2">fds_record_find_by_key</a>, and <a class="el" href="group__fds.html#gaa5bc8844b42493c8d9cdc02d245718fc">fds_record_find_in_file</a>.  <a href="structfds__find__token__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__evt__t.html">fds_evt_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An FDS event.  <a href="structfds__evt__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfds__stat__t.html">fds_stat_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">File system statistics.  <a href="structfds__stat__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gade414e234180e1983d44341bce184853"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gade414e234180e1983d44341bce184853">FDS_FILE_ID_INVALID</a>&#160;&#160;&#160;(0xFFFF)</td></tr>
<tr class="memdesc:gade414e234180e1983d44341bce184853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invalid file ID.  <a href="group__fds.html#gade414e234180e1983d44341bce184853">More...</a><br /></td></tr>
<tr class="separator:gade414e234180e1983d44341bce184853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab855b564bf9f4cac404a71a16aca2906"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gab855b564bf9f4cac404a71a16aca2906">FDS_RECORD_KEY_DIRTY</a>&#160;&#160;&#160;(0x0000)</td></tr>
<tr class="memdesc:gab855b564bf9f4cac404a71a16aca2906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record key for deleted records.  <a href="group__fds.html#gab855b564bf9f4cac404a71a16aca2906">More...</a><br /></td></tr>
<tr class="separator:gab855b564bf9f4cac404a71a16aca2906"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5d6c35d06f7d73bf0a2458a553f52fea"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga5d6c35d06f7d73bf0a2458a553f52fea">fds_cb_t</a>) (<a class="el" href="structfds__evt__t.html">fds_evt_t</a> const *p_evt)</td></tr>
<tr class="memdesc:ga5d6c35d06f7d73bf0a2458a553f52fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">FDS event handler function prototype.  <a href="group__fds.html#ga5d6c35d06f7d73bf0a2458a553f52fea">More...</a><br /></td></tr>
<tr class="separator:ga5d6c35d06f7d73bf0a2458a553f52fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9334a5b9057f32da96db9b5c6a045d67"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67ae489119d0d66fd6020d243e86747bed3">FDS_SUCCESS</a> = NRF_SUCCESS
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67ae0cac73c027cae1ae1847c3611f89826">FDS_ERR_OPERATION_TIMEOUT</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67af922787772a50e2d4f946febd64d444f">FDS_ERR_NOT_INITIALIZED</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a969316942346b0484fbe837cba880a73">FDS_ERR_UNALIGNED_ADDR</a>
, <br />
&#160;&#160;<a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a3479c684a9cd297abb3e5cf8b1878470">FDS_ERR_INVALID_ARG</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a8d6327a8f8002bd4cb38a7334e0f124a">FDS_ERR_NULL_ARG</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a8f3e14ab2fa0f525e63d6824134d1e21">FDS_ERR_NO_OPEN_RECORDS</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67abb56c173c55f594c5c31e11da12da5a3">FDS_ERR_NO_SPACE_IN_FLASH</a>
, <br />
&#160;&#160;<a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a5feceebf00bf1ec9a624a6248637d719">FDS_ERR_NO_SPACE_IN_QUEUES</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a855da459eedc2a9950da8be24fe525d7">FDS_ERR_RECORD_TOO_LARGE</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a04e28034cadb17722f619a2aed3dfda6">FDS_ERR_NOT_FOUND</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a4cefb883ac53148fe36c9775b4ff67b9">FDS_ERR_NO_PAGES</a>
, <br />
&#160;&#160;<a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a5307547005ec8cf01d1df2b7c7e6c2a3">FDS_ERR_USER_LIMIT_REACHED</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67aedea4ee7787c5ecefba66642afe14ab9">FDS_ERR_CRC_CHECK_FAILED</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a9808a8eff5afb2be4b138133c4128b2a">FDS_ERR_BUSY</a>
, <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67a189551024a6826c8fd6a3e1157c1ebab">FDS_ERR_INTERNAL</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9334a5b9057f32da96db9b5c6a045d67"><td class="mdescLeft">&#160;</td><td class="mdescRight">FDS return values.  <a href="group__fds.html#ga9334a5b9057f32da96db9b5c6a045d67">More...</a><br /></td></tr>
<tr class="separator:ga9334a5b9057f32da96db9b5c6a045d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9374d0e6608b9b07940401b407617f8d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga9374d0e6608b9b07940401b407617f8d">fds_evt_id_t</a> { <br />
&#160;&#160;<a class="el" href="group__fds.html#gga9374d0e6608b9b07940401b407617f8da4147e2842827ca524ed04dc066ccb25d">FDS_EVT_INIT</a>
, <a class="el" href="group__fds.html#gga9374d0e6608b9b07940401b407617f8dadec23fb956d52a05ae1dbb64c68fad2d">FDS_EVT_WRITE</a>
, <a class="el" href="group__fds.html#gga9374d0e6608b9b07940401b407617f8dadeaba2d3641cb94365a6a641bacdd367">FDS_EVT_UPDATE</a>
, <a class="el" href="group__fds.html#gga9374d0e6608b9b07940401b407617f8dacf428d0ef9ce66354b569f2bae9264f0">FDS_EVT_DEL_RECORD</a>
, <br />
&#160;&#160;<a class="el" href="group__fds.html#gga9374d0e6608b9b07940401b407617f8da121a81e149c30cca53b1bd127af9f7e8">FDS_EVT_DEL_FILE</a>
, <a class="el" href="group__fds.html#gga9374d0e6608b9b07940401b407617f8dab2b29ea4c2572f34c6f4f164ea7db732">FDS_EVT_GC</a>
<br />
 }</td></tr>
<tr class="memdesc:ga9374d0e6608b9b07940401b407617f8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">FDS event IDs.  <a href="group__fds.html#ga9374d0e6608b9b07940401b407617f8d">More...</a><br /></td></tr>
<tr class="separator:ga9374d0e6608b9b07940401b407617f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadc98fdddd6201988f408116ee0dc4fe5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gadc98fdddd6201988f408116ee0dc4fe5">fds_register</a> (<a class="el" href="group__fds.html#ga5d6c35d06f7d73bf0a2458a553f52fea">fds_cb_t</a> cb)</td></tr>
<tr class="memdesc:gadc98fdddd6201988f408116ee0dc4fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for registering an FDS event handler.  <a href="group__fds.html#gadc98fdddd6201988f408116ee0dc4fe5">More...</a><br /></td></tr>
<tr class="separator:gadc98fdddd6201988f408116ee0dc4fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2382947318f107a9c8d08a9a5916ccf4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga2382947318f107a9c8d08a9a5916ccf4">fds_init</a> (void)</td></tr>
<tr class="memdesc:ga2382947318f107a9c8d08a9a5916ccf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for initializing the module.  <a href="group__fds.html#ga2382947318f107a9c8d08a9a5916ccf4">More...</a><br /></td></tr>
<tr class="separator:ga2382947318f107a9c8d08a9a5916ccf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0114083241dc287c7145fe113c9adc2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga0114083241dc287c7145fe113c9adc2c">fds_record_write</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__record__t.html">fds_record_t</a> const *p_record)</td></tr>
<tr class="memdesc:ga0114083241dc287c7145fe113c9adc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing a record to flash.  <a href="group__fds.html#ga0114083241dc287c7145fe113c9adc2c">More...</a><br /></td></tr>
<tr class="separator:ga0114083241dc287c7145fe113c9adc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee0de6ed4af09fd7d4b3ae7751546ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a> (<a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a> *p_token, uint16_t length_words)</td></tr>
<tr class="memdesc:ga3ee0de6ed4af09fd7d4b3ae7751546ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for reserving space in flash.  <a href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">More...</a><br /></td></tr>
<tr class="separator:ga3ee0de6ed4af09fd7d4b3ae7751546ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59947ed9ab3156d32b284a05783d9b3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga59947ed9ab3156d32b284a05783d9b3e">fds_reserve_cancel</a> (<a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga59947ed9ab3156d32b284a05783d9b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for canceling an <a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a> operation.  <a href="group__fds.html#ga59947ed9ab3156d32b284a05783d9b3e">More...</a><br /></td></tr>
<tr class="separator:ga59947ed9ab3156d32b284a05783d9b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39ce61a46549ddc2340f1841c0c4aee2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga39ce61a46549ddc2340f1841c0c4aee2">fds_record_write_reserved</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__record__t.html">fds_record_t</a> const *p_record, <a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a> const *p_token)</td></tr>
<tr class="memdesc:ga39ce61a46549ddc2340f1841c0c4aee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for writing a record to a space in flash that was reserved using <a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a>.  <a href="group__fds.html#ga39ce61a46549ddc2340f1841c0c4aee2">More...</a><br /></td></tr>
<tr class="separator:ga39ce61a46549ddc2340f1841c0c4aee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97cabe15afd74024e4250e931c720cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gaf97cabe15afd74024e4250e931c720cd">fds_record_delete</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc)</td></tr>
<tr class="memdesc:gaf97cabe15afd74024e4250e931c720cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for deleting a record.  <a href="group__fds.html#gaf97cabe15afd74024e4250e931c720cd">More...</a><br /></td></tr>
<tr class="separator:gaf97cabe15afd74024e4250e931c720cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b4618e5f1a5a86296db525508f5692a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga8b4618e5f1a5a86296db525508f5692a">fds_file_delete</a> (uint16_t file_id)</td></tr>
<tr class="memdesc:ga8b4618e5f1a5a86296db525508f5692a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for deleting all records in a file.  <a href="group__fds.html#ga8b4618e5f1a5a86296db525508f5692a">More...</a><br /></td></tr>
<tr class="separator:ga8b4618e5f1a5a86296db525508f5692a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa71e86ec4e3022063eb08c3411636561"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gaa71e86ec4e3022063eb08c3411636561">fds_record_update</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__record__t.html">fds_record_t</a> const *p_record)</td></tr>
<tr class="memdesc:gaa71e86ec4e3022063eb08c3411636561"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for updating a record.  <a href="group__fds.html#gaa71e86ec4e3022063eb08c3411636561">More...</a><br /></td></tr>
<tr class="separator:gaa71e86ec4e3022063eb08c3411636561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71a586b6017690b888ead2a8bd04caee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga71a586b6017690b888ead2a8bd04caee">fds_record_iterate</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga71a586b6017690b888ead2a8bd04caee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for iterating through all records in flash.  <a href="group__fds.html#ga71a586b6017690b888ead2a8bd04caee">More...</a><br /></td></tr>
<tr class="separator:ga71a586b6017690b888ead2a8bd04caee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15112e682cc2c4771945fcf5816e3b1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga15112e682cc2c4771945fcf5816e3b1b">fds_record_find</a> (uint16_t file_id, uint16_t record_key, <a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *p_token)</td></tr>
<tr class="memdesc:ga15112e682cc2c4771945fcf5816e3b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for searching for records with a given record key in a file.  <a href="group__fds.html#ga15112e682cc2c4771945fcf5816e3b1b">More...</a><br /></td></tr>
<tr class="separator:ga15112e682cc2c4771945fcf5816e3b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5a5ad980e0b2b27a693ca5c0296e9c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gad5a5ad980e0b2b27a693ca5c0296e9c2">fds_record_find_by_key</a> (uint16_t record_key, <a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *p_token)</td></tr>
<tr class="memdesc:gad5a5ad980e0b2b27a693ca5c0296e9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for searching for records with a given record key.  <a href="group__fds.html#gad5a5ad980e0b2b27a693ca5c0296e9c2">More...</a><br /></td></tr>
<tr class="separator:gad5a5ad980e0b2b27a693ca5c0296e9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5bc8844b42493c8d9cdc02d245718fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gaa5bc8844b42493c8d9cdc02d245718fc">fds_record_find_in_file</a> (uint16_t file_id, <a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *p_token)</td></tr>
<tr class="memdesc:gaa5bc8844b42493c8d9cdc02d245718fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for searching for any record in a file.  <a href="group__fds.html#gaa5bc8844b42493c8d9cdc02d245718fc">More...</a><br /></td></tr>
<tr class="separator:gaa5bc8844b42493c8d9cdc02d245718fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab718add23b30b0e663e48a781645879f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gab718add23b30b0e663e48a781645879f">fds_record_open</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, <a class="el" href="structfds__flash__record__t.html">fds_flash_record_t</a> *p_flash_record)</td></tr>
<tr class="memdesc:gab718add23b30b0e663e48a781645879f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for opening a record for reading.  <a href="group__fds.html#gab718add23b30b0e663e48a781645879f">More...</a><br /></td></tr>
<tr class="separator:gab718add23b30b0e663e48a781645879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8d958ecd339e9d2fc3dba40c4503eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gaf8d958ecd339e9d2fc3dba40c4503eea">fds_record_close</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc)</td></tr>
<tr class="memdesc:gaf8d958ecd339e9d2fc3dba40c4503eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for closing a record.  <a href="group__fds.html#gaf8d958ecd339e9d2fc3dba40c4503eea">More...</a><br /></td></tr>
<tr class="separator:gaf8d958ecd339e9d2fc3dba40c4503eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90285f376c435c64b352023e725b7ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga90285f376c435c64b352023e725b7ebb">fds_gc</a> (void)</td></tr>
<tr class="memdesc:ga90285f376c435c64b352023e725b7ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for running garbage collection.  <a href="group__fds.html#ga90285f376c435c64b352023e725b7ebb">More...</a><br /></td></tr>
<tr class="separator:ga90285f376c435c64b352023e725b7ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68a38771138f19c40d8ef9f61582a155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga68a38771138f19c40d8ef9f61582a155">fds_descriptor_from_rec_id</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *p_desc, uint32_t record_id)</td></tr>
<tr class="memdesc:ga68a38771138f19c40d8ef9f61582a155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for obtaining a descriptor from a record ID.  <a href="group__fds.html#ga68a38771138f19c40d8ef9f61582a155">More...</a><br /></td></tr>
<tr class="separator:ga68a38771138f19c40d8ef9f61582a155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d56475359f7fd1343d9815dd5b4b310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga5d56475359f7fd1343d9815dd5b4b310">fds_record_id_from_desc</a> (<a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> const *p_desc, uint32_t *p_record_id)</td></tr>
<tr class="memdesc:ga5d56475359f7fd1343d9815dd5b4b310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for obtaining a record ID from a record descriptor.  <a href="group__fds.html#ga5d56475359f7fd1343d9815dd5b4b310">More...</a><br /></td></tr>
<tr class="separator:ga5d56475359f7fd1343d9815dd5b4b310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d3f04e9755408293408be377f7eeaf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga5d3f04e9755408293408be377f7eeaf9">fds_stat</a> (<a class="el" href="structfds__stat__t.html">fds_stat_t</a> *p_stat)</td></tr>
<tr class="memdesc:ga5d3f04e9755408293408be377f7eeaf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for retrieving file system statistics.  <a href="group__fds.html#ga5d3f04e9755408293408be377f7eeaf9">More...</a><br /></td></tr>
<tr class="separator:ga5d3f04e9755408293408be377f7eeaf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga4dd225920a1695db74f70a5697ea2cd5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#ga4dd225920a1695db74f70a5697ea2cd5">ANON_UNIONS_ENABLE</a></td></tr>
<tr class="separator:ga4dd225920a1695db74f70a5697ea2cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae00d56ea54d55148b7a9db7f786dc655"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fds.html#gae00d56ea54d55148b7a9db7f786dc655">ANON_UNIONS_DISABLE</a></td></tr>
<tr class="separator:gae00d56ea54d55148b7a9db7f786dc655"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Flash Data Storage (FDS). </p>
<p>Copyright (c) 2015 - 2018, Nordic Semiconductor ASA</p>
<p>All rights reserved.</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form, except as embedded into a Nordic Semiconductor ASA integrated circuit in a product or a software update for such product, must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
<li>Neither the name of Nordic Semiconductor ASA nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li>
<li>This software, with or without modification, must only be used with a Nordic Semiconductor ASA integrated circuit.</li>
<li>Any software provided in binary form under this license must not be reverse engineered, decompiled, modified and/or disassembled.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY NORDIC SEMICONDUCTOR ASA "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGEMENT, AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NORDIC SEMICONDUCTOR ASA OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p>
<p>Flash Data Storage is a minimalistic, record-oriented file system for the on-chip flash. Files are stored as a collection of records of variable length. FDS supports synchronous read operations and asynchronous write operations (write, update, and delete). FDS can be used from multiple threads. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gade414e234180e1983d44341bce184853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade414e234180e1983d44341bce184853">&#9670;&nbsp;</a></span>FDS_FILE_ID_INVALID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FDS_FILE_ID_INVALID&#160;&#160;&#160;(0xFFFF)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invalid file ID. </p>
<p>This value must not be used as a file ID by the application. </p>

</div>
</div>
<a id="gab855b564bf9f4cac404a71a16aca2906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab855b564bf9f4cac404a71a16aca2906">&#9670;&nbsp;</a></span>FDS_RECORD_KEY_DIRTY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FDS_RECORD_KEY_DIRTY&#160;&#160;&#160;(0x0000)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record key for deleted records. </p>
<p>This key is used to flag a record as "dirty", which means that it should be removed during the next garbage collection. This value must not be used as a record key by the application. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5d6c35d06f7d73bf0a2458a553f52fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d6c35d06f7d73bf0a2458a553f52fea">&#9670;&nbsp;</a></span>fds_cb_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fds_cb_t) (<a class="el" href="structfds__evt__t.html">fds_evt_t</a> const *p_evt)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FDS event handler function prototype. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p_evt</td><td>The event. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga9334a5b9057f32da96db9b5c6a045d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9334a5b9057f32da96db9b5c6a045d67">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FDS return values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67ae489119d0d66fd6020d243e86747bed3"></a>FDS_SUCCESS&#160;</td><td class="fielddoc"><p>The operation completed successfully. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67ae0cac73c027cae1ae1847c3611f89826"></a>FDS_ERR_OPERATION_TIMEOUT&#160;</td><td class="fielddoc"><p>Error. The operation timed out. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67af922787772a50e2d4f946febd64d444f"></a>FDS_ERR_NOT_INITIALIZED&#160;</td><td class="fielddoc"><p>Error. The module has not been initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a969316942346b0484fbe837cba880a73"></a>FDS_ERR_UNALIGNED_ADDR&#160;</td><td class="fielddoc"><p>Error. The input data is not aligned to a word boundary. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a3479c684a9cd297abb3e5cf8b1878470"></a>FDS_ERR_INVALID_ARG&#160;</td><td class="fielddoc"><p>Error. The parameter contains invalid data. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a8d6327a8f8002bd4cb38a7334e0f124a"></a>FDS_ERR_NULL_ARG&#160;</td><td class="fielddoc"><p>Error. The parameter is NULL. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a8f3e14ab2fa0f525e63d6824134d1e21"></a>FDS_ERR_NO_OPEN_RECORDS&#160;</td><td class="fielddoc"><p>Error. The record is not open, so it cannot be closed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67abb56c173c55f594c5c31e11da12da5a3"></a>FDS_ERR_NO_SPACE_IN_FLASH&#160;</td><td class="fielddoc"><p>Error. There is no space in flash memory. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a5feceebf00bf1ec9a624a6248637d719"></a>FDS_ERR_NO_SPACE_IN_QUEUES&#160;</td><td class="fielddoc"><p>Error. There is no space in the internal queues. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a855da459eedc2a9950da8be24fe525d7"></a>FDS_ERR_RECORD_TOO_LARGE&#160;</td><td class="fielddoc"><p>Error. The record exceeds the maximum allowed size. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a04e28034cadb17722f619a2aed3dfda6"></a>FDS_ERR_NOT_FOUND&#160;</td><td class="fielddoc"><p>Error. The record was not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a4cefb883ac53148fe36c9775b4ff67b9"></a>FDS_ERR_NO_PAGES&#160;</td><td class="fielddoc"><p>Error. No flash pages are available. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a5307547005ec8cf01d1df2b7c7e6c2a3"></a>FDS_ERR_USER_LIMIT_REACHED&#160;</td><td class="fielddoc"><p>Error. The maximum number of users has been reached. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67aedea4ee7787c5ecefba66642afe14ab9"></a>FDS_ERR_CRC_CHECK_FAILED&#160;</td><td class="fielddoc"><p>Error. The CRC check failed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a9808a8eff5afb2be4b138133c4128b2a"></a>FDS_ERR_BUSY&#160;</td><td class="fielddoc"><p>Error. The underlying flash subsystem was busy. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9334a5b9057f32da96db9b5c6a045d67a189551024a6826c8fd6a3e1157c1ebab"></a>FDS_ERR_INTERNAL&#160;</td><td class="fielddoc"><p>Error. An internal error occurred. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9374d0e6608b9b07940401b407617f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9374d0e6608b9b07940401b407617f8d">&#9670;&nbsp;</a></span>fds_evt_id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__fds.html#ga9374d0e6608b9b07940401b407617f8d">fds_evt_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>FDS event IDs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9374d0e6608b9b07940401b407617f8da4147e2842827ca524ed04dc066ccb25d"></a>FDS_EVT_INIT&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__fds.html#ga2382947318f107a9c8d08a9a5916ccf4">fds_init</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9374d0e6608b9b07940401b407617f8dadec23fb956d52a05ae1dbb64c68fad2d"></a>FDS_EVT_WRITE&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__fds.html#ga0114083241dc287c7145fe113c9adc2c">fds_record_write</a> and <a class="el" href="group__fds.html#ga39ce61a46549ddc2340f1841c0c4aee2">fds_record_write_reserved</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9374d0e6608b9b07940401b407617f8dadeaba2d3641cb94365a6a641bacdd367"></a>FDS_EVT_UPDATE&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__fds.html#gaa71e86ec4e3022063eb08c3411636561">fds_record_update</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9374d0e6608b9b07940401b407617f8dacf428d0ef9ce66354b569f2bae9264f0"></a>FDS_EVT_DEL_RECORD&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__fds.html#gaf97cabe15afd74024e4250e931c720cd">fds_record_delete</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9374d0e6608b9b07940401b407617f8da121a81e149c30cca53b1bd127af9f7e8"></a>FDS_EVT_DEL_FILE&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__fds.html#ga8b4618e5f1a5a86296db525508f5692a">fds_file_delete</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9374d0e6608b9b07940401b407617f8dab2b29ea4c2572f34c6f4f164ea7db732"></a>FDS_EVT_GC&#160;</td><td class="fielddoc"><p>Event for <a class="el" href="group__fds.html#ga90285f376c435c64b352023e725b7ebb">fds_gc</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga68a38771138f19c40d8ef9f61582a155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga68a38771138f19c40d8ef9f61582a155">&#9670;&nbsp;</a></span>fds_descriptor_from_rec_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_descriptor_from_rec_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>record_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for obtaining a descriptor from a record ID. </p>
<p>This function can be used to reconstruct a descriptor from a record ID, like the one that is passed to the callback function.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not check whether a record with the given record ID exists. If a non-existing record ID is supplied, the resulting descriptor is invalid and will cause other functions to fail when it is supplied as parameter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record with the given record ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">record_id</td><td>The record ID for which a descriptor should be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If a descriptor was returned. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b4618e5f1a5a86296db525508f5692a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b4618e5f1a5a86296db525508f5692a">&#9670;&nbsp;</a></span>fds_file_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_file_delete </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>file_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for deleting all records in a file. </p>
<p>This function deletes a file, including all its records. Deleted records cannot be located using <a class="el" href="group__fds.html#ga15112e682cc2c4771945fcf5816e3b1b">fds_record_find</a>, <a class="el" href="group__fds.html#gad5a5ad980e0b2b27a693ca5c0296e9c2">fds_record_find_by_key</a>, or <a class="el" href="group__fds.html#gaa5bc8844b42493c8d9cdc02d245718fc">fds_record_find_in_file</a>. Additionally, they can no longer be opened using <a class="el" href="group__fds.html#gab718add23b30b0e663e48a781645879f">fds_record_open</a>.</p>
<p>Note that deleting records does not free the space they occupy in flash memory. To reclaim flash space used by deleted records, call <a class="el" href="group__fds.html#ga90285f376c435c64b352023e725b7ebb">fds_gc</a> to run garbage collection.</p>
<p>This function is asynchronous. Completion is reported through an event that is sent to the registered event handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_id</td><td>The ID of the file to be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_INVALID_ARG</td><td>If the specified <code>file_id</code> is invalid. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_QUEUES</td><td>If the operation queue is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga90285f376c435c64b352023e725b7ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90285f376c435c64b352023e725b7ebb">&#9670;&nbsp;</a></span>fds_gc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_gc </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for running garbage collection. </p>
<p>Garbage collection reclaims the flash space that is occupied by records that have been deleted, or that failed to be completely written due to, for example, a power loss.</p>
<p>This function is asynchronous. Completion is reported through an event that is sent to the registered event handler function.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_QUEUES</td><td>If the operation queue is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2382947318f107a9c8d08a9a5916ccf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2382947318f107a9c8d08a9a5916ccf4">&#9670;&nbsp;</a></span>fds_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for initializing the module. </p>
<p>This function initializes the module and installs the file system (unless it is installed already).</p>
<p>This function is asynchronous. Completion is reported through an event. Make sure to call <a class="el" href="group__fds.html#gadc98fdddd6201988f408116ee0dc4fe5">fds_register</a> before calling <a class="el" href="group__fds.html#ga2382947318f107a9c8d08a9a5916ccf4">fds_init</a> so that you receive the completion event.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_PAGES</td><td>If there is no space available in flash memory to install the file system. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8d958ecd339e9d2fc3dba40c4503eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8d958ecd339e9d2fc3dba40c4503eea">&#9670;&nbsp;</a></span>fds_record_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for closing a record. </p>
<p>Closing a record allows garbage collection to run on the virtual page in which the record is stored (if no other records remain open on that page). The descriptor passed as an argument must be the same as the one used to open the record using <a class="el" href="group__fds.html#gab718add23b30b0e663e48a781645879f">fds_record_open</a>.</p>
<p>Note that closing a record does not invalidate its descriptor. You can still supply the descriptor to all functions that accept a record descriptor as a parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_desc</td><td>The descriptor of the record to close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the record was closed successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_OPEN_RECORDS</td><td>If the record is not open. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_FOUND</td><td>If the record could not be found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf97cabe15afd74024e4250e931c720cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf97cabe15afd74024e4250e931c720cd">&#9670;&nbsp;</a></span>fds_record_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for deleting a record. </p>
<p>Deleted records cannot be located using <a class="el" href="group__fds.html#ga15112e682cc2c4771945fcf5816e3b1b">fds_record_find</a>, <a class="el" href="group__fds.html#gad5a5ad980e0b2b27a693ca5c0296e9c2">fds_record_find_by_key</a>, or <a class="el" href="group__fds.html#gaa5bc8844b42493c8d9cdc02d245718fc">fds_record_find_in_file</a>. Additionally, they can no longer be opened using <a class="el" href="group__fds.html#gab718add23b30b0e663e48a781645879f">fds_record_open</a>.</p>
<p>Note that deleting a record does not free the space it occupies in flash memory. To reclaim flash space used by deleted records, call <a class="el" href="group__fds.html#ga90285f376c435c64b352023e725b7ebb">fds_gc</a> to run garbage collection.</p>
<p>This function is asynchronous. Completion is reported through an event that is sent to the registered event handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_desc</td><td>The descriptor of the record that should be deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If the specified record descriptor <code>p_desc</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_QUEUES</td><td>If the operation queue is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15112e682cc2c4771945fcf5816e3b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15112e682cc2c4771945fcf5816e3b1b">&#9670;&nbsp;</a></span>fds_record_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_find </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>file_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>record_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for searching for records with a given record key in a file. </p>
<p>This function finds the first record in a file that has the given record key. To search for the next record with the same key in the file, call the function again and supply the same <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> structure to resume searching from the last record that was found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_id</td><td>The file ID. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">record_key</td><td>The record key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record that was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token containing information about the progress of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If a record was found. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> or <code>p_token</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_FOUND</td><td>If no matching record was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad5a5ad980e0b2b27a693ca5c0296e9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5a5ad980e0b2b27a693ca5c0296e9c2">&#9670;&nbsp;</a></span>fds_record_find_by_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_find_by_key </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>record_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for searching for records with a given record key. </p>
<p>This function finds the first record with a given record key, independent of the file it belongs to. To search for the next record with the same key, call the function again and supply the same <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> structure to resume searching from the last record that was found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">record_key</td><td>The record key. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record that was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token containing information about the progress of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If a record was found. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> or <code>p_token</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_FOUND</td><td>If no record with the given key was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa5bc8844b42493c8d9cdc02d245718fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5bc8844b42493c8d9cdc02d245718fc">&#9670;&nbsp;</a></span>fds_record_find_in_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_find_in_file </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>file_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for searching for any record in a file. </p>
<p>This function finds the first record in a file, independent of its record key. To search for the next record in the same file, call the function again and supply the same <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> structure to resume searching from the last record that was found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">file_id</td><td>The file ID. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record that was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token containing information about the progress of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If a record was found. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> or <code>p_token</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_FOUND</td><td>If no matching record was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d56475359f7fd1343d9815dd5b4b310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d56475359f7fd1343d9815dd5b4b310">&#9670;&nbsp;</a></span>fds_record_id_from_desc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_id_from_desc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> const *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_record_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for obtaining a record ID from a record descriptor. </p>
<p>This function can be used to extract a record ID from a descriptor. For example, you could use it in the callback function to compare the record ID of an event to the record IDs of the records for which you have a descriptor.</p>
<dl class="section warning"><dt>Warning</dt><dd>This function does not check whether the record descriptor is valid. If the descriptor is not initialized or has been tampered with, the resulting record ID might be invalid.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_desc</td><td>The descriptor from which the record ID should be extracted. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_record_id</td><td>The record ID that is contained in the given descriptor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If a record ID was returned. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> or <code>p_record_id</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71a586b6017690b888ead2a8bd04caee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71a586b6017690b888ead2a8bd04caee">&#9670;&nbsp;</a></span>fds_record_iterate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_iterate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for iterating through all records in flash. </p>
<p>To search for the next record, call the function again and supply the same <a class="el" href="structfds__find__token__t.html">fds_find_token_t</a> structure to resume searching from the last record that was found.</p>
<p>Note that the order with which records are iterated is not defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record that was found. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token containing information about the progress of the operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If a record was found. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> or <code>p_token</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_FOUND</td><td>If no matching record was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab718add23b30b0e663e48a781645879f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab718add23b30b0e663e48a781645879f">&#9670;&nbsp;</a></span>fds_record_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__flash__record__t.html">fds_flash_record_t</a> *&#160;</td>
          <td class="paramname"><em>p_flash_record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for opening a record for reading. </p>
<p>This function opens a record that is stored in flash, so that it can be read. The function initializes an <a class="el" href="structfds__flash__record__t.html">fds_flash_record_t</a> structure, which can be used to access the record data as well as its associated metadata. The pointers provided in the <a class="el" href="structfds__flash__record__t.html">fds_flash_record_t</a> structure are pointers to flash memory.</p>
<p>Opening a record with <a class="el" href="group__fds.html#gab718add23b30b0e663e48a781645879f">fds_record_open</a> prevents garbage collection to run on the virtual flash page in which record is stored, so that the contents of the memory pointed by fields in <a class="el" href="structfds__flash__record__t.html">fds_flash_record_t</a> are guaranteed to remain unmodified as long as the record is kept open.</p>
<p>When you are done reading a record, call <a class="el" href="group__fds.html#gaf8d958ecd339e9d2fc3dba40c4503eea">fds_record_close</a> to close it. Garbage collection can then reclaim space on the virtual page where the record is stored. Note that you must provide the same descriptor for <a class="el" href="group__fds.html#gaf8d958ecd339e9d2fc3dba40c4503eea">fds_record_close</a> as you did for this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_desc</td><td>The descriptor of the record to open. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">p_flash_record</td><td>The record, as stored in flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the record was opened successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_desc</code> or <code>p_flash_record</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_FOUND</td><td>If the record was not found. It might have been deleted, or it might not have been written yet. </td></tr>
    <tr><td class="paramname">FDS_ERR_CRC_CHECK_FAILED</td><td>If the CRC check for the record failed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa71e86ec4e3022063eb08c3411636561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa71e86ec4e3022063eb08c3411636561">&#9670;&nbsp;</a></span>fds_record_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_update </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__record__t.html">fds_record_t</a> const *&#160;</td>
          <td class="paramname"><em>p_record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for updating a record. </p>
<p>Updating a record first writes a new record (<code>p_record</code>) to flash and then deletes the old record (identified by <code>p_desc</code>).</p>
<p>There are no restrictions on the file ID and the record key, except that the record key must be different from <a class="el" href="group__fds.html#gab855b564bf9f4cac404a71a16aca2906">FDS_RECORD_KEY_DIRTY</a> and the file ID must be different from <a class="el" href="group__fds.html#gade414e234180e1983d44341bce184853">FDS_FILE_ID_INVALID</a>. In particular, no restrictions are made regarding the uniqueness of the file ID or the record key. All records with the same file ID are grouped into one file. If no file with the specified ID exists, it is created. There can be multiple records with the same record key in a file.</p>
<p>Record data can consist of multiple chunks. The data must be aligned to a 4 byte boundary, and because it is not buffered internally, it must be kept in memory until the callback for the operation has been received. The length of the data must not exceed <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a94b7203878878277663b572bded3499d">FDS_VIRTUAL_PAGE_SIZE</a> words minus 14 bytes.</p>
<p>This function is asynchronous. Completion is reported through an event that is sent to the registered event handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p_desc</td><td>The descriptor of the record to update. When the function returns with FDS_SUCCESS, this parameter contains the descriptor of the newly written record. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_record</td><td>The updated record to be written to flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_INVALID_ARG</td><td>If the file ID or the record key is invalid. </td></tr>
    <tr><td class="paramname">FDS_ERR_UNALIGNED_ADDR</td><td>If the record data is not aligned to a 4 byte boundary. </td></tr>
    <tr><td class="paramname">FDS_ERR_RECORD_TOO_LARGE</td><td>If the record data exceeds the maximum length. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_QUEUES</td><td>If the operation queue is full or there are more record chunks than can be buffered. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_FLASH</td><td>If there is not enough free space in flash to store the updated record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0114083241dc287c7145fe113c9adc2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0114083241dc287c7145fe113c9adc2c">&#9670;&nbsp;</a></span>fds_record_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__record__t.html">fds_record_t</a> const *&#160;</td>
          <td class="paramname"><em>p_record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing a record to flash. </p>
<p>There are no restrictions on the file ID and the record key, except that the record key must be different from <a class="el" href="group__fds.html#gab855b564bf9f4cac404a71a16aca2906">FDS_RECORD_KEY_DIRTY</a> and the file ID must be different from <a class="el" href="group__fds.html#gade414e234180e1983d44341bce184853">FDS_FILE_ID_INVALID</a>. In particular, no restrictions are made regarding the uniqueness of the file ID or the record key. All records with the same file ID are grouped into one file. If no file with the specified ID exists, it is created. There can be multiple records with the same record key in a file.</p>
<p>Some modules need exclusive use of certain file IDs and record keys. See lib_fds_functionality_keys for details.</p>
<p>Record data can consist of multiple chunks. The data must be aligned to a 4 byte boundary, and because it is not buffered internally, it must be kept in memory until the callback for the operation has been received. The length of the data must not exceed <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a94b7203878878277663b572bded3499d">FDS_VIRTUAL_PAGE_SIZE</a> words minus 14 bytes.</p>
<p>This function is asynchronous. Completion is reported through an event that is sent to the registered event handler function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record that was written. Pass NULL if you do not need the descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_record</td><td>The record to be written to flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_record</code> is NULL. </td></tr>
    <tr><td class="paramname">FDS_ERR_INVALID_ARG</td><td>If the file ID or the record key is invalid. </td></tr>
    <tr><td class="paramname">FDS_ERR_UNALIGNED_ADDR</td><td>If the record data is not aligned to a 4 byte boundary. </td></tr>
    <tr><td class="paramname">FDS_ERR_RECORD_TOO_LARGE</td><td>If the record data exceeds the maximum length. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_QUEUES</td><td>If the operation queue is full or there are more record chunks than can be buffered. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_FLASH</td><td>If there is not enough free space in flash to store the record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39ce61a46549ddc2340f1841c0c4aee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39ce61a46549ddc2340f1841c0c4aee2">&#9670;&nbsp;</a></span>fds_record_write_reserved()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_record_write_reserved </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__record__desc__t.html">fds_record_desc_t</a> *&#160;</td>
          <td class="paramname"><em>p_desc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__record__t.html">fds_record_t</a> const *&#160;</td>
          <td class="paramname"><em>p_record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a> const *&#160;</td>
          <td class="paramname"><em>p_token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for writing a record to a space in flash that was reserved using <a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a>. </p>
<p>There are no restrictions on the file ID and the record key, except that the record key must be different from <a class="el" href="group__fds.html#gab855b564bf9f4cac404a71a16aca2906">FDS_RECORD_KEY_DIRTY</a> and the file ID must be different from <a class="el" href="group__fds.html#gade414e234180e1983d44341bce184853">FDS_FILE_ID_INVALID</a>. In particular, no restrictions are made regarding the uniqueness of the file ID or the record key. All records with the same file ID are grouped into one file. If no file with the specified ID exists, it is created. There can be multiple records with the same record key in a file.</p>
<p>Record data can consist of multiple chunks. The data must be aligned to a 4 byte boundary, and because it is not buffered internally, it must be kept in memory until the callback for the operation has been received. The length of the data must not exceed <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a94b7203878878277663b572bded3499d">FDS_VIRTUAL_PAGE_SIZE</a> words minus 14 bytes.</p>
<p>This function is asynchronous. Completion is reported through an event that is sent to the registered event handler function.</p>
<dl class="section note"><dt>Note</dt><dd>This function behaves similarly to <a class="el" href="group__fds.html#ga0114083241dc287c7145fe113c9adc2c">fds_record_write</a>, with the exception that it never fails with the error <a class="el" href="group__fds.html#gga9334a5b9057f32da96db9b5c6a045d67abb56c173c55f594c5c31e11da12da5a3">FDS_ERR_NO_SPACE_IN_FLASH</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_desc</td><td>The descriptor of the record that was written. Pass NULL if you do not need the descriptor. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_record</td><td>The record to be written to flash. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p_token</td><td>The token that identifies the space reserved in flash.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the operation was queued successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_token</code> is NULL instead of a valid token address. </td></tr>
    <tr><td class="paramname">FDS_ERR_INVALID_ARG</td><td>If the file ID or the record key is invalid. </td></tr>
    <tr><td class="paramname">FDS_ERR_UNALIGNED_ADDR</td><td>If the record data is not aligned to a 4 byte boundary. </td></tr>
    <tr><td class="paramname">FDS_ERR_RECORD_TOO_LARGE</td><td>If the record data exceeds the maximum length. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_QUEUES</td><td>If the operation queue is full or there are more record chunks than can be buffered. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadc98fdddd6201988f408116ee0dc4fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc98fdddd6201988f408116ee0dc4fe5">&#9670;&nbsp;</a></span>fds_register()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_register </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__fds.html#ga5d6c35d06f7d73bf0a2458a553f52fea">fds_cb_t</a>&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for registering an FDS event handler. </p>
<p>The maximum amount of handlers that can be registered can be configured by changing the value of <a class="el" href="config_2nrf52840_2config_2sdk__config_8h.html#a9174af508432f2cfdc60cb77bd0a5062">FDS_MAX_USERS</a> in fds_config.h.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>The event handler function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the event handler was registered successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_USER_LIMIT_REACHED</td><td>If the maximum number of registered callbacks is reached. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3ee0de6ed4af09fd7d4b3ae7751546ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee0de6ed4af09fd7d4b3ae7751546ce">&#9670;&nbsp;</a></span>fds_reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length_words</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for reserving space in flash. </p>
<p>This function can be used to reserve space in flash memory. To write a record into the reserved space, use <a class="el" href="group__fds.html#ga39ce61a46549ddc2340f1841c0c4aee2">fds_record_write_reserved</a>. Alternatively, use <a class="el" href="group__fds.html#ga59947ed9ab3156d32b284a05783d9b3e">fds_reserve_cancel</a> to cancel a reservation.</p>
<p>Note that this function does not write any data to flash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_token</td><td>A token that can be used to write a record in the reserved space or cancel the reservation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length_words</td><td>The length of the record data (in 4-byte words).</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the flash space was reserved successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_token</code> is NULL instead of a valid token address. </td></tr>
    <tr><td class="paramname">FDS_ERR_RECORD_TOO_LARGE</td><td>If the record length exceeds the maximum length. </td></tr>
    <tr><td class="paramname">FDS_ERR_NO_SPACE_IN_FLASH</td><td>If there is not enough free space in flash to store the record. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59947ed9ab3156d32b284a05783d9b3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59947ed9ab3156d32b284a05783d9b3e">&#9670;&nbsp;</a></span>fds_reserve_cancel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_reserve_cancel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__reserve__token__t.html">fds_reserve_token_t</a> *&#160;</td>
          <td class="paramname"><em>p_token</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for canceling an <a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a> operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">p_token</td><td>The token that identifies the reservation, produced by <a class="el" href="group__fds.html#ga3ee0de6ed4af09fd7d4b3ae7751546ce">fds_reserve</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the reservation was canceled. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_token</code> is NULL instead of a valid token address. </td></tr>
    <tr><td class="paramname">FDS_ERR_INVALID_ARG</td><td>If <code>p_token</code> contains invalid data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5d3f04e9755408293408be377f7eeaf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d3f04e9755408293408be377f7eeaf9">&#9670;&nbsp;</a></span>fds_stat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__ble__ipsp__errors.html#gaf6c20fb483036617204f12e99e0b997b">ret_code_t</a> fds_stat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structfds__stat__t.html">fds_stat_t</a> *&#160;</td>
          <td class="paramname"><em>p_stat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for retrieving file system statistics. </p>
<p>This function retrieves file system statistics, such as the number of open records, the space that can be reclaimed by garbage collection, and others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">p_stat</td><td>File system statistics.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">FDS_SUCCESS</td><td>If the statistics were returned successfully. </td></tr>
    <tr><td class="paramname">FDS_ERR_NOT_INITIALIZED</td><td>If the module is not initialized. </td></tr>
    <tr><td class="paramname">FDS_ERR_NULL_ARG</td><td>If <code>p_stat</code> is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="gae00d56ea54d55148b7a9db7f786dc655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae00d56ea54d55148b7a9db7f786dc655">&#9670;&nbsp;</a></span>ANON_UNIONS_DISABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ANON_UNIONS_DISABLE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga4dd225920a1695db74f70a5697ea2cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dd225920a1695db74f70a5697ea2cd5">&#9670;&nbsp;</a></span>ANON_UNIONS_ENABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ANON_UNIONS_ENABLE</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
